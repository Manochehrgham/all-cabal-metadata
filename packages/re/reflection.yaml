changelog-type: ''
hash: ea003eb2ee89880875b5d63724d310140626ae0c9c73dd3a4e6ca78a648e9b1d
synopsis: Reifies arbitrary terms into types that can be reflected back into terms
changelog: ''
all-versions:
- '0.0.0'
- '0.1.0'
- '0.1.1'
- '0.2.0'
- '0.3.0'
- '0.3.1'
- '0.3.2'
- '0.3.3'
- '0.3.5'
- '0.4.0'
- '0.4.0.1'
- '0.4.0.2'
- '0.4.1'
- '0.4.1.1'
- '0.5'
- '0.5.0.1'
- '0.6'
- '0.7'
- '0.8'
- '0.9'
- '1.0'
- '1.1'
- '1.1.1'
- '1.1.2'
- '1.1.3'
- '1.1.4'
- '1.1.5'
- '1.1.5.1'
- '1.1.6'
- '1.1.7'
- '1.2.0.1'
- '1.3'
- '1.3.1'
- '1.3.2'
- '1.4'
- '1.5.1'
- '1.5.1.1'
- '1.5.1.2'
latest: '1.5.1.2'
description-type: haddock
description: ! 'This package addresses the /configuration problem/ which is

  propogating configurations that are available at run-time, allowing

  multible configurations to coexist without resorting to mutable

  global variables or ''System.IO.Unsafe.unsafePerformIO''.


  An example is modular arithmetic where the modulus itself can be

  supplied at run-time:


  @

  foo :: Modular s => Modulus s

  foo = 1000 * 1000 * 5 + 2000

  @

  >>> withModulus 1280 foo

  1040


  given the following setup:


  @

  &#123;-# LANGUAGE ScopedTypeVariables, RankNTypes, ConstraintKinds, FlexibleContexts,
  UndecidableInstances #-&#125;


  import Data.Proxy      (Proxy(Proxy))

  import Data.Reflection (Reifies, reflect, reify)

  @


  and definitions:


  @

  data Modulus s = M &#123; getModulus :: Integer &#125;

  type Modular s = ''Data.Reflection.Reifies'' s Integer


  normalize :: forall s. Modular s => Integer -> Modulus s

  normalize n = M (mod n modulus) where

  &#x20;  modulus = ''Data.Reflection.reflect'' (''Data.Proxy.Proxy'' :: ''Data.Proxy.Proxy''
  s)


  instance Modular s => Num (Modulus s) where

  &#x20;  M a + M b = normalize (a + b)

  &#x20;  M a * M b = normalize (a * b)


  withModulus :: Integer -> (forall s. Modular s => Modulus s) -> Integer

  withModulus m v = ''Data.Reflection.reify'' m (getModulus . asProxyOf v)

  &#x20;  where

  &#x20;  asProxyOf :: f s -> Proxy s -> f s

  &#x20;  asProxyOf = const

  @


  That package is an implementation of the ideas presented in the

  paper \"Functional Pearl: Implicit Configurations\" by Oleg Kiselyov

  and Chung-chieh Shan (<http://okmij.org/ftp/Haskell/tr-15-04.pdf original paper>).
  However, the API has been streamlined to improve

  performance.


  Austin Seipp''s tutorial <https://www.fpcomplete.com/user/thoughtpolice/using-reflection
  Reflecting values to types and back> provides a summary of the

  approach taken by this library, along with more motivating

  examples.'
