homepage: https://bitbucket.org/wuzzeb/react-flux
changelog-type: markdown
hash: 23d235363c978cdf01de4dd560f8b6932f78b302981f82cd8543886f80a15f99
test-bench-deps: {}
maintainer: John Lenz <wuzzeb@gmail.com>
synopsis: A binding to React based on the Flux application architecture for GHCJS
changelog: ! "# 1.0.2\n\n* Update to build with latest ghcjs master.  The breaking
  change was\n  https://github.com/ghcjs/ghcjs-base/commit/968dff527c2be2d3d4815e437ad9b2931ea1f35d\n
  \ which renamed JSRef to JSVal.  Therefore, react-flux no longer builds with ghcjs
  versions without\n  this commit.\n\n# 1.0.1\n\n* Add formatting support for properties
  to `React.Flux.Addons.Intl`.  These are needed for example to translate\n  the placeholder
  text for an input element.  This improvement caused a few changes to the types the
  Internal module.\n\n* Add a new example [purecss-side-menu](https://bitbucket.org/wuzzeb/react-flux/src/tip/example/purecss-side-menu)\n
  \ showing a responsive side menu built with PureCSS.\n\n* Add `classNames` function
  to `React.Flux.PropertiesAndEvents` to allow easily setting class names\n  based
  on calculations.\n\n* Add a new module `React.Flux.Combinators` which is re-exported
  by `React.Flux`.  The `Combinators` module\n  contains useful utilities that while
  not required, make your life a little simpler.\n\n# 1.0.0\n\n* Bindings to react-intl
  (http://formatjs.io/react/) for i18n support.  This is useful even if your app is\n
  \ a single language, as it allows easy number, date, relative time, and message
  formatting like pluralization.\n  It also supports multiple locales and translations
  of messages.\n\n* The type of `callback` has extended to allow arbitrary function
  properties to be\n  passed to foreign classes.  The old `callback` accepted callbacks
  of type `Aeson.Value -> handler`\n  while the new callback allows functions of any
  number of arguments, as long as each argument implements\n  `FromJSVal`.  Since
  `Aeson.Value` implements `FromJSVal`, any existing calls to `callback` should still
  work.\n  This change also caused some changes to types in `React.Flux.Internal`.\n\n*
  Add a function `nestedProperty` to `React.Flux.PropertiesAndEvents` to create nested
  properties.\n\n* Support for React 0.14\n    * React 0.13 and 0.14 are both supported
  from the same Haskell code, the differences are handled internally.\n    * If you
  are using React 0.14, you will have to include `react-dom.min.js` and make sure
  the\n      `ReactDOM` variable is protected by closure similar to how `React` must
  be protected.\n    * `initializeTouchEvents` has been removed from React 0.14, so
  you can remove the call from your app.\n    * The SVG `image_` tag is now supported
  by `React.Flux.DOM`.\n    * The new media events on images and videos don't have
  direct Haskell equivalents, instead the handlers can be\n      created by the new
  `on` function in `React.Flux.PropertiesAndEvents`.\n    * The CSS transitions in
  `React.Flux.Addons.React` were made simpler by just passing the raw\n      properties.
  \ There were several changes to the possible properties in React 0.14 and covering
  them all\n      from Haskell is not worth it when the properties can easily be created
  directly.\n\n* `reactRenderToString` was added to allow executing a react-flux application
  using node.\n\n# 0.9.4\n\n* Fix to build with latest ghcjs-base (requires at least
  aaa4d59117f37d1b9c60a154a9128b3bcc6301cd)\n  of ghcjs-base), so you may need to
  recompile ghcjs and ghcjs-base.\n* Add a function 'property' to create a property
  from any JSVal, not just Aeson values.\n* Add a function 'elementProperty' to create
  a property from a ReactElementM, useful for\n  interacting with foreign React classes.\n\n#
  0.9.3\n\n* Don't require web-routes dependency if not building the routing example\n\n#
  0.9.2\n\n* Bindings to react-bootstrap and the react addons\n* Add new routing example
  application (thanks Vladimir Sekissov!)\n\n# 0.9.1\n\n* Switch to use the improved-base
  branch of ghcjs (thanks Vladimir Sekissov!)\n\n# 0.9.0\n\n* Initial release\n"
basic-deps:
  bytestring: -any
  base: ! '>=4.8 && <5'
  time: ! '>=1.5'
  unordered-containers: -any
  text: ! '>=1.2'
  react-flux: -any
  mtl: ! '>=2.1'
  deepseq: -any
  aeson: ! '>=0.8'
  template-haskell: ! '>=2.10'
all-versions:
- '0.9.0'
- '0.9.1'
- '0.9.2'
- '0.9.3'
- '0.9.4'
- '1.0.0'
- '1.0.1'
- '1.0.2'
author: John Lenz <wuzzeb@gmail.com>
latest: '1.0.2'
description-type: markdown
description: ! 'A GHCJS binding to [React](https://facebook.github.io/react/) based
  on the

  [Flux](https://facebook.github.io/flux/) design.  The flux design pushes state and
  complicated logic

  out of the view, allowing the rendering functions and event handlers to be pure
  Haskell functions.

  When combined with React''s composable components and the one-way flow of data,
  React, Flux, and

  GHCJS work very well together.


  # Docs


  The [haddocks](https://hackage.haskell.org/package/react-flux) contain the documentation.


  # Build


  This package requires GHC 7.10.2 and the improved-base branch of ghcjs.

  I followed the instructions in the [ghcjs wiki](https://github.com/ghcjs/ghcjs/wiki/GHCJS-with-GHC-7.10)

  to install the improved-base branch.  Once ghcjs is installed, I use the following
  to build react-flux:


  ~~~

  echo "compiler: ghcjs" > cabal.config

  cabal configure

  cabal build

  ~~~


  # Example Applications


  The source contains some [example applications](https://bitbucket.org/wuzzeb/react-flux/src/tip/example).

  To try out the TODO example, execute


  ~~~

  cabal configure -fexample

  cabal build

  cd example/todo

  make

  firefox todo.html

  ~~~


  If you don''t have closure installed, you can open `todo-dev.html` instead of `todo.html`.  For
  more details on

  the example applications, see the [README](https://bitbucket.org/wuzzeb/react-flux/src/tip/example/README.md).


  # Test Suite


  To run the test suite, first you must build both the example applications and the
  test-client.  (The

  test-client is a react-flux application which contains code for everything not contained
  in the todo

  example.)


  ~~~

  echo "compiler: ghcjs" > cabal.config

  cabal configure -fexample -ftest-client

  cabal build

  ~~~


  The above builds the TODO application and the test client.

  Next, install [selenium-server-standalone](http://www.seleniumhq.org/download/)
  (also from

  [npm](https://www.npmjs.com/package/selenium-server-standalone-jar)).  Then, build
  the

  [hspec-webdriver](https://hackage.haskell.org/package/hspec-webdriver) test suite
  using GHC (not

  GHCJS).  I use stack for this, although you can use cabal too if you like.  Also,
  at the moment, the prerelease

  of the react-intl library must be installed from npm.


  ~~~

  cd test/client

  npm install react-intl@next

  cd ../spec

  stack build

  ~~~


  Finally, start selenium-server-standalone and execute the test suite.  Make sure
  you also have

  closure installed, since the test suite will compress the todo app before testing
  it.  It must be

  started from the `test/spec` directory, otherwise it does not find the correct javascript
  files.


  ~~~

  stack exec react-flux-spec

  ~~~


  # Other Projects


  It differes significantly from the other two react bindings,

  [react-haskell](https://github.com/joelburget/react-haskell) and

  [ghcjs-react](https://github.com/fpco/ghcjs-react).  In particular, the major difference
  is how

  events are handled.  In the Flux design, the state is moved out out of the view
  and then handlers

  produce actions which transform the state.  Thus there is a one-way flow of data
  from the store into

  the view.  In contrast, react-haskell and ghcjs-react both have event signals propagaing
  up the

  react component tree, transforming state at each node.  In particular, react-haskell
  with its InSig

  and OutSig have the signals propagate up the tree and optionally transform state
  at each node and

  change the type of the signal.

'
license-name: BSD3
