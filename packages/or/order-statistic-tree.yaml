homepage: ''
changelog-type: ''
hash: de2ebc3ca6a565dd54309f828af0410d3e429d3a0b7fe958af20b715d3fcaab1
test-bench-deps:
  base: ==4.8.*
  criterion: ! '>=1.1.0.0 && <1.2'
  order-statistic-tree: -any
  containers: ! '>=0.5 && <0.6'
  tasty-quickcheck: ! '>=0.8.4 && <0.9'
  tasty-hunit: ! '>=0.9.2 && <0.10'
  random: ! '>=1.1 && <1.2'
  tasty: ! '>=0.11 && <0.12'
  deepseq: ! '>=1.4 && <1.5'
maintainer: mz@lambdasoft.ru
synopsis: Order statistic trees based on weight-balanced trees
changelog: ''
basic-deps:
  base: ! '>=4.8 && <4.9'
all-versions:
- '0.1.0.0'
- '0.1.0.1'
author: Mansur Ziiatdinov
latest: '0.1.0.1'
description-type: haddock
description: ! 'This repository contains an implementation of order statistic tree
  in Haskell programming language.

  I could not find an order statistic tree at Hackage, so I have to develop one.


  This implementation uses weight-balanced trees which are desribed in


  - Hirai, Yoichi, and Kazuhiko Yamamoto. "Balancing weight-balanced trees." Journal
  of Functional Programming 21.03 (2011): 287-307.


  Also some code is based on containers package.


  Implementation of order statistic tree is described in


  - Cormen, T.H., Leiserson, Rivest, Stein. Introduction to algorithms. The MIT Press.
  3rd ed.


  = Benchmarks


  I tried to make this tree as fast as possible. The results on my i7-4790 with 16Gb
  RAM are following:


  - OSTree was created from 1.000.000 random numbers in 2.087 ± 0.021 s (e.g. for
  Data.Map.Strict - 1.977 ± 0.016 s);

  - deletion from OSTree with 1.000.000 random numbers was made in 13.94 ± 0.93 ms;

  - lookup from OSTree with 1.000.000 random numbers was made in 208.2 ± 3.48 ns;

  - selection from OSTree with 1.000.000 random numbers was made in 92.72 ± 1.91 ns;

  - full testing protocol can be found in result-bench.txt.'
license-name: BSD3
