changelog-type: ''
hash: 6e5ec7da68f2777ae28ff3ccc43d6c54b68835fccf14f18d726f8c17ca31189f
synopsis: Fast JSON parsing and encoding
changelog: ''
all-versions:
- '0.1.0.0'
- '0.2.0.0'
- '0.3.0.0'
- '0.3.1.0'
- '0.3.1.1'
- '0.3.2.0'
- '0.3.2.1'
- '0.3.2.2'
- '0.3.2.3'
- '0.3.2.4'
- '0.3.2.5'
- '0.3.2.6'
- '0.3.2.7'
- '0.3.2.8'
- '0.3.2.9'
- '0.3.2.10'
- '0.3.2.11'
- '0.3.2.12'
- '0.3.2.13'
- '0.3.2.14'
- '0.4.0.0'
- '0.4.0.1'
- '0.5.0.0'
- '0.6.0.0'
- '0.6.0.1'
- '0.6.0.2'
- '0.6.1.0'
- '0.6.2.0'
- '0.6.2.1'
- '0.7.0.0'
- '0.7.0.1'
- '0.7.0.2'
- '0.7.0.3'
- '0.7.0.4'
- '0.7.0.5'
- '0.7.0.6'
- '0.8.0.0'
- '0.8.0.1'
- '0.8.0.2'
- '0.8.1.0'
latest: '0.8.1.0'
description-type: haddock
description: ! 'A JSON parsing and encoding library optimized for ease of use

  and high performance.


  To get started, see the documentation for the @Data.Aeson@ module

  below.


  Parsing performance on an early 2011 MacBook Pro (2.2GHz Core i7),

  running 64-bit GHC 7.6.3, for mostly-English tweets from Twitter''s

  JSON search API:


  * 0.8 KB: 34124 msg\/sec (27.8 MB\/sec)


  * 6.4 KB: 6833 msg\/sec (43.0 MB\/sec)


  * 11.8 KB: 3410 msg\/sec (39.2 MB\/sec)


  * 31.2 KB: 1157 msg\/sec (35.3 MB\/sec)


  * 61.5 KB: 542 msg\/sec (32.5 MB\/sec)


  Handling heavily-escaped text is a little more work.  Here is

  parsing performance with Japanese tweets, where much of the text

  is entirely Unicode-escaped.


  * 14.6 KB: 2101 msg\/sec (30.0 MB\/sec)


  * 44.1 KB: 667 msg\/sec (28.7 MB\/sec)


  * 82.9 KB: 360 msg\/sec (29.2 MB\/sec)


  Encoding performance on the same machine and data:


  * English, 0.8 KB: 109697 msg\/sec (89.3 MB\/sec)


  * English, 6.4 KB: 18517 msg\/sec (116.4 MB\/sec)


  * Engish, 61.5 KB: 1963 msg\/sec (118.0 MB\/sec)


  * Japanese, 14.6 KB: 12140 msg\/sec (173.5 MB\/sec)


  * Japanese, 44.1 KB: 3980 msg\/sec (171.3 MB\/sec)


  (A note on naming: in Greek mythology, Aeson was the father of Jason.)'
