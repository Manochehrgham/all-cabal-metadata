changelog-type: markdown
hash: 42f9cb2c47246402eeb104815ce9fe810fac5c0e73c5286f335ee5c0bbbd41c5
test-bench-deps:
  test-framework-hunit: -any
  bytestring: -any
  test-framework: -any
  base: -any
  time: -any
  unordered-containers: -any
  text: -any
  test-framework-quickcheck2: -any
  HUnit: -any
  containers: -any
  ghc-prim: ! '>=0.2'
  old-locale: -any
  attoparsec: -any
  QuickCheck: -any
  aeson: -any
  template-haskell: -any
  vector: -any
synopsis: Fast JSON parsing and encoding
changelog: ! "0.8.1.0\n\n* Encoding a Scientific value with a huge exponent is now
  handled\n  efficiently.  (This would previously allocate a huge\n  arbitrary-precision
  integer, potentially leading to a denial of\n  service.)\n\n* Handling of strings
  that contain backslash escape sequences is\n  greatly improved.  For a pathological
  string containing almost a\n  megabyte of consecutive backslashes, the new implementation
  is 27x\n  faster and uses 42x less memory.\n\n* The ToJSON instance for UTCTime
  is rendered with higher (picosecond)\n  resolution.\n\n* The value parser now correctly
  handles leading whitespace.\n\n* New instances of ToJSON and FromJSON for Data.Sequence
  and\n  Data.Functor.Identity.  The Value type now has a Read instance.\n\n* ZonedTime
  parser ordering now favours the standard JSON format,\n  increasing efficiency in
  the common case.\n\n* Encoding to a Text.Builder now escapes '<' and '>' characters,
  to\n  reduce XSS risk.\n\n0.8.0.2\n\n* Fix ToJSON instance for 15-tuples (see #223).\n\n0.8.0.1\n\n*
  Support time-1.5.\n\n0.8.0.0\n\n* Add ToJSON and FromJSON instances for tuples of
  up to 15 elements.\n\n0.7.1.0\n\n* Major compiler and library compatibility changes:
  we have dropped\n  support for GHC older than 7.4, text older than 1.1, and bytestring\n
  \ older than 0.10.4.0.  Supporting the older versions had become\n  increasingly
  difficult, to the point where it was no longer worth\n  it.\n\n0.7.0.0\n\n* The
  performance of encoding to and decoding of bytestrings have both\n  improved by
  up to 2x, while also using less memory.\n\n* New dependency: the scientific package
  lets us parse floating point\n  numbers more quickly and accurately.\n\n* eitherDecode,
  decodeStrictWith: fixed bugs.\n\n* Added FromJSON and ToJSON instances for Tree
  and Scientific.\n\n* Fixed the ToJSON instances for UTCTime and ZonedTime.\n\n0.6
  series\n\n* Much improved documentation.\n\n* Angle brackets are now escaped in
  JSON strings, to help avoid XSS\n  attacks.\n\n* Fixed up handling of nullary constructors
  when using generic\n  encoding.\n\n* Added ToJSON/FromJSON instances for:\n\n  *
  The Fixed class\n  * ISO-8601 dates: UTCTime, ZonedTime, and TimeZone\n\n* Added
  accessor functions for inspecting Values.\n\n* Added eitherDecode function that
  returns an error message if\n  decoding fails.\n\n0.5 to 0.6\n\n* This release introduces
  a slightly obscure, but\n  backwards-incompatible, change.\n\n  In the generic APIs
  of versions 0.4 and 0.5, fields whose names\n  began with a \"_\" character would
  have this character removed.  This\n  no longer occurs, as it was both buggy and
  surprising\n  (https://github.com/bos/aeson/issues/53).\n\n* Fixed a bug in generic
  decoding of nullary constructors\n  (https://github.com/bos/aeson/issues/62).\n\n0.4
  to 0.5\n\n* When used with the UTF-8 encoding performance improvements\n  introduced
  in version 0.11.1.12 of the text package, this release\n  improves aeson's JSON
  encoding performance by 33% relative to aeson\n  0.4.\n\n  As part of achieving
  this improvement, an API change was necessary.\n  The fromValue function in the
  Data.Aeson.Encode module now uses the\n  text package's Builder type instead of
  the blaze-builder package's\n  Builder type.\n\n0.3 to 0.4\n\n* The new decode function
  complements the longstanding encode\n  function, and makes the API simpler.\n\n*
  New examples make it easier to learn to use the package\n  (https://github.com/bos/aeson/tree/master/examples).\n\n*
  Generics support\n\n  aeson's support for data-type generic programming makes it
  possible\n  to use JSON encodings of most data types without writing any\n  boilerplate
  instances.\n\n  Thanks to Bas Van Dijk, aeson now supports the two major schemes
  for\n  doing datatype-generic programming:\n\n  * the modern mechanism, built into
  GHC itself\n\t(http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-programming.html)\n\n
  \ * the older mechanism, based on SYB (aka \"scrap your\n\tboilerplate\")\n\n  The
  modern GHC-based generic mechanism is fast and terse: in fact,\n  its performance
  is generally comparable in performance to\n  hand-written and TH-derived ToJSON
  and FromJSON instances.  To see\n  how to use GHC generics, refer to examples/Generic.hs.\n\n
  \ The SYB-based generics support lives in Data.Aeson.Generic and is\n  provided
  mainly for users of GHC older than 7.2.  SYB is far slower\n  (by about 10x) than
  the more modern generic mechanism.  To see how\n  to use SYB generics, refer to
  examples/GenericSYB.hs.\n\n* We switched the intermediate representation of JSON
  objects from\n  Data.Map to Data.HashMap which has improved type conversion\n  performance.\n\n*
  Instances of ToJSON and FromJSON for tuples are between 45% and 70%\n  faster than
  in 0.3.\n\n* Evaluation control\n\n  This version of aeson makes explicit the decoupling
  between\n  *identifying* an element of a JSON document and *converting* it to\n
  \ Haskell.  See the Data.Aeson.Parser documentation for details.\n\n  The normal
  aeson decode function performs identification strictly,\n  but defers conversion
  until needed.  This can result in improved\n  performance (e.g. if the results of
  some conversions are never\n  needed), but at a cost in increased memory consumption.\n\n
  \ The new decode' function performs identification and conversion\n  immediately.
  \ This incurs an up-front cost in CPU cycles, but\n  reduces reduce memory consumption.\n"
basic-deps:
  bytestring: ! '>=0.10.4.0'
  base: ==4.*
  time: <1.5
  unordered-containers: ! '>=0.2.3.0'
  text: ! '>=1.1.1.0'
  syb: -any
  dlist: ! '>=0.2'
  containers: -any
  ghc-prim: ! '>=0.2'
  old-locale: -any
  mtl: -any
  hashable: ! '>=1.1.2.0'
  attoparsec: ! '>=0.13.0.0'
  transformers: -any
  deepseq: -any
  scientific: ! '>=0.3.1 && <0.4'
  template-haskell: ! '>=2.4'
  vector: ! '>=0.7.1'
all-versions:
- '0.1.0.0'
- '0.2.0.0'
- '0.3.0.0'
- '0.3.1.0'
- '0.3.1.1'
- '0.3.2.0'
- '0.3.2.1'
- '0.3.2.2'
- '0.3.2.3'
- '0.3.2.4'
- '0.3.2.5'
- '0.3.2.6'
- '0.3.2.7'
- '0.3.2.8'
- '0.3.2.9'
- '0.3.2.10'
- '0.3.2.11'
- '0.3.2.12'
- '0.3.2.13'
- '0.3.2.14'
- '0.4.0.0'
- '0.4.0.1'
- '0.5.0.0'
- '0.6.0.0'
- '0.6.0.1'
- '0.6.0.2'
- '0.6.1.0'
- '0.6.2.0'
- '0.6.2.1'
- '0.7.0.0'
- '0.7.0.1'
- '0.7.0.2'
- '0.7.0.3'
- '0.7.0.4'
- '0.7.0.5'
- '0.7.0.6'
- '0.8.0.0'
- '0.8.0.1'
- '0.8.0.2'
- '0.8.1.0'
latest: '0.8.1.0'
description-type: markdown
description: ! '# Welcome to aeson


  aeson is a fast Haskell library for working with JSON data.



  # Join in!


  We are happy to receive bug reports, fixes, documentation enhancements,

  and other improvements.


  Please report bugs via the

  [github issue tracker](http://github.com/bos/aeson/issues).


  Master [git repository](http://github.com/bos/aeson):


  * `git clone git://github.com/bos/aeson.git`


  There''s also a [Mercurial mirror](http://bitbucket.org/bos/aeson):


  * `hg clone http://bitbucket.org/bos/aeson`


  (You can create and contribute changes using either git or Mercurial.)



  # Authors


  This library is written and maintained by Bryan O''Sullivan,

  <bos@serpentine.com>.

'
