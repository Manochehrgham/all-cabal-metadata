homepage: https://github.com/rudymatela/leancheck#readme
changelog-type: ''
hash: cac711f6090e989d1a1f8ca2f56d4094b5f61785ed417da0785c7b4f1b81523b
test-bench-deps:
  base: ==4.*
  template-haskell: -any
maintainer: Rudy Matela <rudy@matela.com.br>
synopsis: Cholesterol-free property-based testing
changelog: ''
basic-deps:
  base: ! '>=4 && <5'
  template-haskell: -any
all-versions:
- '0.3.0'
author: Rudy Matela <rudy@matela.com.br>
latest: '0.3.0'
description-type: markdown
description: ! "LeanCheck\n=========\n\n**The API is likely to change in the near
  future**\n\nLeanCheck is a simple enumerative property-based testing library.  It
  works by\nproducing *tiers* of test values, which are essentially (possibly infinite)\nlists
  of finite lists of same-and-increasingly-sized values.  It is similar to\n[Feat]
  in that regard.\n\nIn this README, lines ending with `-- >` indicate expected return
  values.\n\n\nChecking if properties are True\n-------------------------------\n\nTo
  check if properties are True,\njust use the function `holds :: Testable a => Int
  -> a -> Bool`.\nIt takes _two arguments_:\nthe _number of values_ to test\nand a
  _property_ (function returning Bool),\nthen, it returns a boolean indicating whether
  the property holds.\nSee (ghci):\n\n\timport Test.Check\n\timport Data.List\n\tholds
  100 $ \\xs -> sort (sort xs) == sort (xs::[Int])  -- > True\n\tholds 100 $ \\xs
  -> [] `union` xs == (xs::[Int])        -- > False\n\n\nFinding counter examples\n------------------------\n\nTo
  find counter examples to properties,\nyou can use the function `counterExample ::
  Testable a => Int -> a -> Maybe [String]`.\nIt takes _two arguments_:\nthe _number
  of values_ to test\nand a _property_ (function returning Bool).\nThen, it returns
  Nothing if no results are found or Just a list of Strings\nrepresenting the offending
  arguments to the property.\nSee (ghci):\n\n\timport Test.Check\n\timport Data.List\n\n\tcounterExample
  100 $ \\xs -> sort (sort xs) == sort (xs::[Int])\n\t-- > Nothing\n\n\tcounterExample
  100 $ \\xs -> [] `union` xs == (xs::[Int])\n\t-- > Just [\"[0,0]\"]\n\n\tcounterExample
  100 $ \\xs ys -> xs `union` ys == ys `union` (xs::[Int])\n\t-- > Just [\"[]\",\"[0,0]\"]\n\n\nChecking
  properties like in SmallCheck/QuickCheck\n-------------------------------------------------\n\nTo
  \"check\" properties like in [SmallCheck] and [QuickCheck]\nautomatically printing
  results on standard output,\nyou can use the function `check :: Testable a => a
  -> IO ()`.\n\n\timport Test.Check\n\timport Data.List\n\n\tcheck $ \\xs -> sort
  (sort xs) == sort (xs::[Int])\n\t-- > OK, passed 200 tests.\n\n\tcheck $ \\xs ys
  -> xs `union` ys == ys `union` (xs::[Int])\n\t-- > Failed! Falsifiable (after 4
  tests):\n\t-- > [] [0,0]\n\nThe function `check` tests for a maximum of 200 tests.\nTo
  check for a maximum of `n` tests, use `checkFor n`.\nTo get a boolean result wrapped
  in `IO`, use `checkResult` or `checkResultFor`.\nThere is no \"quiet\" option, just
  use `holds` or `counterExample` in that case.\n\n\nTesting for custom types\n------------------------\n\nLeanCheck
  works on properties with `Listable` argument types.\nCustom `Listable` instances
  are created similarly to SmallCheck:\n\n\tdata MyType = MyConsA\n\t            |
  MyConsB Int\n\t            | MyConsC Int Char\n\t            | MyConsD String\n\n\tinstance
  Listable MyType where\n\t  tiers = cons0 MyConsA\n\t       \\/ cons1 MyConsB\n\t
  \      \\/ cons2 MyConsC\n\t       \\/ cons1 MyConsD\n\nThe tiers function return
  a potentially infinite list of finite sub-lists (tiers).\nEach tier has values of
  increasing size.\n\n\ttiers :: Listable a => [[a]]\n\nFor convenience, there is
  also the function `list`,\nwhich returns an infinite list of values of the bound
  type:\n\n\tlist :: Listable a => [a]\n\nSo, for example:\n\n\ttake 5 (list :: [(Int,Int)])
  -- > [(0,0),(0,1),(1,0),(0,-1),(1,1)]\n\nThe `list` function can be used to debug
  your custom instances.\n\n\nMore information / extra functions\n----------------------------------\n\n`Listable`
  class instances are more customizable than what is described here:\ncheck source
  comments or haddock documentation for details.\n\n\nBuilding / Installing\n---------------------\n\nTo
  build:\n\n\t$ cabal build\n\nTo install:\n\n\t$ cabal install\n\nTo reference in
  a cabal sandbox:\n\n\t$ cabal sandbox add-source ../path/to/leancheck\n\nTo use
  the files directly in your project:\n\n\t$ cp -r Test ../path/to/your-project\n\n\nLeanCheck
  was tested on GHC 7.10, GHC 7.8, GHC 7.6 and GHC 7.4.\nThis library does not use
  any fancy extensions:\nif it does not work on previous GHC versions,\nprobably only
  *minor* changes are needed.\nIt optionally depends on Template Haskell\n(for automatic
  derivation of Listable instances).\n\n\n[Feat]: https://hackage.haskell.org/package/testing-feat\n[SmallCheck]:
  https://hackage.haskell.org/package/smallcheck\n[QuickCheck]: https://hackage.haskell.org/package/QuickCheck\n"
license-name: BSD3
