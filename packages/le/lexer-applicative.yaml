homepage: https://github.com/feuerbach/lexer-applicative
changelog-type: markdown
hash: 2ad68240f449e891edf92df33b7a7ebc7c54a8e4a96bb4d25fdeaded4090cd5f
test-bench-deps:
  srcloc: -any
  base: ! '>=4 && <5'
  tasty-hunit: ! '>=0.9'
  regex-applicative: -any
  tasty: ! '>=0.10'
  deepseq: -any
  lexer-applicative: -any
maintainer: Roman Cheplyaka <roma@ro-che.info>
synopsis: Simple lexer based on applicative regular expressions
changelog: ! "Changelog\n=========\n\n2.1\n---\n\n* Restore compatibility with older
  GHCs\n* Change the type of `longestShortest`\n\n2.0\n---\n\nThis is a major redesign
  of the API. Notable changes:\n\n- The lexer now supports parsing the longest prefix/shortest
  suffix\n  (see `longestShortest`)\n- Instead of throwing an exception, we return
  a stream. The stream can be\n  consumed directly, converted to a list or either-error-list
  of tokens.\n\n1.1.1\n-----\n\nAdd `tokensEither`\n\n1.1\n---\n\nUpgrade to srcloc
  0.5\n\n1.0.0.1\n-------\n\nSignal a lexical error (instead of looping) when a regex
  does not consume any\ncharacters\n"
basic-deps:
  srcloc: ! '>=0.5'
  base: ! '>=4.5 && <5'
  regex-applicative: ! '>=0.3.1'
all-versions:
- '1.0'
- '1.0.0.1'
- '1.1'
- '1.1.1'
- '2.0'
- '2.1'
author: Roman Cheplyaka <roma@ro-che.info>
latest: '2.1'
description-type: markdown
description: ! 'Simple applicative lexer based on the article

  [Lexical analysis with parser combinators][1]

  and the [regex-applicative][2] library.


  [1]: https://ro-che.info/articles/2015-01-02-lexical-analysis>

  [2]: http://hackage.haskell.org/package/regex-applicative-0.3.1/docs/Text-Regex-Applicative.html

'
license-name: MIT
