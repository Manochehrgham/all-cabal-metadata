homepage: https://github.com/jfischoff/postgresql-queue#readme
changelog-type: ''
hash: 4315dc879c12ffd3565f77ecfe55b78fb1c3a48552fc729cffcb4acdf56910e2
test-bench-deps:
  bytestring: -any
  base: -any
  hspec: -any
  async: -any
  hspec-pg-transact: -any
  postgresql-simple-queue: -any
  hspec-expectations-lifted: -any
  postgresql-simple: -any
  hspec-discover: -any
  pg-transact: -any
  aeson: -any
maintainer: jonathangfischoff@gmail.com
synopsis: A PostgreSQL backed queue
changelog: ''
basic-deps:
  amazonka: -any
  exceptions: -any
  bytestring: -any
  optparse-generic: -any
  base: ! '>=4.7 && <5'
  time: -any
  text: -any
  uuid: -any
  postgresql-simple-opts: -any
  monad-control: -any
  resource-pool: -any
  lifted-base: -any
  data-default: -any
  postgresql-simple-queue: -any
  amazonka-ses: -any
  lens: -any
  postgresql-simple: -any
  lifted-async: -any
  transformers: -any
  random: -any
  pg-transact: -any
  aeson: -any
all-versions:
- '0.1.0.0'
author: Jonathan Fischoff
latest: '0.1.0.0'
description-type: markdown
description: ! "# postgresql-simple-queue\n\nThis module utilize PostgreSQL to implement
  a durable queue for efficently processing arbitrary payloads which can be represented
  as JSON.\n\nTypically a producer would enqueue a new payload as part of larger database
  transaction\n\n```haskell\ncreateAccount userRecord = do\n  runDBTSerializable $
  do\n    createUserDB userRecord\n    enqueueDB $ makeVerificationEmail userRecord\n```\n\nIn
  another thread or process, the consumer would drain the queue.\n\n```haskell\n  forever
  $ do\n    -- Attempt get a payload or block until one is available\n    payload
  <- lock conn\n\n    -- Perform application specifc parsing of the payload value\n
  \   case fromJSON $ pValue payload of\n      Success x -> sendEmail x -- Perform
  application specific processing\n      Error err -> logErr err\n\n    -- Remove
  the payload from future processing\n    dequeue conn $ pId payload\n```\n"
license-name: BSD3
