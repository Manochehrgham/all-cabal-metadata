changelog-type: markdown
hash: 58c505ef033a883c34a99e9827da43ed1c208bd3ced2a6fe63c8a0ee26b48f09
test-bench-deps:
  postgresql-simple-migration: ! '>=0.1 && <0.2'
  bytestring: ! '>=0.10 && <0.11'
  base: ! '>=4.6 && <5.0'
  hspec: ! '>=1.10 && <1.11'
  postgresql-simple: ! '>=0.4 && <0.5'
synopsis: PostgreSQL Schema Migrations
changelog: ! '# Changelog


  ## 0.1.2.0

  * Moved Util module

  * Improved documentation


  ## 0.1.1.0

  * Support for schema validations.

  * Improved Haskell API


  ## 0.1.0.0

  * Support for file-based and Haskell migrations.

'
basic-deps:
  bytestring: ==0.10.*
  base: ! '>=4.6 && <5.0'
  time: ==1.4.*
  base64-bytestring: ==1.0.*
  postgresql-simple: ==0.4.*
  directory: ==1.2.*
  cryptohash: ==0.11.*
all-versions:
- '0.1.0.0'
- '0.1.1.0'
- '0.1.2.0'
- '0.1.3.0'
latest: '0.1.3.0'
description-type: markdown
description: ! "# PostgreSQL Migrations for Haskell\n\n[![Build Status](https://api.travis-ci.org/ameingast/postgresql-simple-migration.png)](https://travis-ci.org/ameingast/postgresql-simple-migration)\n\nWelcome
  to postgresql-simple-migrations, a tool for helping you with\nPostgreSQL schema
  migrations.\n\nThis project is an open-source database migration tool. It favors
  simplicity\nover configuration.\n\nIt is implemented in Haskell and uses the (excellent)
  postgresql-simple\nlibrary to communicate with PostgreSQL.\n\nIt comes in two flavors:
  a library that features an easy to use Haskell\nAPI and as a standalone application.\n\nDatabase
  migrations can be written in SQL (in this case PostgreSQL-sql)\nor in Haskell.\n\n##
  Why?\nDatabase migrations should not be hard. They should be under version control\nand
  documented in both your production systems and in your project files.\n\n## What?\nThis
  library executes SQL/Haskell migration scripts and keeps track of their\nmeta information.\n\nScripts
  are be executed exactly once and any changes to scripts will cause\na run-time error
  notifying you of a corrupted database.\n\nThe meta information consists of:\n* an
  MD5 checksum of the executed script to make sure already existing\n  scripts cannot
  be modified in your production system.\n* a time-stamp of the date of execution
  so you can easily track when a change\n  happened.\n\nThis library also supports
  migration validation so you can ensure (some)\ncorrectness before your application
  logic kicks in.\n\n## How?\nThis utility can be used in two ways: embedded in your
  Haskell program or as\na standalone binary.\n\n### Standalone\nThe standalone program
  supports file-based migrations. To execute all SQL-files\nin a directory $BASE\\_DIR,
  execute the following command to initialize the database\nin a first step.\n\n```bash\nCON=\"host=$host
  dbname=$db user=$user password=$pw\"\n./dist/build/migrate/migrate init $CON\n./dist/build/migrate/migrate
  migrate $CON $BASE_DIR\n```\n\nTo validate already executed scripts, execute the
  following:\n```bash\nCON=\"host=$host dbname=$db user=$user password=$pw\"\n./dist/build/migrate/migrate
  init $CON\n./dist/build/migrate/migrate validate $CON $BASE_DIR\n```\n\nFor more
  information about the PostgreSQL connection string, see:\n[libpq-connect](http://www.postgresql.org/docs/9.3/static/libpq-connect.html).\n\n###
  Library\nThe library supports more actions than the standalone program.\n\nInitializing
  the database:\n\n```haskell\nmain :: IO ()\nmain = do\n    let url = \"host=$host
  dbname=$db user=$user password=$pw\"\n    con <- connectPostgreSQL (BS8.pack url)\n
  \   withTransaction con $ runMigration $ \n        MigrationContext MigrationInitialization
  True con\n```\n\nFor file-based migrations, the following snippet can be used:\n\n```haskell\nmain
  :: IO ()\nmain = do\n    let url = \"host=$host dbname=$db user=$user password=$pw\"\n
  \   let dir = \".\"\n    con <- connectPostgreSQL (BS8.pack url)\n    withTransaction
  con $ runMigration $ \n        MigrationContext (MigrationDirectory dir) True con\n```\n\nTo
  run Haskell-based migrations, use this:\n\n```haskell\nmain :: IO ()\nmain = do\n
  \   let url = \"host=$host dbname=$db user=$user password=$pw\"\n    let name =
  \"my script\"\n    let script = \"create table users (email varchar not null)\";\n
  \   con <- connectPostgreSQL (BS8.pack url)\n    withTransaction con $ runMigration
  $ \n        MigrationContext (MigrationScript name script) True con\n```\n\nValidations
  wrap _MigrationCommands_. This means that you can re-use all\nMigrationCommands
  to perform a read-only validation of your migrations.\n\nTo perform a validation
  on a directory-based migration, you can use the\nfollowing code:\n\n```haskell\nmain
  :: IO ()\nmain = do\n    let url = \"host=$host dbname=$db user=$user password=$pw\"\n
  \   con <- connectPostgreSQL (BS8.pack url)\n    withTransaction con $ runMigration
  $ MigrationContext \n        (MigrationValidation (MigrationDirectory dir)) True
  con\n```\n\nDatabase migrations should always be performed in a transactional context.
  \n\nThe standalone binary takes care of proper transaction handling automatically.\n\nThe
  library does not make any assumptions about the current transactional state\nof
  the system. This way you can execute multiple migration-commands or\nvalidations
  in sequence while still staying in the same transaction.\n\nThe tests work in a
  similar way. After executing all migration-tests, the \ntransaction is rolled back.\n\n##
  Compilation and Tests\nThe program is built with the _cabal_ build system. The following
  command\nbuilds the library, the standalone binary and the test package.\n\n```bash\ncabal
  configure --enable-tests && cabal build -j\n```\n\nTo execute the tests, you need
  a running PostgreSQL server with an empty\ndatabase called _test_. Tests are executed
  through cabal as follows:\n\n```bash\ncabal configure --enable-tests && cabal test\n```\n\n##
  To Do\n* Collect executed scripts and check if already executed scripts have been\n
  \ deleted.\n"
