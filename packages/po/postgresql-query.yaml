homepage: https://bitbucket.org/s9gf4ult/postgresql-query
changelog-type: markdown
hash: 38cc6dced4bbfb5d9306ccf754e898d8053e102c3327d83e4d16c90953f9b39a
test-bench-deps:
  quickcheck-assertions: -any
  tasty-th: -any
  base: ! '>=4.6 && <5'
  text: -any
  postgresql-query: -any
  quickcheck-instances: -any
  tasty-quickcheck: -any
  tasty-hunit: -any
  attoparsec: -any
  tasty: -any
  QuickCheck: -any
maintainer: s9gf4ult@gmail.com
synopsis: ! 'Sql interpolating quasiquote plus some kind of primitive ORM

  using it'
changelog: ! "# CHANGELOG\n\n## 1.2.0\n\n### Added\n* `pgWithTransactionMode` and
  its friends, like\n  `pgWithTransactionSerializable` added.\n\n## 1.1.1\n\n### Changed\n*
  `pgInsertManyEntities` returns count of inserted entities\n* `pgDeleteEntity` returns
  True if entity was actually deleted\n* `pgUpdateEntity` returns True if entity was
  actually updated\n\n## 1.1.0\n\n### Added\n* `deriveEntity` - TH derivation `Entity`
  instances for you types\n* `deriveEverything` - TH derivation of `Entity`, `ToRow`
  and `FromRow` in one shot\n\n### Changed\n* Docs improoved\n\n## 1.0.1\nThe first
  usable version\n"
basic-deps:
  exceptions: -any
  either: -any
  bytestring: -any
  base: ! '>=4.6 && <5'
  time: -any
  text: -any
  monad-control: ==0.3.3.1 || >1.0.0.3
  resource-pool: -any
  data-default: -any
  semigroups: -any
  containers: -any
  blaze-builder: -any
  postgresql-simple: ! '>=0.4.10.0'
  mtl: -any
  transformers-base: -any
  monad-logger: -any
  file-embed: -any
  attoparsec: -any
  transformers: <0.4
  haskell-src-meta: -any
  aeson: -any
  template-haskell: -any
  transformers-compat: ! '>=0.3'
all-versions:
- '1.0.0'
- '1.0.1'
- '1.1.0'
- '1.1.1'
- '1.2.0'
author: Aleksey Uimanov
latest: '1.2.0'
description-type: markdown
description: ! "# What ?\n\n`postgresql-query` is a library for more simple query
  generation for\nPostgreSQL database. It is not an ORM (but contains some part of).
  It\ncontains interpolating quasiquote for simple query generation.\n\n# Motivation\n\nWhen
  you want to perform some complex SQL query using\n`postgresql-simple` you writing
  this query by hands like that:\n\n```haskell\nlet q = mconcat\n        [ \"SELECT
  u.id, u.name, count(p.id) \"\n        , \"FROM users as u INNER JOIN posts as p
  \"\n        , \"ON u.id = p.user_id \"\n        , \"WHERE u.name like ? AND u.created
  BETWEEN ? AND ? \"\n        , \"GROUP BY u.id ORDER BY ? \" ]\n```\n\nWell, this
  is not realy complex. Now what you need to perform the\nquery is to paste parameters
  instead of this `?` signs:\n\n```haskell\nquery con q (\"%Peyton%\", now, yesterday)\n```\n\nDid
  you see the mistake? We forgot about ordering field. To perform this query we must\n\n```haskell\nquery
  con q (\"%Peyton%\", now, yesterday, Identifier \"...\n```\n\nOups!. If we use `Identifier
  \"u.name\"` we will get `\"u.name\"` in our\nquery which is just not right. Sql
  syntax assumes `\"u\".\"name\"` for\nthis query. We can not use query parameter
  to paste optional field\nhere.\n\n\nNext example is more complex:\n\n```haskell\nlet
  name = Just \"%Peyton%\" -- assume we getting parameters from query\n    minage
  = Just 10\n    maxage = Just 50\n    condlist = catMaybes\n               [ const
  \" u.name like ? \" <$> name\n               , const \" u.age > ? \" <$> minage\n
  \              , const \" u.age < ? \" <$> maxage ]\n    paramlist = catMaybes\n
  \               [ toField <$> name\n                , toField <$> minage\n                ,
  toField <$> maxage ]\n    cond = if L.null condlist\n           then mempty\n           else
  \"WHERE \" <> (mconcat $ L.intersperse \" AND \" condlist)\n    q = \"SELECT u.id,
  u.name, u.age FROM users AS u \" <> cond\nquery con q paramlist\n```\n\nSo much
  to write and so many chances to make a mistake. What if we\ncould write this like:\n\n```haskell\nlet
  name = Just \"%Peyton%\" -- assume we getting parameters from query\n    minage
  = Just 10\n    maxage = Just 50\n    ord = \"u.name\" :: FN -- <- special type for
  field names!\n    condlist = catMaybes\n               [ (\\a -> [sqlExp|u.name
  like #{a}|]) <$> name\n               , (\\a -> [sqlExp|u.age > #{a}|])     <$>
  minage\n               , (\\a -> [sqlExp|u.age < #{a}|])     <$> maxage ]\n    cond
  = if L.null condlist\n           then mempty\n           else [sqlExp|WHERE ^{mconcat
  $ L.intersperse \" AND \" condlist}|]\npqQuery [sqlExp|SELECT u.id, u.name, u.age\n
  \               FROM users AS u ^{cond}\n                ORDER BY ^{ord}|]\n```\n\nMuch
  better!\n\n# sqlExp\n\nQuasiquote `sqlExp` has two way of interpolation:\n\n* `#{exp}`
  - pastes inside query arbitrary value which type is\n  instance of `ToField` typeclass.
  It performs correct strings\n  escaping so it is not the same as stupid string interpolation.
  Dont\n  worry about sql-injections when using it.\n\n* `^{exp}` - pastes inside
  query arbitrary value which type has\n  instance of `ToSqlBuilder` typeclass.\n\n`sqlExp`
  returns `SqlBuilder` which has a `Monoid` instance\nand made for effective concatination
  (bytestring builder works\ninside).\n\nThis quasiquote correctly handles string
  literals and quoted\nidentifiers. It also removes line and block (even nested) sql
  comments\nfrom resulting query as well as sequences of space characters. You are\nfree
  to write queries like\n\n```sql\nWHERE name SIMILAR TO '\\^{2,3}' -- line comment
  #{ololo}\n```\n\nor even\n\n```sql\nWHERE \"#{strange}identifier\" SIMILAR TO '#{1,10}'
  /*nested/*^{block}*/comment*/\n```\n\n`sqlExp` will remove all comments and will
  not interpolate inside\nstring literals or quoted identifiers at all.\n\n## sqlExpEmbed
  and sqlExpFile\n\nIf you have realy huge hardcore sql template you can\n\n```haskell\npgQuery
  $(sqlExpEmbed \"sql/foo/bar.sql\")\n```\n\nIt works just like Yesod's templates.
  You can use interpolation inside\ntemplates like inside `sqlExp`.\n\n```haskell\npgQuery
  $(sqlExpFile \"foo/bar\")\n```\n\nIs absolutely the same as above. It just prepends
  `sql/` and\nappends `.sql` to your string. If you agree to follow naming\nconventions
  you are welcome to use `sqlExpFile`."
license-name: BSD3
