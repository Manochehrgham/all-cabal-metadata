changelog-type: ''
hash: 09265e1807974f4946007f165a7af4ff621cdc010f9c2a98114e943854015b01
test-bench-deps: {}
synopsis: Run jobs on a limited number of threads and support data dependencies
changelog: ''
basic-deps:
  unsafe: ! '>=0.0 && <0.1'
  base: ! '>=4 && <5'
  utility-ht: ! '>=0.0.9 && <0.1'
  containers: ! '>=0.4 && <0.6'
  concurrent-split: ! '>=0.0 && <0.1'
  transformers: ! '>=0.2.2 && <0.5'
  deepseq: ! '>=1.3 && <1.5'
all-versions:
- '0.0'
- '0.0.0.1'
- '0.0.1'
- '0.0.1.1'
- '0.0.1.2'
- '0.0.2'
latest: '0.0.2'
description-type: haddock
description: ! 'The motivation for this package was to run computations on multiple
  cores

  that need to write intermediate results to disk.

  The functions restrict the number of simultaneously running jobs

  to a user given number or to the number of capabilities

  the Haskell program was started with,

  i.e. the number after the RTS option @-N@.


  There are some flavors of this functionality:


  * "Control.Concurrent.PooledIO.Independent":

  run independent actions without results in parallel


  * "Control.Concurrent.PooledIO.Final":

  run independent actions with a final result in parallel


  * "Control.Concurrent.PooledIO.InOrder":

  run jobs in parallel with data dependencies like @make -j n@


  Additionally there is the module

  "Control.Concurrent.PooledIO.Sequence"

  that helps to serialize I/O actions from multiple threads.

  It is certainly most useful in connection with

  "Control.Concurrent.PooledIO.Independent".


  Related packages:


  * @lazyio@: interleave IO actions in a single thread


  * @async@: start threads and wait for their results, forward exceptions,

  but do not throttle concurrency with respect to number of available cores


  * @parallel-tasks@:'
