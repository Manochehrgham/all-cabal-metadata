homepage: ''
changelog-type: ''
hash: 7f3d7f3a8c8aedb78145f4d8a992815cdb644d839a5431b23e5fad0a62d7dd5c
test-bench-deps: {}
maintainer: Paweł Nowak <pawel834@gmail.com>
synopsis: Reversible parsing and pretty-printing.
changelog: ''
basic-deps:
  semi-iso: ! '>=1'
  base: ! '>=4 && <5'
  text: -any
  lens: ! '>=4'
  scientific: ! '>=0.3'
  mono-traversable: -any
  vector: -any
all-versions:
- '0.1.0.0'
- '0.1.1.0'
- '0.2.0.0'
- '0.2.1.0'
- '0.3.0.0'
- '1.0.0.0'
author: Paweł Nowak
latest: '1.0.0.0'
description-type: haddock
description: ! 'UPDATE: I have a lot of work now and so I haven''t updated the library
  in a while. However once I get some free time I will probably rewrite it with a
  new, cleaner design (focused more on adjoints then isomorphisms). Consider this
  package very experimental :)


  "syntax" allows you to write a single syntax description and instantiate is both
  as a parser and a pretty printer.


  Syntax descriptions are written in applicative or arrow style. The library uses
  a custom typeclass hierarchy, provided

  by the "semi-iso" package. Most of the time you will be using operators like ''/$/'',
  ''/*/'' and ''/+/'' (= ''<|>''), just

  like parser combinators. When more power is needed - e.g. when the syntax depends
  on the parsed or printed value -

  you turn to arrows.


  Semi-isomorphisms from "semi-iso" are the basic building block of syntax descriptions.
  I recommend reading

  the hackage page of "semi-iso" first, as it contains much more information.


  Once you write a syntax description (polymorphic in the syntax category) you can
  instantiate it both as a parser or as

  a pretty-printer. The library "syntax-attoparsec" gives you the ability to extract
  an Attoparsec parser. Pretty-printing

  is implemented by the "syntax-printer" library, which uses Text and ByteString builders.
  (Note that formatting is handled

  by "syntax" itself, not by the printer library)


  Advanced formatting and parsing (for example indentation, haskell layout rule) is
  implemented as category transformers

  (similar to monad transformers). Currently only simple indentation is implemented
  (in "Data.Syntax.Indent") - basically

  a reader category transformer that tracks current indentation level. I plan on implementing
  Haskell layout rule in the

  future.


  The library can work with both text and binary data. Alas, there are no binary combinators
  implemented yet.


  EXAMPLES! See @syntax-example@ and @syntax-example-json@ for examples.


  * "syntax-example" implements a simple lambda calculus.


  * "syntax-example-json" implements a json parser and pretty printer.'
license-name: MIT
