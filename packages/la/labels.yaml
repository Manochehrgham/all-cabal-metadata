homepage: https://github.com/chrisdone/labels#readme
changelog-type: text
hash: 9014f4804a3b064e3c8af20cd31bf15785b7300bf2026769bb189841c0f7472e
test-bench-deps: {}
maintainer: chrisdone@gmail.com
synopsis: Declare and access tuple fields with labels
changelog: ! "0.1.0:\n\t* Drop the convenience accessor #foo. Must use get #foo\n\n0.0.0:\n\t*
  First version\n"
basic-deps:
  bytestring: -any
  base: ! '>=4.7 && <5'
  unordered-containers: -any
  cassava: -any
  template-haskell: -any
all-versions:
- '0.0.0'
- '0.1.0'
author: Chris Done
latest: '0.1.0'
description-type: markdown
description: ! "# labels\n\nDeclare and access tuple fields with labels\n\nThis package
  is experimental, exploring the design space opened up by\nthe implemented and to-be-implemented
  work on extensible records in GHC.\n\n*Note: You need GHC 8.0.1 for the `#foo` syntax,
  otherwise you have to\n use `$(\"foo\")` which works on GHC 7.10.*\n\n## Basic examples\n\nThe
  [haddock docs are here.](https://chrisdone.github.io/labels/)\n\nEnable these extensions:\n\n*
  In GHCi: `:set -XOverloadedLabels -XTypeOperators -XDataKinds -XFlexibleContexts`\n\n*
  In a module: `{-# LANGUAGE OverloadedLabels, TypeOperators, DataKinds, FlexibleContexts
  #-}`\n\nLet's use GHCi:\n\n``` haskell\n> import Labels\n> :set -XOverloadedLabels
  -XTypeOperators -XDataKinds -XFlexibleContexts\n```\n\n<table>\n<tr><td>Construct
  a record</td><td><pre lang=\"haskell\">\n> (#foo := \"hi\", #bar := 123)\n(#foo
  := \"hi\",#bar := 123)\n</pre></td></tr>\n<tr><td>Get fields of a record</td><td><pre
  lang=\"haskell\">\n> get #bar (#foo := \"hi\", #bar := 123)\n123\n</pre></td></tr>\n<tr><td>Set
  fields of a record</td><td><pre lang=\"haskell\">\n> set #bar 66 (#foo := \"hi\",
  #bar := 123)\n(#foo := \"hi\",#bar := 66)\n</pre></td></tr>\n<tr><td>Modify fields
  of a record</td><td><pre lang=\"haskell\">\n> modify #mu (*0.1) (#bar := \"hi\",
  #mu := 123)\n(#bar := \"hi\",#mu := 12.3)\n</pre></td></tr>\n<tr><td>Add fields
  to a record</td><td><pre lang=\"haskell\">\n> cons (#mu := [1,2,3]) (#foo := \"hi\",
  #bar := 123)\n(#mu := [1,2,3],#foo := \"hi\",#bar := 123)\n</pre></td></tr>\n<tr><td>Abstraction</td><td><pre
  lang=\"haskell\">\n> let double field record = set field (get field record * 2)
  record\n> double #mu (#bar := \"hi\", #mu := 123)\n(#bar := \"hi\",#mu := 246)\n</pre></td></tr>\n</table>\n\n##
  Reading CSV files with Cassava\n\nImport the instances for `FromNamedRecord`:\n\n```
  haskell\nimport Labels.Cassava\n```\n\nThen just specify the type you want to load:\n\n```
  haskell\n> let Right (_,rows :: Vector (\"salary\" := Int, \"name\" := Text)) =
  decodeByName \"name,salary\\r\\nJohn,27\\r\\n\"\n> rows\n[(#salary := 27,#name :=
  \"John\")]\n```\n\nNon-existent fields or invalid types result in a parse error:\n\n```
  haskell\n> decodeByName \"name,salary\\r\\nJohn,27\\r\\n\" :: Either String (Header,
  Vector (\"name\" := Text, \"age\" := Int))\nLeft \"parse error (Failed reading:
  conversion error: Missing field age) at \\\"\\\\r\\\\n\\\"\"\n> decodeByName \"name,salary\\r\\nJohn,27\\r\\n\"
  :: Either String (Header, Vector (\"name\" := Text, \"salary\" := Char))\nLeft \"parse
  error (Failed reading: conversion error: expected Char, got \\\"27\\\") at \\\"\\\\r\\\\n\\\"\"\n```\n\nExample
  with Yahoo!'s market data for AAPL:\n\n``` haskell\n> Right (headers,rows :: Vector
  (\"date\" := String, \"high\" := Double, \"low\" := Double)) <- fmap decodeByName
  (LB.readFile \"AAPL.csv\")\n> headers\n[\"date\",\"open\",\"high\",\"low\",\"close\",\"volume\",\"adj
  close\"]\n```\n\nWe can print the rows as-is:\n\n``` haskell\n> mapM_ print (V.take
  2 rows)\n(#date := \"2016-08-10\",#high := 108.900002,#low := 107.760002)\n(#date
  := \"2016-08-09\",#high := 108.940002,#low := 108.010002)\n```\n\nAccessing fields
  is natural as anything:\n\n``` haskell\n> V.sum (V.map (get #low) rows)\n2331.789993\n```\n\nWe
  can just make up new fields on the fly:\n\n``` haskell\n> let diffed = V.map (\\row
  -> cons (#diff := (get #high row - get #low row)) row) rows\n> mapM_ print (V.take
  2 diffed)\n(#diff := 1.1400000000000006,#date := \"2016-08-10\",#high := 108.900002,#low
  := 107.760002)\n(#diff := 0.9300000000000068,#date := \"2016-08-09\",#high := 108.940002,#low
  := 108.010002)\n```\n\nSometimes a CSV file will have non-valid Haskell identifiers
  or\nspaces, e.g. `adj close` here:\n\n``` haskell\n> Right (headers,rows :: Vector
  (\"date\" := String, \"adj close\" := Double)) <- fmap decodeByName (LB.readFile
  \"AAPL.csv\")\n> mapM_ print (V.take 2 rows)\n(#date := \"2016-08-10\",#adj close
  := 108.0)\n(#date := \"2016-08-09\",#adj close := 108.809998)\n```\n\nJust use the
  `$(\"adj close\")` syntax:\n\n``` haskell\n> mapM_ print (V.take 2 (V.map (get $(\"adj
  close\")) rows))\n108.0\n108.809998\n```\n\nIt still checks the name and type:\n\n```
  haskell\n> mapM_ print (V.take 2 (V.map (get $(\"adj closer\")) rows))\n<interactive>:133:31:
  error:\n    • No instance for (Has\n                         \"adj closer\" a0 (\"date\"
  := String, \"adj close\" := Double))\n        arising from a use of ‘get’\n````\n"
license-name: BSD3
