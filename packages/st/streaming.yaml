homepage: https://github.com/michaelt/streaming
changelog-type: ''
hash: 8edb7c497dff745b8ec3741975023f0cca168224b3dac60d067ad79cf2e63080
test-bench-deps: {}
maintainer: what_is_it_to_do_anything@yahoo.com
synopsis: A free monad transformer optimized for streaming applications.
changelog: ''
basic-deps:
  base: ! '>=4.6 && <4.9'
  mtl: ! '>=2.1 && <2.3'
  mmorph: ! '>=1.0 && <1.2'
  transformers: ! '>=0.3 && <0.5'
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.1.0.3'
- '0.1.0.4'
- '0.1.0.5'
- '0.1.0.6'
- '0.1.0.7'
- '0.1.0.8'
- '0.1.0.9'
- '0.1.0.10'
- '0.1.0.11'
- '0.1.0.12'
author: michaelt
latest: '0.1.0.12'
description-type: haddock
description: ! '`Stream` can be used wherever `FreeT` is used. The compiler''s

  standard range of optimizations work better for operations

  written in terms of `Stream`. @FreeT f m r@ / @Stream f m r@

  is of course extremely general, and many functor-general combinators

  are exported by the general module @Streaming@.


  See the examples in @Streaming.Prelude@ for a sense of how

  simple the library is to use and think about.

  That module is focused on employment with such base functors

  (readings of the @f@ in @Stream f m r@) that express

  different forms of effectful sequences. Some of these appear

  elsewhere under titles like


  > pipes:      Producer a m r, Producer a m (Producer a m r), FreeT (Producer a m)
  m r

  > io-streams: InputStream a, Generator a r

  > conduit:    Source m a, ConduitM () o m r


  and the like. @Streaming.Prelude@ closely follows

  @Pipes.Prelude@, but cleverly /omits the pipes/.


  Interoperation with

  <http://hackage.haskell.org/package/pipes pipes>

  is accomplished with this isomorphism:


  > Pipes.unfoldr Streaming.next        :: Stream (Of a) m r   -> Producer a m r

  > Streaming.unfoldr Pipes.next        :: Producer a m r      -> Stream (Of a) m
  r


  Interoperation with

  <http://hackage.haskell.org/package/io-streams io-streams>

  is thus:


  > Streaming.reread IOStreams.read     :: InputStream a       -> Stream (Of a) IO
  ()

  > IOStreams.unfoldM Streaming.uncons  :: Stream (Of a) IO () -> IO (InputStream
  a)


  A simple exit to <http://hackage.haskell.org/package/conduit conduit> would be,
  e.g.:


  > Conduit.unfoldM Streaming.uncons    :: Stream (Of a) m ()  -> Source m a


  These conversions should never be more expensive than a single @>->@ or @=$=@.


  With a much more general level, we also of course have interopetion with

  <http://hackage.haskell.org/package/free free>:


  Free.iterTM  Stream.wrap              :: FreeT f m a -> Stream f m a

  Stream.iterTM Free.wrap               :: Stream f m a -> FreeT f m a


  See the companion package <https://hackage.haskell.org/package/streaming-bytestring
  streaming-bytestring>

  For some simple examples, see

  <https://gist.github.com/michaelt/6c6843e6dd8030e95d58 these replicas> of shell-like
  programs from

  the <http://hackage.haskell.org/package/io-streams-1.3.2.0/docs/System-IO-Streams-Tutorial.html
  io-streams tutorial>.'
license-name: BSD3
