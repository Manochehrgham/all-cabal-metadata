homepage: https://github.com/michaelt/streaming
changelog-type: ''
hash: e191e5a5d93a699ff96a8928e05e694000ee036b88e1023429f2483f6b50a7f7
test-bench-deps: {}
maintainer: what_is_it_to_do_anything@yahoo.com
synopsis: an elementary streaming prelude and a general monad transformer for streaming
  applications.
changelog: ''
basic-deps:
  bytestring: -any
  base: ! '>=4.6 && <5'
  time: -any
  mtl: ! '>=2.1 && <2.3'
  mmorph: ! '>=1.0 && <1.2'
  transformers: ! '>=0.4 && <0.5'
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.1.0.3'
- '0.1.0.4'
- '0.1.0.5'
- '0.1.0.6'
- '0.1.0.7'
- '0.1.0.8'
- '0.1.0.9'
- '0.1.0.10'
- '0.1.0.11'
- '0.1.0.12'
- '0.1.0.13'
- '0.1.0.14'
- '0.1.0.15'
- '0.1.0.16'
- '0.1.0.17'
- '0.1.0.18'
- '0.1.0.19'
- '0.1.0.20'
- '0.1.1.0'
- '0.1.1.1'
- '0.1.2.0'
author: michaelt
latest: '0.1.2.0'
description-type: markdown
description: ! "streaming\n=========\n\n\n\n`Stream` can be used wherever [FreeT](https://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Trans-Free.html)
  is used. The compiler's standard range of optimizations work better for operations
  written in terms of `Stream`. `FreeT f m r` and `Stream f m r` are of course extremely
  general, and many functor-general combinators are exported by the general module
  `Streaming`. \n\nBut the library is focused on uses of `Stream f m r` where `f`
  is itself in some sense \"streaming\". This means, very crudely, that it is possible
  to make strict left folds over it. Where `f` is complex, and has the form `t m`,
  these folds will have the form `t m r -> m (a, r)`, polymorphic in `r`. In particular,
  it will be possible, for example, to write the trivial left fold - a `drain` or
  `runEffects` function - `t m r -> m r` or `f r -> m r` - polymorphically. `Stream
  f m r` preserves this property. In particular, branching and failure are excluded;
  the latter is always handled in the monad `m`.  \n\nThe abstraction is inevitable,
  though there are many ways of writing it. Once one possesses it, though, one is
  already in possession of an elementary streaming library, since `Stream ((,)a) m
  r` or its equivalent is the type of a producer, generator or source. I try to argue
  for this more elaborately below, bringing it into connection with the standard streaming
  io libraries. \n\nThe freely generated stream on a streamable functor\n----------------------------------------------------\n\nAs
  soon as you consider the idea of an effectful stream of any kind whatsoever, for
  example, a stream of bytes from a handle, however constituted, you will inevitably
  be forced to contemplate the idea of a streaming *succession* of *just such streams*.
  \nThus, for example, however you imagine your bytes streaming from a handle, you
  will want to consider a *succession* of *such streams* divided on newlines. \n\nThis
  is closely related to the fact that, as soon as you contemplate a complex streaming
  phenomenon, you will want to consider a break in the stream, a function that divides
  the stream into parts according to some internal characteristic, and allows us to
  handle the parts separately, making it possible to do one thing with the first part
  and another with the second. Such a function will not have the form:\n\n    splitter
  :: S -> (S, S)\n\nlike the splitting operations we find with lists and the like,
  e.g. \n\n    splitAt 3 :: [a] -> ([a],[a])\n\nSince we can assume an underlying
  monad m, which may be implicit (in `io-streams`, for example, `IO` is implicit in
  the types of `InputStream` and `Generator`), we can write the candidate type thus:\n\n
  \   splitter :: S m -> (S m, S m)\n\nThese types use ordinary \"pure\" pairing,
  and cannot express the fundamental point that I cannot get to the 'second' stream
  without passing through the 'first'; the features of the 'second half' may depend
  causally on events in the first half. We do not repair this, but just make it worse,
  by complicating the type thus\n\n    splitter :: S m -> m (S m, S m)\n    \n\nsince
  the effects I must pass through to get to pair, and thus the second element, are
  precisely the effects putatively contained in the first element in the result type.
  My idea was to do \"one thing with the first half\" and \"another thing with the
  second half\"; in this type I somehow do the effects of the first half to get the
  pair, and still have the first half before me, coupled with the second half. If
  I am not proposing to repeat the action of the first part and I have not lost information,
  my type must secretly be something like \n\n    splitter :: S m -> m (S Identity,
  S m)\n    \nor\n\n    splitAccum :: S m -> m ([z], S m)\n    \nas we see, e.g. [here](http://hackage.haskell.org/package/list-t-0.4.5.1/docs/src/ListT.html#splitAt)
  or, more obscurely in functions like [these](http://hackage.haskell.org/package/conduit-combinators-1.0.3/docs/src/Data-Conduit-Combinators.html#splitOnUnboundedE).
  \ (I will return to this difficulty below.)\n\nThis point makes it inevitable that
  *a rational stream type will have a return value*. It will have the form \n\n    S
  r\n    \nor \n\n    S m r\n    \nand the dividing functions will have the form\n\n\n
  \   splitter :: S r -> S (S r)  \n\nor, where the underlying form of effect is explicit\n\n
  \   splitter :: S m r -> S m (S m r)\n    \nNow we can express what we meant by
  'doing one thing with the first half and another with the second', we were thinking
  of applying some sort of polymorphic folds, maybe with types like\n\n    folder
  :: S m x -> m (a, x)\n    \nthen we have\n\n    folder . splitter :: S m r -> m
  (a, S m r)\n    \nand can contemplate applying this or another folding operation
  to the 'second half', e.g.\n\n    liftM (fmap folder) . folder . splitter :: S m
  x -> m (a, m (a,x))\n    \nand can reshuffle to get a function `S m x -> m ((a,a),
  x)`. This function has the form of our original folder function, since it is polymorphic
  in `x`.  \n\nThat folds over streaming types should be polymorphic in their return
  type is written already into this simple material: we want to 'do one thing with
  the first half and something else - or the same thing - with the second half'. The
  thing we 'do with the first half' will have to be something we could do even if
  the second half doesn't exist, and it must preserve it if it does. In the simplest
  case, 'what we do with the first half' might be simply to throw it out, or drain
  it. \n\nNow, to return to the first point, suppose you have the idea the unfolding
  of some sort of stream from an individual Haskell value, a seed - a file name, as
  it might be. And suppose you *also* have some idea of a stream *of* individual Haskell
  values - maybe a stream of file names coming from something like `du`, subjected
  to some filter. Then you will also have the idea of a streaming *succession* of
  *such unfoldings* linked together end to end in accordance with the initial succession
  of seed values.\n\nCall the thoughts above the ABCs of streaming. If you understood
  these ABCs you have a total comprehension of `Stream f m r`:\n\n-   `Stream` expresses
  what the word \"succession\" meant in the ABCs\n-   The general parameter `f` expresses
  what was meant by \"such streams\"\n-   `m` expresses the relevant form of \"effect\".\n\nGeneral
  combinators for working with this idea of succession __irrespective of the form
  of succession__ are contained in the module `Stream`. They can be used, or example,
  to organize a succession of io-streams `Generator`s or pipes `Producer`s or the
  effectful bytestreams of the [streaming-bytestring](https://hackage.haskell.org/package/streaming-bytestring)
  library, or whatever stream-form you can express in a Haskell functor.\n\nA freely
  generated stream of individual Haskell values is a Producer, Generator or Source\n---------------------------------------------------------------------------------------------------\n\nBut,
  of course, as soon as you grasp the general form of *succession*, you are already
  in possession of the most basic concrete form: a simple *succession of individual
  Haskell values* one after another. This is just `Stream ((,) a) m r`. Here we prefer
  `Stream (Of a) m r`, strictifying the left element of the pair with \n\n    data
  Of a r = !a :> r deriving Functor\n\nEither way, the pairing just links the present
  element with the rest of the stream. The primitive `yield` statement just expresses
  the pairing of the yielded item with the rest of the stream; or rather it is itself
  the trivial singleton stream. \n\n    yield 17  :: Stream (Of Int) IO ()\n\n`Streaming.Prelude`
  is focused on the manipulation of this all-important stream-form, which appears
  in the streaming IO libraries under titles like:\n\n    io-streams: Generator a
  r\n    pipes:      Producer a m r\n    conduit:    ConduitM () o m r\n    streaming:
  \ Stream (Of a) m r\n\nThe only difference is that in `streaming` the simple generator
  or producer concept is formulated explicitly in terms of the *general* concept of
  successive connection. But *this is a concept you need and already possess anyway*,
  as your comprehension of the streaming ABCs showed.\n\nThe special case of a *stream
  of individual Haskell values* that simply *comes to an end without a special result*
  is variously expressed thus:\n\n    io-streams: InputStream a \n    pipes:      Producer
  a m ()\n    conduit:    Source m a\n    machines:   SourceT m a (= forall k. MachineT
  m k a)\n    streaming:  Stream (Of a) m ()\n\n`Streaming.Prelude`\n-------------------\n\n`Streaming.Prelude`
  closely follows `Pipes.Prelude`. But since it restricts itself to use only of the
  general idea of streaming, it cleverly *omits the pipes*:\n\n    ghci> S.stdoutLn
  $ S.take 2 S.stdinLn\n    let's<Enter>\n    let's\n    stream<Enter>\n    stream\n\nHere's
  a little *connect and resume*, as the streaming-io experts call it:\n\n    ghci>
  rest <- S.print $ S.splitAt 3 $ S.each [1..10]\n    1\n    2\n    3\n    ghci> S.sum
  rest\n    49\n\nSomehow, we didn't even need a four-character operator for that,
  nor advice about best practices! - just ordinary Haskell common sense.\n\nMother's
  `Prelude` v. `Streaming.Prelude`\n-----------------------------------------\n\nThe
  effort of `Streaming.Prelude` is to leverage the intuition the user has acquired
  in mastering `Prelude` and `Data.List` and to elevate her understanding into a general
  comprehension of effectful streaming transformations. Unsurprisingly, it takes longer
  to type out the signatures. It cannot be emphasized enough, thought, that *the transpositions
  are totally mechanical*:\n\n    Data.List.Split.chunksOf :: Int -> [a]          ->
  [[a]]\n    Streaming.chunksOf       :: Int -> Stream f m r -> Stream (Stream f m)
  m r\n\n    Prelude.splitAt   :: Int -> [a]          -> ([a],[a])\n    Streaming.splitAt
  :: Int -> Stream f m r -> Stream f m (Stream f m r)\n\nThese concepts are \"functor
  general\", in the jargon used in the documentation, and are thus exported by the
  main `Streaming` module. Something like `break` requires us to inspect individual
  values for their properties, so it is found in the `Streaming.Prelude`\n\n    Prelude.break
  \          :: (a -> Bool) -> [a]               -> ([a],[a])\n    Streaming.Prelude.break
  :: (a -> Bool) -> Stream (Of a) m r -> Stream (Of a) m (Stream (Of a) m r)\n\nIt
  is easy to prove that *resistance to these types is resistance to effectful streaming
  itself*. I will labor this point a bit more below, but you can also find it developed,
  with greater skill, in the documentation for the pipes libraries.\n\nHow come there's
  not one of those fancy \"ListT done right\" implementations in here?\n-----------------------------------------------------------------------------------\n\nThe
  use of the final return value appears to be a complication, but in fact it is essentially
  contained in the idea of effectful streaming. This is why this library does not
  export a \\_ListT done right/, which would be simple enough - following `pipes`,
  as usual:\n\n    newtype ListT m a = ListT (Stream (Of a) m ())\n\nThe associated
  monad instance would wrap\n\n    yield :: (Monad m)            => a -> Stream (Of
  a) m ()\n    for   :: (Monad m, Functor f) => Stream (Of a) m r -> (a -> Stream
  f m ()) -> Stream f m r\n\nTo see the trouble, consider [this signature](http://hackage.haskell.org/package/list-t-0.4.5.1/docs/ListT.html#v:splitAt)
  for splitting a ListT very much done right. Here's what becomes of [chunksOf](http://hackage.haskell.org/package/list-t-0.4.5.1/docs/src/ListT.html#slice).
  As long as we are trapped in some sort of ListT, however much rightly implemented,
  these operations can't be made to stream; something like a list must be accumulated.
  Similarly, try to imagine adding a `splitAt` or `lines` function to [this API](https://hackage.haskell.org/package/list-t-text-0.2.0.2/docs/ListT-Text.html).
  It would accumulate strict text forever, just as [this does](https://hackage.haskell.org/package/io-streams-1.3.2.0/docs/System-IO-Streams-ByteString.html#v:lines)
  and [this doesn't](https://hackage.haskell.org/package/pipes-bytestring-2.1.1/docs/src/Pipes-ByteString.html#lines)
  and [this doesn't](https://hackage.haskell.org/package/streaming-bytestring-0.1.0.6/docs/Data-ByteString-Streaming-Char8.html#v:lines)
  The difference is simply that the latter libraries operate with the general concept
  of streaming, and the whole implementation is governed by it. The attractions of
  the various \"`ListT` done right\" implementations are superficial; the concept
  belongs to logic programming, not stream programming.\n\nNote similarly that you
  can write a certain kind of [take](http://hackage.haskell.org/package/machines-0.5.1/docs/Data-Machine-Process.html#v:taking)
  and [drop](http://hackage.haskell.org/package/machines-0.5.1/docs/Data-Machine-Process.html#v:dropping)
  with the `machines` library - as you can even with a \"`ListT` done right\". But
  I wish you luck writing `splitAt`! Similarly you can write a [getContents](http://hackage.haskell.org/package/machines-io-0.2.0.6/docs/System-IO-Machine.html);
  but I wish you luck dividing the resulting bytestream on its lines. This is - as
  usual! - because the library was not written with the general concept of effectful
  succession or streaming in view. Materials for sinking some elements of a stream
  in one way, and others in other ways - copying each line to a different file, as
  it might be, but without accumulation - are documented within. So are are myriad
  other elementary operations of streaming io.\n\nDidn't I hear that free monads are
  a dog from the point of view of efficiency?\n------------------------------------------------------------------------------\n\nWe
  noted above that if we instantiate `Stream f m r` to `Stream ((,) a) m r` or the
  like, we get the standard idea of a producer or generator. If it is instantiated
  to `Stream f Identity m r` then we have the standard \\_free monad construction/.
  This construction is subject to certain familiar objections from an efficiency perspective;
  efforts have been made to substitute exotic cps-ed implementations and so forth.
  It is an interesting topic.\n\nBut in fact, the standard alarmist talk about *retraversing
  binds* and *quadratic explosions* and *costly appends*, and so on become transparent
  nonsense with `Stream f m r`\\\nin its streaming use. The conceptual power needed
  to see this is basically nil: Where `m` is read as `IO`, or some transformed `IO`,
  then the dreaded *retraversing of the binds* in a stream expression would involve
  repeating all the past actions. Don't worry, to get e.g. the second chunk of bytes
  from a handle, you won't need to start over and get the first one again! The first
  chunk has vanished into an unrepeatable past.\n\nAll of the difficulties a streaming
  library is attempting to avoid are concentrated in the deep irrationality of\n\n
  \   sequence :: (Monad m, Traversable t) => t (m a) -> m (t a)\n\nIn the streaming
  context, this becomes\n\n    sequence :: Monad m, Functor f => Stream f m r -> Stream
  f m r\n    sequence = id\n\nIt is of course easy enough to define\n\n    accumulate
  :: Monad m, Functor f => Stream f m r -> m (Stream f Identity r)\n\nor `reifyBindsRetraversingWherePossible`
  or `_ICan'tTakeThisStreamingAnymore`, as you might call it. *The types themselves*
  teach the user how to avoid or control the sort of accumulation characteristic of
  `sequence` in its various guises e.g. `mapM f = sequence . map f` and `traverse
  f = sequence . fmap f` and `replicateM n = sequence . replicate n`. See for example
  the types of\n\n    Control.Monad.replicateM :: Int -> m a -> m [a]\n    Streaming.Prelude.replicateM
  :: Int -> m a -> Stream (Of a) m ()\n\nIf you want to tempt fate and replicate the
  irrationality of `Control.Monad.replicateM`, then sure, you can define the hermaphroditic
  chimera\n\n    accumulate . Streaming.Prelude.replicateM :: Int -> m a -> m (Stream
  (Of a) Identity ())\n\nwhich is what we find in our diseased base libraries. But
  once you know how to operate with a stream directly you will see less and less point
  in what is called *extracting the (structured) value from IO*. Consider the apparently
  innocent distinction between\n\n    \"getContents\" :: String\n\nand\n\n    getContents
  :: IO String \n\nOmitting consideration of eof, we might define `getContents` thus\n\n
  \   getContents = sequence $ repeat getChar\n\nThere it is again! The very devil!
  By contrast there is no distinction between\n\n    \"getContents\" :: Stream (Of
  Char) m ()  -- the IsString instance is monad-general\n\nand\n\n    getContents
  :: MonadIO m => Stream (Of Char) m ()\n\nThey unify just fine. That is, if I make
  the type synonym\n\n    type String m r = Stream (Of Char) m r\n\nI get, for example:\n\n
  \   \"getLine\"                              :: String m  ()\n    getLine                                ::
  String IO ()\n    \"getLine\" >> getLine                   :: String IO ()\n    splitAt
  20 $ \"getLine\" >> getLine      :: String IO (String IO ())\n    length $ \"getLine\"
  >> getLine          :: IO Int\n\nand can dispense with half the advice they will
  give you on `#haskell`. It is only a slight exaggeration to say that a stream should
  never be \"extracted from IO\". \n\nWith `sequence` and `traverse`, we accumulate
  a pure succession of pure values from a pure succession of monadic values. Why bother
  if you have intrinsically monadic conception of succession or traversal? `Stream
  f m r` gives you an immense body of such structures and a simple discipline for
  working with them. Spinkle `id` freely though your program, under various names,
  if you get homesick for `sequence` and company.\n\nInteroperation with the streaming-io
  libraries\n----------------------------------------------\n\nThe simplest form of
  interoperation with [pipes](http://hackage.haskell.org/package/pipes) is accomplished
  with this isomorphism:\n\n    Pipes.unfoldr Streaming.next        :: Stream (Of
  a) m r   -> Producer a m r\n    Streaming.unfoldr Pipes.next        :: Producer
  a m r      -> Stream (Of a) m r                     \n\nOf course, `streaming` can
  be mixed with `pipes` wherever `pipes` itself employs `Control.Monad.Trans.Free`;
  speedups are frequently appreciable. (This was the original purpose of the main
  `Streaming` module, which just mechanically transposes a simple optimization employed
  in `Pipes.Internal`.) Interoperation with [io-streams](http://hackage.haskell.org/package/io-streams)
  is thus:\n\n    Streaming.reread IOStreams.read     :: InputStream a       -> Stream
  (Of a) IO ()\n    IOStreams.unfoldM Streaming.uncons  :: Stream (Of a) IO () ->
  IO (InputStream a)\n\nA simple exit to [conduit](http://hackage.haskell.org/package/conduit)
  would be, e.g.:\n\n    Conduit.unfoldM Streaming.uncons    :: Stream (Of a) m ()
  \ -> Source m a\n\nThese conversions should never be more expensive than a single
  `>->` or `=$=`.\n\nAt a much more general level, we also of course have interoperation
  with [free](http://hackage.haskell.org/package/free):\n\n    Free.iterTM  Stream.wrap
  \             :: FreeT f m a -> Stream f m a\n    Stream.iterTM Free.wrap               ::
  Stream f m a -> FreeT f m a \n\nWhere can I find examples of use?\n---------------------------------\n\nFor
  some simple ghci examples, see the commentary throughout the Prelude module. For
  slightly more advanced usage see the commentary in the haddocks of [streaming-bytestring](https://hackage.haskell.org/package/streaming-bytestring)
  and e.g. [these replicas](https://gist.github.com/michaelt/6c6843e6dd8030e95d58)
  of shell-like programs from the io-streams tutorial. Here's a simple [streaming
  GET request](https://gist.github.com/michaelt/2dcea1ba32562c091357) with intrinsically
  streaming byte streams.\n\nProblems\n--------\n\nQuestions about this library can
  be put as issues through the github site or on the [pipes mailing list](https://groups.google.com/forum/#!forum/haskell-pipes).
  (This library understands itself as part of the pipes \"ecosystem.\")\n\n* * * *
  *\n\nimplementation notes\n\nThis library defines an optimized `FreeT` with an eye
  to use with streaming libraries, namely:\n\n    data Stream f m r\n         = Return
  r\n         | Step !(f (Stream f m r))\n         | Delay (m (Stream f m r))\n\nin
  place of the standard `FreeT` that we find in the `free` library, which is approximately:\n\n
  \   newtype FreeT f m r = FreeT {runFreeT :: m (Either r (f (FreeT f m r)))}\n\nRather
  than wrapping each step in a monadic 'layer', such a layer is put alongside separate
  'pure' constructors for a functor 'layer' and a final return value. The maneuver
  is very friendly to the compiler, but requires a bit of subtlety to protect a sound
  monad instance. Just such an optimization is adopted internally by the `pipes` library.
  As in `pipes`, the constructors are here left in an `Internal` module; the main
  `Streaming` module exporting the type itself and various operations and instances.\n\nThere
  is also a still-incomplete `Prelude` of functions, some `FreeT` or `Stream` - general,
  some involving the functor `((,) a)` here called `Of a`. (`Stream (Of a) m r` like
  `FreeT ((,) a) m r` is equivalent to the `pipes` `Producer a m r` type. Similarly,
  `Stream (Of a) m ()` and `FreeT ((,) a) m ()` are possible implementations of `ListT
  done right`.\n\nI ran a simple [benchmark](https://gist.github.com/michaelt/7f89dc8b366b30bb6acc)
  (adjusting a [script](https://github.com/jwiegley/streaming-tests) of John Weigly)
  using a very simple composition of functions:\n\n    toList \n    . filter (\\x
  -> x `mod` 2 == 0) \n    . map (+1) \n    . drop 1000 \n    . map (+1) \n    . filter
  even \n    . each\n\nThe the results were fairly pleasing:\n\n    benchmarking basic/streaming\n
  \   time                 84.50 ms   (79.81 ms .. 87.90 ms)\n\n    benchmarking basic/iostreams\n
  \   time                 266.2 ms   (235.6 ms .. 292.0 ms)\n\n    benchmarking basic/pipes\n
  \   time                 232.0 ms   (206.6 ms .. 246.7 ms)\n\n    benchmarking basic/conduit\n
  \   time                 102.3 ms   (96.24 ms .. 110.0 ms)\n\nThis sequence of pre-packaged
  combinators is, I think, very friendly to the more recent conduit fusion framework.
  The framework of course doesn't apply to user-defined operations, where we should
  expect times like those shown for pipes. Since the combinators from `streaming`
  is defined with naive recursion, more or less as the user might, we have reason
  to think the result is characteristic, but much more benchmarking is needed before
  anything can be said with certainty. The labor of constructor-hiding may turn up
  some further difficulty.\n"
license-name: BSD3
