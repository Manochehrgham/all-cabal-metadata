homepage: https://github.com/michaelt/streaming
changelog-type: ''
hash: d7f5edb722d8c852a599a2340cbe918e6a5778e1e18ba216866661eeec111d3f
test-bench-deps: {}
maintainer: what_is_it_to_do_anything@yahoo.com
synopsis: A free monad transformer optimized for streaming applications.
changelog: ''
basic-deps:
  base: ! '>=4.7 && <4.9'
  ghc-prim: -any
  mtl: ! '>=2.1 && <2.3'
  mmorph: ! '>=1.0 && <1.2'
  transformers: ! '>=0.3 && <0.5'
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.1.0.3'
- '0.1.0.4'
- '0.1.0.5'
author: michaelt
latest: '0.1.0.5'
description-type: haddock
description: ! '`Stream` can be used wherever `FreeT` is used. The compiler

  is better able to optimize operations written in

  terms of `Stream`.


  See the examples in @Streaming.Prelude@ for a sense

  of how simple the library is to use and think about.

  @Streaming.Prelude@ closely follows

  @Pipes.Prelude@, but cleverly omits the pipes. It is focused

  on employment with a base functors which generate

  effectful sequences: i.e., things like


  * @Pipes.Producer@


  * @Conduit.Source@


  * @IOStreams.InputStream@


  * @IOStreams.Generator@


  Interoperation with

  <http://hackage.haskell.org/package/pipes pipes>

  is accomplished with this isomorphism which

  uses @Pipes.Prelude.unfoldr@ from @HEAD@:


  > Pipes.unfoldr Streaming.next        :: Stream (Of a) m r   -> Producer a m r

  > Streaming.unfoldr Pipes.next        :: Producer a m r      -> Stream (Of a) m
  r


  (If you don''t have @pipes-HEAD@, inline the definition of <https://github.com/Gabriel439/Haskell-Pipes-Library/blob/master/src/Pipes/Prelude.hs#L909
  unfoldr>.)


  Interoperation with

  <http://hackage.haskell.org/package/io-streams io-streams>

  is thus:


  > Streaming.reread IOStreams.read     :: InputStream a       -> Stream (Of a) IO
  ()

  > IOStreams.unfoldM Streaming.uncons  :: Stream (Of a) IO () -> IO (InputStream
  a)


  for example. A simple exit to <http://hackage.haskell.org/package/conduit conduit>
  would be, e.g.:


  > Conduit.unfoldM Streaming.uncons    :: Stream (Of a) m ()  -> Source m a


  These conversions should never be more expensive than a single @>->@ or @=$=@.'
license-name: BSD3
