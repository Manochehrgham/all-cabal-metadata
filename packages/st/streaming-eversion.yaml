homepage: ''
changelog-type: text
hash: 302020753bc10bc20246cf267677cdc0b0f442af14e1f98b185bfa9b6c3f7a81
test-bench-deps:
  streaming: ! '>=0.1.4.2'
  pipes-text: ! '>=0.0.2.2'
  base: ! '>=4.4 && <5'
  doctest: ! '>=0.10.1'
  streaming-eversion: -any
  pipes: ! '>=4.1.9'
  tasty-quickcheck: ! '>=0.8.3.2'
  foldl: ! '>=1.1.5'
  tasty-hunit: ! '>=0.9.2'
  tasty: ! '>=0.10.1.1'
maintainer: diaz_carrete@yahoo.com
synopsis: Translate pull-based stream folds into push-based iteratees.
changelog: ''
basic-deps:
  streaming: ! '>=0.1.4.2'
  free: ! '>=4'
  base: ! '>=4 && <5'
  comonad: ! '>=4'
  bifunctors: ! '>=4'
  pipes: ! '>=4.2.0'
  foldl: ! '>=1.1.5'
  transformers: ! '>=0.4.0.0'
  profunctors: ! '>=5'
all-versions:
- '0.1.0.0'
author: Daniel Diaz
latest: '0.1.0.0'
description-type: markdown
description: ! "## What's in this library?\n\nFunctions that turn pull-based stream
  operations from the pipes/streaming\necosystem into push-based, iteratee-like stream
  operations. \n\nInspired by the blog post [Programmatic translation to iteratees
  from pull-based code](http://pchiusano.blogspot.com.es/2011/12/programmatic-translation-to-iteratees.html).\n\n##
  Could you go into more detail?\n\nThere are three streaming libraries that often
  go together:\n[pipes](http://hackage.haskell.org/package/pipes),\n[streaming](http://hackage.haskell.org/package/streaming),
  and\n[foldl](http://hackage.haskell.org/package/foldl).\n\nOf these, the first two
  are pull-based: you take some (possibly effectful)\nsource of values and keep extracting
  stuff until the source is exhausted and/or\nyou have obtained all the info you need.\n\nMeanwhile,
  foldl is push-based: foldl folds are not directly aware of any\nsource, they are
  like little state machines that keep running as long as\nsomeone feeds them input.
  \n\nUsually, defining stream transformations in pull-based mode is easier and feels\nmore
  natural. The pipes ecosystem already provides a lot of them:\n[parsers](http://hackage.haskell.org/package/pipes-parse),\n[decoders](http://hackage.haskell.org/package/pipes-text),\n[splitters](http://hackage.haskell.org/package/pipes-group)...\n\nHowever,
  push-based mode also has advantages. Push-based abstractions are not\ntied to a
  particular type of source because data is fed externally. And foldl\nfolds have
  very useful Applicative and Comonad instances. \n\nAlso, sometimes, a library will
  only offer a push-based interface. \n\nWouldn't it be nice if you could adapt already
  existing pull-based operations\nto work on push-based consumers? For example, using
  a decoding function from\n[Pipes.Text.Encoding](http://hackage.haskell.org/package/pipes-text-0.0.2.4/docs/Pipes-Text-Encoding.html#g:6)\nto
  preprocess the inputs of a\n[Fold](http://hackage.haskell.org/package/foldl-1.2.1/docs/Control-Foldl-Text.html).\n\nThis
  library provides that.\n\n## Why so many newtypes?\n\nTo avoid having to enable
  [-XImpredicativeTypes](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#impredicative-polymorphism).\n\n##
  Is it fast?\n\nI haven't benchmarked or optimized it. It is likely to be slow.\n\n"
license-name: BSD3
