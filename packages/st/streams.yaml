changelog-type: ''
hash: 3c1008ebd4890a9ddbde5b752fc24c5479f62bec7006c89a7c381aaaa9537bec
synopsis: Various Haskell 2010 stream comonads
changelog: ''
all-versions:
- '0.1.1'
- '0.2'
- '0.3'
- '0.3.1'
- '0.4'
- '0.5.0'
- '0.5.1'
- '0.5.1.1'
- '0.5.1.2'
- '0.6.0'
- '0.6.0.1'
- '0.6.1.1'
- '0.6.1.2'
- '0.6.3'
- '0.7.0'
- '0.7.1'
- '0.7.2'
- '0.8.0'
- '0.8.0.1'
- '0.8.0.2'
- '0.8.0.3'
- '0.8.0.4'
- '0.8.1'
- '0.8.2'
- '3.0'
- '3.0.0.1'
- '3.0.1'
- '3.0.1.1'
- '3.1'
- '3.1.1'
- '3.2'
latest: '3.2'
description-type: haddock
description: ! 'Various Haskell 2010 stream comonads.

  * "Data.Stream.Future" provides a coinductive anti-causal stream, or non-empty ''ZipList''.
  The comonad provides access to only the

  tail of the stream. Like a conventional ''ZipList'', this is /not/ a monad.


  > data Future a = Last a | a :< Future a


  * "Data.Stream.Future.Skew" provides a non-empty skew-binary random-access-list
  with the semantics of @Data.Stream.Future@. As with

  "Data.Stream.Future" this stream is not a ''Monad'', since the ''Applicative'' instance
  zips streams of potentially differing lengths.

  The random-access-list structure provides a number of operations logarithmic access
  time, but makes ''Data.Stream.Future.Skew.cons''

  less productive. Where applicable "Data.Stream.Infinite.Skew" may be more efficient,
  due to a lazier and more efficient ''Applicative''

  instance.


  >


  * "Data.Stream.Infinite" provides a coinductive infinite anti-causal stream. The
  ''Comonad'' provides access to the tail of the

  stream and the ''Applicative'' zips streams together. Unlike ''Future'', infinite
  stream form a ''Monad''. The monad diagonalizes

  the ''Stream'', which is consistent with the behavior of the ''Applicative'', and
  the view of a ''Stream'' as a isomorphic to the reader

  monad from the natural numbers. Being infinite in length, there is no ''Alternative''
  instance.


  > data Stream a = a :< Stream a


  * "Data.Stream.Infinite.Skew" provides an infinite skew-binary random-access-list
  with the semantics of "Data.Stream.Infinite"

  Since every stream is infinite, the ''Applicative'' instance can be considerably
  less strict than the corresponding instance for

  "Data.Stream.Future.Skew" and performs asymptotically better.


  >


  * "Data.Stream.Infinite.Functional.Zipper" provides a bi-infinite sequence, represented
  as a pure function with an accumulating

  parameter added to optimize moving the current focus.


  > data Zipper a = !Integer :~ (Integer -> a)


  * "Data.Stream.Supply" provides a comonadic supply of unique values, which are

  generated impurely as the tree is explored.'
