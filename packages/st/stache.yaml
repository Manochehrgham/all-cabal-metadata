homepage: https://github.com/stackbuilders/stache
changelog-type: markdown
hash: ec1c5cb174f30ef65d7f11409dbc0180f5563d613ccccf12f5efb6a9f0a6a810
test-bench-deps:
  bytestring: ! '>=0.10 && <0.11'
  base: ! '>=4.7 && <5.0'
  hspec: ! '>=2.0 && <3.0'
  text: ==1.2.*
  megaparsec: ! '>=5.0 && <6.0'
  criterion: ! '>=0.6.2.1 && <1.2'
  semigroups: ==0.18.*
  containers: ==0.5.*
  stache: ! '>=0.1.4'
  hspec-megaparsec: ! '>=0.2 && <0.3'
  file-embed: -any
  deepseq: ! '>=1.4 && <1.5'
  aeson: ==0.11.*
  yaml: ! '>=0.8 && <0.9'
maintainer: Mark Karpov <markkarpov@openmailbox.org>
synopsis: Mustache templates for Haskell
changelog: ! "## Stache 0.1.4\n\n* Numbers are now treated as “true” values.\n\n*
  Added `Semigroup` instance for `Key`.\n\n* Now change of delimiters affects special
  unescaped variable syntax as\n  well, for example: `{{=<< >>=}}<<{var}>>` will be
  parsed as unescaped\n  variable `var`.\n\n* `compileMustacheFile` now shows full
  path to malformed template when the\n  template cannot be parsed.\n\n* Defined `displayException`
  method of `Exception` type class for\n  `MustacheException` using `parseErrorPretty`
  from Megaparsec.\n\n## Stache 0.1.3\n\n* Cosmetic improvements.\n\n* Minor improvement
  in performance of parser.\n\n## Stache 0.1.2\n\n* Fixed compilation of benchmarks
  with Megaparsec 5.0.1 and later.\n\n## Stache 0.1.1\n\n* Added benchmarks.\n\n##
  Stache 0.1.0\n\n* Initial release.\n"
basic-deps:
  exceptions: ! '>=0.8 && <0.9'
  bytestring: ! '>=0.10 && <0.11'
  base: ! '>=4.7 && <5.0'
  unordered-containers: ! '>=0.2.5 && <0.3'
  text: ! '>=1.2 && <1.3'
  megaparsec: ! '>=5.0 && <6.0'
  filepath: ! '>=1.2 && <1.5'
  semigroups: ==0.18.*
  containers: ! '>=0.5 && <0.6'
  mtl: ! '>=2.1 && <3.0'
  deepseq: ! '>=1.4 && <1.5'
  aeson: ! '>=0.11 && <0.12'
  template-haskell: ! '>=2.10 && <2.12'
  vector: ! '>=0.11 && <0.12'
  directory: ! '>=1.2 && <1.3'
all-versions:
- '0.1.0'
- '0.1.1'
- '0.1.2'
- '0.1.3'
- '0.1.4'
author: Mark Karpov <markkarpov@openmailbox.org>
latest: '0.1.4'
description-type: markdown
description: ! "# Stache\n\n[![License BSD3](https://img.shields.io/badge/license-BSD3-brightgreen.svg)](http://opensource.org/licenses/BSD-3-Clause)\n[![Hackage](https://img.shields.io/hackage/v/stache.svg?style=flat)](https://hackage.haskell.org/package/stache)\n[![Stackage
  Nightly](http://stackage.org/package/stache/badge/nightly)](http://stackage.org/nightly/package/stache)\n[![Stackage
  LTS](http://stackage.org/package/stache/badge/lts)](http://stackage.org/lts/package/stache)\n[![Build
  Status](https://travis-ci.org/stackbuilders/stache.svg?branch=master)](https://travis-ci.org/stackbuilders/stache)\n[![Coverage
  Status](https://coveralls.io/repos/github/stackbuilders/stache/badge.svg?branch=master)](https://coveralls.io/github/stackbuilders/stache?branch=master)\n\nThis
  is a Haskell implementation of Mustache templates. The implementation\nconforms
  to the version 1.1.3 of official [Mustache specification]\n(https://github.com/mustache/spec).
  It is extremely simple and\nstraightforward to use with minimal but complete API
  — three functions to\ncompile templates (from directory, from file, and from lazy
  text) and one to\nrender them.\n\nThe implementation uses the Megaparsec parsing
  library to parse the\ntemplates which is results in superior quality of error messages.\n\nFor
  rendering you only need to create Aeson's `Value` where you put the data\nto interpolate.
  Since the library re-uses Aeson's instances and most data\ntypes in Haskell ecosystem
  are instances of classes like\n`Data.Aeson.ToJSON`, the whole process is very simple
  for end user.\n\nTemplate Haskell helpers for compilation of templates at compile
  time are\navailable in the `Text.Mustache.Compile.TH` module. The helpers are\ncurrently
  available only for GHC 8 users though.\n\nOne feature that is not currently supported
  is lambdas. The feature is\nmarked as optional in the spec and can be emulated via
  processing of parsed\ntemplate representation. The decision to drop lambdas is intentional,
  for\nthe sake of simplicity and better integration with Aeson.\n\n## Quick start\n\nHere
  is an example of basic usage:\n\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule
  Main (main) where\n\nimport Data.Aeson\nimport Data.Text\nimport Text.Megaparsec\nimport
  Text.Mustache\nimport qualified Data.Text.Lazy.IO as TIO\n\nmain :: IO ()\nmain
  = do\n  let res = compileMustacheText \"foo\"\n        \"Hi, {{name}}! You have:\\n{{#things}}\\n
  \ * {{.}}\\n{{/things}}\\n\"\n  case res of\n    Left err -> putStrLn (parseErrorPretty
  err)\n    Right template -> TIO.putStr $ renderMustache template $ object\n      [
  \"name\"   .= (\"John\" :: Text)\n      , \"things\" .= [\"pen\" :: Text, \"candle\",
  \"egg\"]\n      ]\n```\n\nIf I run the program, it prints the following:\n\n```\nHi,
  John! You have:\n  * pen\n  * candle\n  * egg\n```\n\nFor more information about
  Mustache templates the following links may be\nhelpful:\n\n* The official Mustache
  site: https://mustache.github.io/\n* The manual: https://mustache.github.io/mustache.5.html\n*
  The specification: https://github.com/mustache/spec\n\n## License\n\nCopyright ©
  2016 Stack Builders\n\nDistributed under BSD 3 clause license.\n"
license-name: BSD3
