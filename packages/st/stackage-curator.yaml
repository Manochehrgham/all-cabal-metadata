changelog-type: markdown
hash: 667795c397dd68af74dd88f9a9c0c0030846b2f47134b68c5ab2ec0a1367b1a2
test-bench-deps:
  stackage-curator: -any
  http-client: -any
  Cabal: -any
  base: -any
  hspec: -any
  text: -any
  classy-prelude-conduit: -any
  containers: -any
  http-client-tls: -any
  QuickCheck: -any
  yaml: -any
synopsis: Tools for curating Stackage bundles
changelog: ! '## 0.8.1


  * Redefine core packages [#395](https://github.com/fpco/stackage/issues/395)

  * Add --constraint flag for create-plan


  ## 0.8.0.1


  * GHC 7.10 support


  ## 0.8.0


  * Restructured commands to work on server/Docker setup


  ## 0.7.4


  * `-j`/`--jobs` option for build flags

  * Only pass in required .haddock files (more memory efficiency)


  ## 0.7.3


  * Number of jobs == number of capabilities

  * `--bundle-dest`

  * `--skip-git-push`

  * Removed some of the old upload stuff

  * Better exception output (limited to 500 characters)


  ## 0.7.2


  * Add `diff` command


  ## 0.7.1.1


  * Fix bug with existing .haddock file collection


  ## 0.7.1


  * Add the `stats` command


  ## 0.7.0.4


  * Respect --summary option


  ## 0.7.0.3


  * LTS bumps: specify a goal


  ## 0.7.0.2


  * Deal better with invariant violations around unregistered packages


  ## 0.7.0


  * Renamed to stackage-curator


  ## 0.6.1


  * Switch to V2 upload by default

  * --skip-hoogle option


  ## 0.6.0


  * Upload bundle V2 stuff


  ## 0.5.2


  * Upload LTS to Hackage with the name LTSHaskell


  ## 0.5.1


  * `loadBuildConstraints`

  * More command line options


  ## 0.5.0


  * Print "Still Alive" while checking, to avoid Travis timeouts

  * Include `stackage upload-nightly` command

  * Optional plan checking


  ## 0.4.0


  * Command line uses optparse-applicative with additional options

  * Library profiling support during build

  * Remove cfGlobalFlags (just use package-specific flags)


  ## 0.3.1


  * Added `justCheck` and `stackage check` command line.


  ## 0.3.0.1


  Pre-fetch all packages from Hackage to catch Hackage downtime early.


  ## 0.3.0.0


  * Return progress URL from uploadBundle


  ## 0.2.1.4


  Generate a `core` file in bundles.


  ## 0.2.1.1


  Run postBuild earlier to avoid problems from broken doc uploads.


  ## 0.2.1.0


  * Use TLS manager (to download from Github)


  ## 0.2.0.0


  * Minor fixes

  * `pbGlobalInstall`


  ## 0.1.0.0


  First version of Stackage which is made available as its own package. The

  codebase has been completely rewritten at this point, to be ready for generated

  both Stackage Nightly and LTS Haskell distributions.

'
basic-deps:
  stackage-curator: -any
  http-client: -any
  streaming-commons: ! '>=0.1.7.1'
  bytestring: -any
  stm: -any
  xml-conduit: -any
  Cabal: ! '>=1.14'
  base: ==4.*
  data-default-class: -any
  time: -any
  text: -any
  system-fileio: -any
  unix-compat: -any
  filepath: -any
  process: -any
  async: -any
  stackage-cli: -any
  conduit: -any
  classy-prelude-conduit: -any
  semigroups: -any
  conduit-extra: -any
  stackage-update: -any
  containers: -any
  tar: ! '>=0.3'
  utf8-string: -any
  old-locale: -any
  http-client-tls: -any
  zlib: -any
  mtl: -any
  optparse-simple: -any
  monad-unlift: -any
  transformers: -any
  stackage-types: -any
  temporary: -any
  optparse-applicative: ! '>=0.11'
  http-conduit: -any
  system-filepath: -any
  aeson: -any
  mono-traversable: -any
  yaml: -any
  directory: -any
all-versions:
- '0.7.0'
- '0.7.0.1'
- '0.7.0.2'
- '0.7.0.3'
- '0.7.0.4'
- '0.7.0.5'
- '0.7.1'
- '0.7.1.1'
- '0.7.2'
- '0.7.2.1'
- '0.7.3'
- '0.7.4'
- '0.8.0'
- '0.8.0.1'
- '0.8.1'
latest: '0.8.1'
description-type: markdown
description: ! '## stackage-curator


  [![Build Status](https://travis-ci.org/fpco/stackage-curator.svg?branch=master)](https://travis-ci.org/fpco/stackage-curator)


  This repository contains the code for curating Stackage package sets and

  building reusable package databases. It was originally simply called the

  stackage package and was part of the stackage repository, but since this is a

  tool very few people need to use, we split it into its own package with a name

  to indicate it''s limited usage (curators only).


  More information on Stackage:


  * [Stackage Homepage](https://www.stackage.org)

  * [Main stackage repo](https://github.com/fpco/stackage)


  ### Code explanation


  We start off with *constraints*. Constraints state things like "package X has a

  given version range," who the maintainer is for a package, the description of

  the system/compiler being used, etc. `BuildConstraints` describes the build as

  a whole, whereas `PackageConstraints` describes the constraints on an

  individual package.


  There are two primary ways of getting a `BuildConstraints`.

  `defaultBuildConstraints` inspects the first GHC in the PATH environment variable
  to

  determine GHC version, core packages, core tools, etc. It then uses the

  `Stackage.Config` module to extract information on additional packages to be

  installed. The secondary approach is in `Stackage2.UpdateBuildPlan`, which will
  be

  discussed later.


  `BuildConstraints` does not specify a build completely. That is given by a

  `BuildPlan`, which is similarly broken down into `BuildPlan` and `PackagePlan`.

  In order to get a `BuildPlan`, we need two pieces of information: the

  `BuildConstraints`, and a package index. The package index (usually downloaded

  from Hackage) is a collection of all of the cabal files available.


  By applying a `BuildConstraints` to a package index (via `newBuildPlan`), we

  get a proposed `BuildPlan`. There is no guarantee that this `BuildPlan` is

  valid. To validate it, we use `checkBuildPlan`. A `BuildPlan` is an instance of

  both `ToJSON` and `FromJSON`, and therefore can be serialized to a file for

  later use.


  When dealing with LTS Haskell, we want to be able to take a `BuildPlan`, and

  update to a newer `BuildPlan` that keeps all packages at the same major

  version.  `updateBuildConstraints` turns a `BuildPlan` into a new

  `BuildConstraints` with that restriction, and `updateBuildPlan` applies

  `newBuildPlan` to that result. As mentioned previously: this is *not* a

  validated result, and therefore `checkBuildPlan` must be used.


  A `BuildPlan` can be acted on. This is done to check that all packages compile

  together, run relevant test suites, test Haddock documentation is correct, and

  produce as artifacts both a self-contained GHC binary package database and a

  set of Haddock documentation. (Not yet implemented.)


  A `BuildPlan` may be converted into a bundle to be uploaded to Stackage Server.

  (Not yet implemented.)

'
