homepage: https://github.com/frontrowed/stratosphere#readme
changelog-type: markdown
hash: ddf16149315c71ccf0ee4a1ccc74e9662eefcfe652836bb6e1f2ee301a46662d
test-bench-deps:
  hlint: -any
  bytestring: -any
  base: ! '>=4.8 && <5'
  aeson-pretty: ! '>=0.7'
  unordered-containers: ! '>=0.2'
  text: ! '>=1.1'
  system-fileio: -any
  tasty-hspec: -any
  lens: ! '>=4.5'
  ede: -any
  tasty: -any
  system-filepath: -any
  stratosphere: -any
  aeson: ! '>=0.11'
  template-haskell: ! '>=2.0'
  directory: -any
maintainer: David Reaver
synopsis: EDSL for AWS CloudFormation
changelog: ! "# Change Log\n\n## 0.1.1\n\n* Small bug fix for \"style\" test when
  using the cabal distribution\n\n## 0.1 (initial release)\n\n* Initial release with
  all Template components implemented along with a huge\n  set of Resources.\n"
basic-deps:
  bytestring: -any
  base: ! '>=4.8 && <5'
  aeson-pretty: ! '>=0.7'
  unordered-containers: ! '>=0.2'
  text: ! '>=1.1'
  system-fileio: -any
  lens: ! '>=4.5'
  ede: -any
  system-filepath: -any
  stratosphere: -any
  aeson: ! '>=0.11'
  template-haskell: ! '>=2.0'
all-versions:
- '0.1.0'
- '0.1.1'
author: ''
latest: '0.1.1'
description-type: markdown
description: ! "# Stratosphere: AWS CloudFormation in Haskell\n\n[![Circle CI](https://circleci.com/gh/frontrowed/stratosphere.svg?style=svg)](https://circleci.com/gh/frontrowed/stratosphere)\n\nAWS
  CloudFormation is a system that provisions and updates Amazon Web Services\n(AWS)
  resources based on declarative templates. Common criticisms of\nCloudFormation include
  the use of JSON as the template language and limited\nerror-checking, often only
  available in the form of run-time errors and stack\nrollbacks. By wrapping templates
  in Haskell, we are able to easily construct\nthem and help ensure correctness.\n\nThe
  goals of stratosphere are to:\n* Build a Haskell EDSL to specify CloudFormation
  templates. Since it is\n  embedded in Haskell, it is type-checked and generally
  much easier to work\n  with than raw JSON.\n* Have a simple checking/linting system
  outside of the types that can find\n  common errors in templates.\n* Be able to
  also read valid CloudFormation JSON templates so they can be\n  type-checked. This
  also gives us free integration tests by using the huge\n  amount of example templates
  available in the AWS docs.\n\n## Example\n\nHere is an example of a `Template` that
  creates an EC2 instance, along with the\nJSON output:\n\n```haskell\n{-# LANGUAGE
  OverloadedLists #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main where\n\nimport
  qualified Data.ByteString.Lazy.Char8 as B\nimport Stratosphere\n\nmain :: IO ()\nmain
  = B.putStrLn $ encodeTemplate instanceTemplate\n\ninstanceTemplate :: Template\ninstanceTemplate
  =\n  template\n  [ resource \"EC2Instance\" (\n    EC2InstanceProperties $\n    ec2Instance\n
  \   \"ami-22111148\"\n    & eciKeyName ?~ (Ref \"KeyName\")\n    )\n    & deletionPolicy
  ?~ Retain\n  ]\n  & description ?~ \"Sample template\"\n  & parameters ?~\n  [ parameter
  \"KeyName\" \"AWS::EC2::KeyPair::KeyName\"\n    & description ?~ \"Name of an existing
  EC2 KeyPair to enable SSH access to the instance\"\n    & constraintDescription
  ?~ \"Must be the name of an existing EC2 KeyPair.\"\n  ]\n```\n\n```json\n{\n  \"Description\":
  \"Sample template\",\n  \"Parameters\": {\n    \"KeyName\": {\n      \"Description\":
  \"Name of an existing EC2 KeyPair to enable SSH access to the instance\",\n      \"ConstraintDescription\":
  \"Must be the name of an existing EC2 KeyPair.\",\n      \"Type\": \"AWS::EC2::KeyPair::KeyName\"\n
  \   }\n  },\n  \"Resources\": {\n    \"EC2Instance\": {\n      \"DeletionPolicy\":
  \"Retain\",\n      \"Type\": \"AWS::EC2::Instance\",\n      \"Properties\": {\n
  \       \"KeyName\": {\n          \"Ref\": \"KeyName\"\n        },\n        \"ImageId\":
  \"ami-22111148\"\n      }\n    }\n  }\n}\n```\n\nPlease see the [examples](examples/)
  directory for more in-depth examples.\n\n## Value Types\n\nCloudFormation resource
  parameters can be literals (strings, integers, etc),\nreferences to another resource
  or a Parameter, or the result of some function\ncall. We encapsulate all of these
  possibilities in the `Val a` type.\n\nWe recommend using the `OverloadedStrings`
  extension to reduce the number of\n`Literal`s you have to use.\n\nNote that CloudFormation
  represents numbers and bools in JSON as strings, so we\nhad to some types called
  `Integer'` and `Bool'` to override the `aeson`\ninstances. In a future version we
  plan on using our own JSON encoder/decoder to\nget around this.\n\n## Lenses\n\nAlmost
  every CloudFormation resource has a handful of required arguments, and\nmany more
  optional arguments. Each resource is represented as a record type\nwith optional
  arguments wrapped in `Maybe`. Each resource also comes with a\nconstructor that
  accepts required resource parameters as arguments. This allows\nthe user to succinctly
  specify the resource parameters they actually use\nwithout adding too much noise
  to their code.\n\nTo specify optional arguments, we recommend using the lens operators
  `&` and\n`?~`. In the example above, the `ec2Instance` function takes the AMI as
  an\nargument, since it is required by the `EC2Instance` resource type. Then, the\noptional
  EC2 key name is specified using the `&` and `?~` lens operators.\n\nThis approach
  is very similar to the approach taken by the `amazonka` library.\nSee this\n[blog
  post](http://brendanhay.nz/amazonka-comprehensive-haskell-aws-client#smart-constructors)\nfor
  an explanation.\n\n## Auto-generation\n\nAll of the resources and resource properties
  are auto-generated from JSON files\nand are placed in `library-gen/`. The `gen/`
  directory contains the\nauto-generator code and the JSON model files. We include
  the `library-gen/`\ndirectory in git so the build process is simplified. To build
  `library-gen`\nfrom scratch and then build all of `stratosphere`, just run the very
  short\n`build.sh` script. You can pass stack args to the script too, so run\n`./build.sh
  --fast` to build the library without optimization. This is useful\nfor development.\n\nIn
  the future, it would be great to not have to include the auto-generated code\nin
  git.\n\nAlso, there is a file called `scraper.py` that scrapes a given CloudFormation\nresource
  documentation page to produce the JSON model. It isn't perfect, but it\nhelps a
  lot.\n\n## Contributing\n\nFeel free to raise any issues, or even just make suggestions,
  by filing a\nGithub issue.\n\n## Future Work\n\nThe library is usable in its current
  state and it is already much more\nenjoyable to work with than writing JSON templates
  by hand, but there are of\ncourse a few possible future improvements:\n\n* Not all
  resources implemented. Adding resources is very easy though. Just\n  request them
  and I will implement them :)\n* Implement basic checker for things like undefined
  Refs and duplicate field\n  names. This stuff would be too unwieldy to do in types,
  and performing a\n  checking pass over a template should be pretty straightforward.\n*
  Use a custom JSON encoder so the templates look a little more idiomatic. We\n  also
  create a lot of empty whitespace and newlines using aeson-pretty. There\n  are limits
  on the size of CloudFormation templates, and we want readable\n  output without
  hitting the limits. Also, we have some newtypes that just\n  exist to override aeson
  instances, and we could get rid of those.\n* Use a custom JSON decoder with useful
  error messages. Although we don't use\n  them, we have implemented FromJSON instances
  for everything. Theoretically,\n  stratosphere could be used as a checker/linter
  for existing JSON\n  CloudFormation templates.\n"
license-name: MIT
