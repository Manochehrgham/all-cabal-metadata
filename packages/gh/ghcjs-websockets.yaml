changelog-type: ''
hash: 7f117485b450530ac8ba943b253535eba0154165148990ecb52b6018206f400d
synopsis: GHCJS interface for the Javascript Websocket API
changelog: ''
all-versions:
- '0.3.0.0'
- '0.3.0.1'
- '0.3.0.2'
latest: '0.3.0.2'
description-type: haddock
description: ! 'Documentation online at

  <http://mstksg.github.io/ghcjs-websockets/JavaScript-WebSockets.html>


  ''ghcjs-websockets'' aims to provide a clean, idiomatic,

  efficient, low-level, out-of-your-way, bare bones,

  concurrency-aware interface with minimal abstractions

  over the Javascript Websockets API

  <http://www.w3.org/TR/websockets/>,

  inspired by common Haskell idioms found in libraries like

  ''io-stream''

  <http://hackage.haskell.org/package/io-streams> and the

  server-side ''websockets''

  <http://hackage.haskell.org/package/websockets> library,

  targeting compilation to Javascript with ''ghcjs''.


  The interface asbtracts websockets as simple IO/file

  handles, with additional access to the natively "typed"

  (text vs binary) nature of the Javascript Websockets API.

  There are also convenience functions to directly decode

  serialized data (serialized with ''binary''

  <http://hackage.haskell.org/package/binary>) sent through

  channels.


  The library is mostly intended to be a low-level FFI

  library, with the hopes that other, more advanced

  libraries maybe build on the low-level FFI bindings in

  order to provide more advanced and powerful abstractions.

  Most design decisions were made with the intent of

  keeping things as simple as possible in order for future

  libraries to abstract over it.


  Most of the necessary functionality is in hopefully in

  ''JavaScript.WebSockets''; more of the low-level API is

  exposed in ''JavaScript.WebSockets.Internal'' if you need

  it for library construction.


  See the ''JavaScript.WebSockets'' module for detailed usage

  instructions and examples.


  Some examples:


  > import Data.Text (unpack)

  >

  > -- A simple echo client, echoing all incoming text data

  > main :: IO ()

  > main = withUrl "ws://my-server.com" $ \conn ->

  >     forever $ do

  >         t <- receiveText conn

  >         putStrLn (unpack t)

  >         sendText conn t


  > -- A simple client waiting for connections and outputting the running sum

  > main :: IO ()

  > main = withUrl "ws://my-server.com" (runningSum 0)

  >

  > runningSum :: Int -> Connection -> IO ()

  > runningSum n conn = do

  >     i <- receiveData conn

  >     print (n + i)

  >     runningSum (n + i) conn


  > -- Act as a relay between two servers

  > main :: IO ()

  > main = do

  >     conn1 <- openConnection "ws://server-1.com"

  >     conn2 <- openConnection "ws://server-2.com"

  >     forever $ do

  >         msg <- receiveMessage conn1

  >         sendMessage conn2 msg

  >     closeConnection conn2

  >     closeConnection conn1'
