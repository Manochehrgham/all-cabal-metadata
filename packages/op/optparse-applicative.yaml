changelog-type: markdown
hash: 9886545336d1e9040aac7ee073806465e4c21b4711ef866de65ed2dae2430fa4
test-bench-deps: {}
synopsis: Utilities and combinators for parsing command line options
changelog: ! "## Version 0.11.0.2 (17 Feb 2015)\n\n- Updated dependency bounds.\n\n##
  Version 0.11.0.1 (5 Oct 2014)\n\n- Updated documentation.\n\n## Version 0.11.0 (4
  Oct 2014)\n\n- Added Alternative instances for `Chunk` and `ReadM`.\n\n- The `ReadM`
  monad is now a `ReaderT` for the argument being parsed.  User\n  defined readers
  do not need to handle their argument explicitly, but can\n  always access it using
  `readerAsk`.\n\n- Argument builders now take a `ReadM` parameter, just like options.\n\n-
  Fixed bugs\n    * \\#106 - argument should perhaps use `ReadM`\n\n## Version 0.10.0
  (1 Sep 2014)\n\n- Parser execution and help text generation are now more modular,
  and allow for\n  greater customisation.\n\n- More consistent API for `option` and
  `argument` builders: now `option` takes\n  a reader as argument, and `nullOption`
  is deprecated in favour of `option`.\n  The `reader` modifier is gone.  Quick migration
  guide:\n\n    * `option` (without a `reader` modifier) => `option auto`\n    * `nullOption`
  (without a `reader` modifier) => `option disabled`\n    * `option`/`nullOption`
  (with a `reader r` modifier) => `option r`.\n\n- Added convenience builder `strArgument`,
  equivalent to `argument str`.\n\n- Removed functions deprecated from at least version
  0.8.0.\n\n- Switched test infrastructure to `tasty`.\n\n- Fixed bugs\n    * \\#63
  - Inconsistency between 'argument' and 'strOption' types\n\n## Version 0.9.1.1 (31
  Jul 2014)\n\n- Fixed bugs\n    * \\#97 - Version 0.9.1 fails test suite\n\n## Version
  0.9.1 (30 Jul 2014)\n\n- Documentation tweaks.\n\n- Added low-level function to
  handle parse results (pull request \\#94).\n\n- `ParserResult` now has a `Show`
  instance (see issue \\#95).\n\n- Fixed bugs\n    * \\#93 - Formatting problem for
  several sub-parsers\n\n## Version 0.9.0 (23 May 2014)\n\n- The option returned by
  `abortOption` is now visible by default.\n\n## Version 0.8.1 (5 May 2014)\n\n- Fixed
  bugs\n    * \\#74 - Missing newline\n\n## Version 0.8.0.1 (19 Mar 2014)\n\n- Fixed
  bugs\n    * \\#73 - Release 0.8.0 is broken\n\n## Version 0.8.0 (16 Mar 2014)\n\n-
  Help page formatting.  Added `columns` preference modifier,\n  which can be used
  to specify the number of columns in the output\n  terminal.\n\n- Deprecated `arguments`
  and `arguments1` builders. Using `many` and `some` on a\n  parser built using `argument`
  now returns a multiple argument parsers that\n  behaves correctly with respect to
  `--`.\n\n- Fixed bugs\n    * \\#60 - runParser can't be called\n    * \\#64 - --help
  behaviour\n\n## Version 0.7.0.2 (18 Oct 2013)\n\n- Fixed bugs\n    * \\#51 - Build
  fails with ghc 6.12.3 and ghc 7.0.4\n\n## Version 0.7.0.1 (18 Oct 2013)\n\n- Minor
  docs fixes\n\n## Version 0.7.0 (17 Oct 2013)\n\n- Added builders for options that
  always fail. This makes it\n  easier to create options that just print an error
  message or\n  display some brief information and then exit (like `--version`).\n\n-
  Added `execParserMaybe` and `customExecParserMaybe` functions\n  (pull request #49).\n\n-
  Fixed bugs\n    * \\#47 - Current master prints help text instead of error\n    *
  \\#48 - Can we have an eitherReader convenience function?\n    * \\#50 - In order
  parsing problems.\n    * \\#22 - Strict (no-intersperse) arguments\n\n## Version
  0.6.0 (11 Oct 2013)\n\n- Arguments are now always parsed in order.\n\n- Fixed bugs\n
  \   * \\#40 - Add context information to error messages\n    * \\#41 - Readme uses
  old reader API\n    * \\#38 - Internal types leaking into public API\n    * \\#44
  - Can the build input restriction process == 1.1.* be relaxed?\n    * \\#28 - Help
  for subcommands\n\n## Version 0.5.2.1 (24 Dic 2012)\n\n- Minor docs fixes.\n\n##
  Version 0.5.2 (23 Dic 2012)\n\n- Fixed compatibility with GHC 7.2.\n\n## Version
  0.5.1 (23 Dic 2012)\n\n- There is a new parser preference `noBacktrack`, that controls
  whether how a\n  failure in a subparser is propagated. By default, an unknown option
  in a\n  subparser causes the option to be looked up in parent parsers. When\n  `noBacktrack`
  is used, this behavior is disabled. This is useful to implement\n  subcommands that
  have no relations with their parent commands.\n\n- Fixed bugs\n    * \\#35 - Artifacts
  of \"hidden\"\n    * \\#31 - Backtracking on commands\n    * \\#25 - Allow for using
  Maybe in options types to specify optional arguments\n    * \\#34 - No simple/obvious
  way to add a --version switch\n    * \\#29 - Document Mod\n    * \\#26 - Improve
  docs for the `Arrow` interface\n\n## Version 0.5.0 (22 Dic 2012)\n\n- Fewer GHC
  extensions required.\n\n- Improved error handling: unrecognized options now result
  in an error message.\n\n- By default, the full help text is not displayed on parse
  errors anymore.\n  This behavior can be controlled with the `prefShowHelpOnError`
  field of\n  `ParserPrefs`.\n\n- The `(&)` operator is now deprecated. Modifiers
  can still be combined using\n  `(<>)` or `mappend`.\n\n- Fixed bugs\n    * \\#37
  - Use (\\<\\>) instead of (&) in documentation\n\n## Version 0.4.3 (09 Dic 2012)\n\n-
  Updated dependency bounds.\n\n## Version 0.4.2 (26 Nov 2012)\n\n- Fixed bugs\n    *
  \\#27 - Please include the test source files in the cabal sdist tarball\n\n## Version
  0.4.1 (04 Sep 2012)\n\n- Fixed bugs\n    * \\#19 - Regression\n\n## Version 0.4.0
  (05 Aug 2012)\n\n- Brief help text for nested commands now shows the full command
  line.\n\n- Fixed inefficiency in the `arguments` parsers for long argument lists.\n\n-
  Added automatic [bash\ncompletion](https://github.com/pcapriotti/optparse-applicative/wiki/Bash-Completion).\n\n-
  Added `disambiguate` modifier for `prefs`, which enabled automatic\ndisambiguation
  of option abbreviations. With disambiguation on, a command line\nlike:\n\n        foo
  --out\n\n    will match an option called `--output`, as long as its the only one
  starting\n    with the string `out`.\n\n- Added `briefDesc` modifier.\n\n- Fixed
  bugs\n    * \\#8 - Long options not disambiguated\n    * \\#10 - Shell completions\n
  \   * \\#16 - Possible memory leak?\n\n## Version 0.3.2 (31 Jul 2012)\n\n- Fixed
  bug where both branches of an alternative could be matched.\n\n- Improved brief
  help text for alternatives.\n\n## Version 0.3.1 (30 Jul 2012)\n\n- Added new `showDefault`
  and `showDefaultWith` modifiers, which will result in\nthe default value (if present)
  to be displayed in the help text.\n\n- Fixed bugs\n    * \\#12 - Optionally display
  default values in help\n\n## Version 0.3.0 (30 Jul 2012)\n\n- Option modifiers are
  now instances of `Monoid` instead of `Category`.\n\n- Dropped dependencies on data-default
  and data-lens.\n\n- Fixed bugs\n    * \\#14 - \"arguments\" can no longer take a
  list as a default\n\n## Version 0.2.0 (23 Jul 2012)\n\n- Parser is now an instance
  of Alternative. This makes it possible to build\ncertain complex parsers that were
  not definable before. See\n`tests/Examples/Alternatives.hs` for a simple example.\n\n-
  Removed `multi` modifier. You can now use the `many` or `some` methods from\n`Alternative`,
  instead, to create parsers for options that can appear more than\nonce.\n\n- Added
  new `flag'` builder that returns a flag without a default value.\nAlthough flags
  without default values were not useful before, with the addition\nof `Alternative`
  combinators, they do have valid use cases.\n\n- Added new `internal` modifier for
  options. An internal option is completely\ninvisible in the help text.\n\n- Added
  a new `customExecParser` function, which takes an additional\n`ParserPrefs` parameter.
  At the moment, `ParserPrefs` can only be used to\ncontrol how many-valued option
  metavars are displayed in the help text. Setting\nits `multiSuffix` field to e.g.
  `...` will result in an `arguments` parser\ndescription like `[METAVAR]...`.\n\n-
  Fixed bugs\n    * \\#6 - \"arguments\" swallows options\n    * \\#5 - Help formatting
  for \"arguments\" misleading\n\n## Version 0.1.1 (21 Jul 2012)\n\n- New arrow interface\n\n-
  Fixed bugs\n      * \\#7 - \"arguments\" reads positional arguments in reverse\n\n##
  Version 0.1.0 (07 Jul 2012)\n\n- Improved error reporting internals\n\n- Removed
  template-haskell dependency\n\n- Fixed bugs:\n      * \\#3 - No help for subparsers\n
  \     * \\#4 - Extra empty lines around command list\n\n## Version 0.0.1 (09 Jun
  2012)\n\n- Initial release.\n"
basic-deps:
  ansi-wl-pprint: ! '>=0.6 && <0.7'
  base: ==4.*
  process: ! '>=1.0 && <1.3'
  transformers: ! '>=0.2 && <0.5'
  transformers-compat: ! '>=0.3 && <0.5'
all-versions:
- '0.0.1'
- '0.1.0'
- '0.1.1'
- '0.2.0'
- '0.3.0'
- '0.3.1'
- '0.3.2'
- '0.4.0'
- '0.4.1'
- '0.4.2'
- '0.4.3'
- '0.5.0'
- '0.5.1'
- '0.5.2'
- '0.5.2.1'
- '0.6.0'
- '0.7.0'
- '0.7.0.1'
- '0.7.0.2'
- '0.8.0'
- '0.8.0.1'
- '0.8.1'
- '0.9.0'
- '0.9.1'
- '0.9.1.1'
- '0.10.0'
- '0.11.0'
- '0.11.0.1'
- '0.11.0.2'
latest: '0.11.0.2'
description-type: markdown
description: ! "# Applicative option parser\n\nThis package contains utilities and
  combinators to define command line option\nparsers.\n\n[![Continuous Integration
  status][status-png]][status]\n[![Hackage page (downloads and API reference)][hackage-png]][hackage]\n\n**Table
  of Contents**\n\n- [Getting started](#getting-started)\n- [Supported options](#supported-options)\n
  \   - [Regular options](#regular-options)\n    - [Flags](#flags)\n    - [Arguments](#arguments)\n
  \   - [Commands](#commands)\n- [Option builders](#option-builders)\n- [Advanced
  features](#advanced-features)\n- [How it works](#how-it-works)\n\n## Getting started\n\nInstall
  with\n\n```sh\ncabal install optparse-applicative\n```\n\nHere is a simple example
  of an applicative option parser:\n\n```haskell\nimport Options.Applicative\n\ndata
  Sample = Sample\n  { hello :: String\n  , quiet :: Bool }\n\nsample :: Parser Sample\nsample
  = Sample\n     <$> strOption\n         ( long \"hello\"\n        <> metavar \"TARGET\"\n
  \       <> help \"Target for the greeting\" )\n     <*> switch\n         ( long
  \"quiet\"\n        <> help \"Whether to be quiet\" )\n```\n\nThe parser is built
  using [applicative style][applicative] starting from a set\nof basic combinators.
  In this example, `hello` is defined as an option with a\n`String` argument, while
  `quiet` is a boolean flag (called `switch`).\n\nA parser can be used like this:\n\n```haskell\ngreet
  :: Sample -> IO ()\ngreet (Sample h False) = putStrLn $ \"Hello, \" ++ h\ngreet
  _ = return ()\n\nmain :: IO ()\nmain = execParser opts >>= greet\n  where\n    opts
  = info (helper <*> sample)\n      ( fullDesc\n     <> progDesc \"Print a greeting
  for TARGET\"\n     <> header \"hello - a test for optparse-applicative\" )\n```\n\nThe
  `greet` function is the entry point of the program, while `opts` is a\ncomplete
  description of the program, used when generating a help text. The\n`helper` combinator
  takes any parser, and adds a `help` option to it.\n\nThe `hello` option in this
  example is mandatory (since it doesn't have a\ndefault value), so running the program
  without any argument will display a\nshort option summary:\n\n    Usage: hello --hello
  TARGET [--quiet]\n\nRunning the program with the `--help` option will display the
  full help text:\n\n    hello - a test for optparse-applicative\n\n    Usage: hello
  --hello TARGET [--quiet]\n      Print a greeting for TARGET\n\n    Available options:\n
  \     -h,--help                Show this help text\n      --hello TARGET           Target
  for the greeting\n      --quiet                  Whether to be quiet\n\ncontaining
  a detailed list of options with descriptions.\n\nThe specified metavars are used
  as placeholders for the option arguments, and\ncan be referred to in the program
  description.  This makes it possible to\nexplicitly describe the connection between
  the options and the behaviour of the\nprogram.\n\nParsers are instances of both
  `Applicative` and `Alternative`, and work with\nany generic combinator, like `many`
  and `some`. For example, to make a option\nreturn `Nothing` instead of failing when
  it's not supplied, you can use the\n`optional` combinator in `Control.Applicative`:\n\n```haskell\noptional
  $ strOption\n   ( long \"output\"\n  <> metavar \"DIRECTORY\" )\n```\n\n [applicative]:
  http://www.soi.city.ac.uk/~ross/papers/Applicative.html\n\n## Supported options\n\n`optparse-applicative`
  supports four kinds of options: regular options, flags,\narguments and commands.\n\n###
  Regular options\n\nA **regular option** is an option which takes a single argument,
  parses it, and\nreturns a value.\n\nA regular option can have a default value, which
  is used as the result if the\noption is not found in the command line. An option
  without a default value is\nconsidered mandatory, and produces an error when not
  found.\n\nRegular options can have **long** names, or **short** (one-character)
  names,\nwhich determine when the option matches and how the argument is extracted.\n\nAn
  option with a long name (say \"output\") is specified on the command line as\n\n
  \   --output filename.txt\n\nor\n\n    --output=filename.txt\n\nwhile a short name
  option (say \"o\") can be specified with\n\n    -o filename.txt\n\nor\n\n    -ofilename.txt\n\nOptions
  can have more than one name, usually one long and one short, although\nyou are free
  to create options with an arbitrary combination of long and short\nnames.\n\nRegular
  options returning strings are the most common, and they can be created\nusing the
  `strOption` builder. For example,\n\n```haskell\nstrOption\n   ( long \"output\"\n
  \ <> short 'o'\n  <> metavar \"FILE\"\n  <> help \"Write output to FILE\" )\n```\n\ncreates
  a regular option with a string argument (which can be referred to as\n`FILE` in
  the help text and documentation), a long name \"output\" and a short\nname \"o\".
  See below for more information on the builder syntax and modifiers.\n\nA regular
  option can return an object of any type, and takes a *reader*\nparameter which specifies
  how the argument should be parsed.  A common reader is\n`auto`, which assumes a
  `Read` instance for the return type and uses it to parse\nits argument. For example:\n\n```haskell\nlineCount
  :: Parser Int\nlineCount = option auto\n            ( long \"lines\"\n           <>
  short 'n'\n           <> metavar \"K\"\n           <> help \"Output the last K lines\"
  )\n```\n\nspecifies a regular option with an `Int` argument. We added an explicit
  type\nannotation here, since without it the parser would have been polymorphic in
  the\noutput type. There's usually no need to add type annotations, however, because\nthe
  type will be normally inferred from the context in which the parser is\nused.\n\nYou
  can also create a custom reader that doesn't use the `Read` typeclass, and\nuse
  it to parse option arguments.  A custom reader is a value in the `ReadM`\nmonad.\n\n```haskell\ndata
  FluxCapacitor = ...\n\nparseFluxCapacitor :: Monad m => String -> m FluxCapacitor\n\noption
  (str >>= parseFluxCapacitor)\n  ( long \"flux-capacitor\" )\n```\n\nUse `readerAbort`
  or `readerError` within the `ReadM` monad to exit with an\nerror message.\n\n###
  Flags\n\nA **flag** is just like a regular option, but it doesn't take any arguments:
  it is\neither present in the command line or not.\n\nA flag has a default value
  and an **active value**. If the flag is found on the\ncommand line, the active value
  is returned, otherwise the default value is\nused. For example:\n\n```haskell\ndata
  Verbosity = Normal | Verbose\n\nflag Normal Verbose\n  ( long \"verbose\"\n <> short
  'v'\n <> help \"Enable verbose mode\" )\n```\n\nis a flag parser returning a `Verbosity`
  value.\n\nSimple boolean flags can be specified using the `switch` builder, like
  so:\n\n```haskell\nswitch\n  ( long \"keep-tmp-files\"\n <> help \"Retain all intermediate
  temporary files\" )\n```\n\nThere is also a `flag'` builder, which has no default
  value. For example, to\nadd a `--version` switch to a program, you could write:\n\n```haskell\nflag'
  Nothing (long \"version\" <> hidden) <|> (Just <$> normal_options)\n```\n\n### Arguments\n\nAn
  **argument** parser specifies a positional command line argument.\n\nThe `argument`
  builder takes a reader parameter, and creates a parser which\nwill return the parsed
  value every time it is passed a command line argument\nfor which the reader succeeds.
  For example\n\n```haskell\nargument str (metavar \"FILE\")\n```\n\ncreates an argument
  accepting any string.  To accept an arbitrary number of\narguments, combine the
  `argument` builder with either the `many` or `some`\ncombinator:\n\n```haskell\nsome
  (argument str (metavar \"FILES...\"))\n```\n\nArguments are only displayed in the
  brief help text, so there's no need to\nattach a description to them. They should
  be manually documented in the program\ndescription.\n\nNote that arguments starting
  with `-` are considered options by default, and\nwill not be considered by an `argument`
  parser.\n\nHowever, parsers always accept a special argument: `--`. When a `--`
  is found on\nthe command line, all the following words are considered by `argument`
  parsers,\nregardless of whether they start with `-` or not.\n\n### Commands\n\nA
  **command** can be used to specify a sub-parser to be used when a certain\nstring
  is encountered in the command line.\n\nCommands are useful to implement command
  line programs with multiple functions,\neach with its own set of options, and possibly
  some global options that apply\nto all of them. Typical examples are version control
  systems like `git`, or\nbuild tools like `cabal`.\n\nA command can be created using
  the `subparser` builder, and commands can be\nadded with the `command` modifier.
  For example\n\n```haskell\nsubparser\n  ( command \"add\" (info addOptions\n      (
  progDesc \"Add a file to the repository\" ))\n <> command \"commit\" (info commitOptions\n
  \     ( progDesc \"Record changes to the repository\" ))\n)\n```\n\nEach command
  takes a full `ParserInfo` structure, which will be used to extract\na description
  for this command when generating a help text.\n\nNote that all the parsers appearing
  in a command need to have the same type.\nFor this reason, it is often best to use
  a sum type which has the same\nstructure as the command itself. For example, for
  the parser above, you would\ndefine a type like:\n\n```haskell\ndata Options = Options\n
  \ { optGlobalOpt :: String\n  , optGlobalFlag :: Bool\n  ...\n  , optCommand ::
  Command }\n\ndata Command\n  = Add AddOptions\n  | Commit CommitOptions\n  ...\n```\n\nAlternatively,
  you can directly return an `IO` action from a parser, and\nexecute it using `join`
  from `Control.Monad`.\n\n```haskell\nstart :: String -> IO ()\nstop :: IO ()\n\nopts
  :: Parser (IO ())\nopts = subparser\n  ( command \"start\" (info (start <$> argument
  str idm) idm)\n <> command \"stop\"  (info (pure stop) idm) )\n\nmain :: IO ()\nmain
  = join $ execParser (info opts idm)\n```\n\n## Option builders\n\nBuilders allow
  you to define parsers using a convenient combinator-based\nsyntax. Each builder
  takes a **modifier** as parameter, and returns a parser.\n\nA modifier is a composition
  of functions which act on the option, setting\nvalues for properties or adding features,
  and is used to build the option from\nscratch and finally lift it to a single-option
  parser, which can then be\ncombined with other parsers using normal `Applicative`
  combinators.\n\nModifiers are instances of the `Monoid` typeclass, so they can be
  combined\nusing the composition function `mappend` (or simply `(<>)`).\n\nSee the
  [haddock documentation][builder-documentation] for `Options.Applicative.Builder`\nfor
  a full list of builders and modifiers.\n\n## Advanced features\n\n* [Bash completion]\n*
  [Arrow interface]\n* [Disambiguation]\n\n [Bash completion]: https://github.com/pcapriotti/optparse-applicative/wiki/Bash-Completion\n
  [Arrow interface]: https://github.com/pcapriotti/optparse-applicative/wiki/Arrows\n
  [Disambiguation]: https://github.com/pcapriotti/optparse-applicative/wiki/Disambiguation\n\n##
  How it works\n\nA `Parser a` is essentially a heterogeneous list of `Option`s, implemented
  with\nexistential types.\n\nAll options are therefore known statically (i.e. before
  parsing, not\nnecessarily before runtime), and can, for example, be traversed to
  generate a\nhelp text.\n\nSee [this blog post][blog] for a more detailed explanation
  based on a\nsimplified implementation.\n\n [status-png]: https://api.travis-ci.org/pcapriotti/optparse-applicative.svg\n
  [status]: http://travis-ci.org/pcapriotti/optparse-applicative?branch=master\n [blog]:
  http://paolocapriotti.com/blog/2012/04/27/applicative-option-parser/\n [builder-documentation]:
  http://hackage.haskell.org/package/optparse-applicative/docs/Options-Applicative-Builder.html\n
  [hackage-png]: http://img.shields.io/hackage/v/optparse-applicative.svg\n [hackage]:
  http://hackage.haskell.org/package/optparse-applicative\n"
