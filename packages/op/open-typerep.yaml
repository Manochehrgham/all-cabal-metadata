changelog-type: ''
hash: 78da667f17b9582b76715a8e7096e3177bd842200b3d3dfd4a430dd6f889ec15
synopsis: Open type representations and dynamic types
changelog: ''
all-versions:
- '0.1'
- '0.2'
- '0.3.1'
latest: '0.3.1'
description-type: haddock
description: ! 'This package uses Data Types Ã  la Carte to provide open type representations

  and dynamic types/coercions for open type universes.


  Example 1 (dynamic types):


  > type MyUniverse = IntType :+: BoolType

  >

  > hlist :: [Dynamic MyUniverse]

  > hlist = [toDyn True, toDyn (1 :: Int)]


  > *Main> hlist

  > [True,1]


  Note that if we were using "Data.Dynamic", it would just print


  > [<<Bool>>,<<Int>>]


  Example 2 (dynamically typed addition):


  > addDyn :: (TypeEq ts ts, PWitness Num ts ts) => Dynamic ts -> Dynamic ts -> Maybe
  (Dynamic ts)

  > addDyn (Dyn ta a) (Dyn tb b) = do

  >     Dict <- typeEq ta tb

  >     Dict <- pwit pNum ta

  >     return (Dyn ta (a+b))


  "Data.Dynamic" could only do this monomorphically, for one ''Num'' type at a

  time.'
