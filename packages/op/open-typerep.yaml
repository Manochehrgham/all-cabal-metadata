changelog-type: ''
hash: 3edb3f527dd7a23f680d69c594bc88b4c2fbbf2c87749f36d5d316531bc52299
test-bench-deps:
  base: -any
  criterion: ! '>=1'
  open-typerep: -any
synopsis: Open type representations and dynamic types
changelog: ''
basic-deps:
  base: ! '>=4 && <5'
  constraints: ! '>=0.3'
  tagged: ! '>=0.4'
  syntactic: ! '>=2.0'
  mtl: ! '>=2.1'
all-versions:
- '0.1'
- '0.2'
- '0.3.1'
latest: '0.3.1'
description-type: haddock
description: ! 'This package uses Data Types Ã  la Carte to provide open type representations

  and dynamic types/coercions for open type universes.


  Example 1 (dynamic types):


  > type MyUniverse = IntType :+: BoolType

  >

  > hlist :: [Dynamic MyUniverse]

  > hlist = [toDyn True, toDyn (1 :: Int)]


  > *Main> hlist

  > [True,1]


  Note that if we were using "Data.Dynamic", it would just print


  > [<<Bool>>,<<Int>>]


  Example 2 (dynamically typed addition):


  > addDyn :: (TypeEq ts ts, PWitness Num ts ts) => Dynamic ts -> Dynamic ts -> Maybe
  (Dynamic ts)

  > addDyn (Dyn ta a) (Dyn tb b) = do

  >     Dict <- typeEq ta tb

  >     Dict <- pwit pNum ta

  >     return (Dyn ta (a+b))


  "Data.Dynamic" could only do this monomorphically, for one ''Num'' type at a

  time.'
