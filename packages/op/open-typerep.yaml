homepage: https://github.com/emilaxelsson/open-typerep
changelog-type: ''
hash: 05d81ac2af776e77e316192580af804f190ba685d3693c020e22ee1fab79b687
test-bench-deps:
  base: -any
  criterion: ! '>=1'
  syntactic: -any
  open-typerep: -any
maintainer: emax@chalmers.se
synopsis: Open type representations and dynamic types
changelog: ''
basic-deps:
  base: ! '>=4 && <5'
  constraints: ! '>=0.3'
  base-orphans: -any
  tagged: ! '>=0.4'
  syntactic: ! '>=3.2'
  mtl: ! '>=2.2.1'
  template-haskell: -any
all-versions:
- '0.1'
- '0.2'
- '0.3.1'
- '0.3.2'
- '0.3.3'
- '0.4'
author: Emil Axelsson
latest: '0.4'
description-type: haddock
description: ! 'This package uses Data Types Ã  la Carte to provide open type representations

  and dynamic types/coercions for open type universes.


  Example 1 (dynamic types):


  > type MyUniverse = IntType :+: BoolType

  >

  > hlist :: [Dynamic MyUniverse]

  > hlist = [toDyn True, toDyn (1 :: Int)]


  > *Main> hlist

  > [True,1]


  Note that if we were using "Data.Dynamic", it would just print


  > [<<Bool>>,<<Int>>]


  Example 2 (dynamically typed addition):


  > addDyn :: (TypeEq ts ts, PWitness Num ts ts) => Dynamic ts -> Dynamic ts -> Maybe
  (Dynamic ts)

  > addDyn (Dyn ta a) (Dyn tb b) = do

  >     Dict <- typeEq ta tb

  >     Dict <- pwit pNum ta

  >     return (Dyn ta (a+b))


  "Data.Dynamic" could only do this monomorphically, for one ''Num'' type at a

  time.'
license-name: BSD3
