homepage: https://github.com/ndmitchell/weeder#readme
changelog-type: text
hash: cafe4b9b1164a8524746285314b542cb333a326bee860565a1c72e59f5179746
test-bench-deps: {}
maintainer: Neil Mitchell <ndmitchell@gmail.com>
synopsis: Detect dead code
changelog: ! "Changelog for Weeder\n\n0.1.4\n    #9, allow --dist-dir to set the stack
  dist-dir\n    Deal with operators including | in them\n    Allow arrays of arrays
  of strings in the .weeder.yaml\n0.1.3\n    #5, document how to install weeder\n
  \   #8, detect unused imports, even import Foo()\n    #7, don't say modules with
  only instances are always redundant\n    #6, don't give partial pattern matches
  when reading .weeder.yaml\n0.1.2\n    #3, deal with space-separated hs-source-dirs\n0.1.1\n
  \   #2, use \"stack query\" rather than parsing stack.yaml\n0.1\n    Initial version\n"
basic-deps:
  bytestring: -any
  extra: -any
  base: ! '>=4.6 && <5'
  unordered-containers: -any
  text: -any
  filepath: -any
  process: ! '>=1.2.3.0'
  cmdargs: -any
  hashable: -any
  aeson: -any
  yaml: -any
  vector: -any
all-versions:
- '0.1'
- '0.1.1'
- '0.1.2'
- '0.1.3'
- '0.1.4'
author: Neil Mitchell <ndmitchell@gmail.com>
latest: '0.1.4'
description-type: markdown
description: ! "# Weeder [![Hackage version](https://img.shields.io/hackage/v/weeder.svg?label=Hackage)](https://hackage.haskell.org/package/weeder)
  [![Stackage version](https://www.stackage.org/package/weeder/badge/lts?label=Stackage)](https://www.stackage.org/package/weeder)
  [![Linux Build Status](https://img.shields.io/travis/ndmitchell/weeder.svg?label=Linux%20build)](https://travis-ci.org/ndmitchell/weeder)
  [![Windows Build Status](https://img.shields.io/appveyor/ci/ndmitchell/weeder.svg?label=Windows%20build)](https://ci.appveyor.com/project/ndmitchell/weeder)\n\nThe
  principle is to delete dead code (pulling up the weeds). To do that, run:\n\n* GHC
  with `-fwarn-unused-binds -fwarn-unused-imports`, which finds unused definitions
  and unused imports in a module.\n* [HLint](https://github.com/ndmitchell/hlint#readme),
  looking for \"Redundant extension\" hints, which finds unused extensions.\n* The
  `weeder` tool, which detects functions that are exported internally but not available
  from outside this package. It also detects redundancies and missing information
  in your `.cabal` file.\n\n## Running Weeder\n\nWeeder piggy-backs off files generated
  by [`stack`](https://www.haskellstack.org), so first obtain stack, then:\n\n* Install
  `weeder` by running `stack install weeder --resolver=nightly`.\n* Ensure your project
  has a `stack.yaml` file. If you don't normally build with `stack` then run `stack
  init` to generate one.\n* Run `weeder . --build`, which builds your project with
  `stack` and checks it for weeds.\n\n## What does Weeder detect?\n\nWeeder detects
  a bunch of weeds, including:\n\n* You export a function `helper` from module `Foo.Bar`,
  but nothing else in your package uses `helper`, and `Foo.Bar` is not an `exposed-module`.
  Therefore, the export of `helper` is a weed. Note that `helper` itself may or may
  not be a weed - once it is no longer exported `-fwarn-unused-binds` will tell you
  if it is entirely redundant.\n* Your package `depends` on another package but doesn't
  use anything from it - the dependency should usually be deleted. This functionality
  is quite like [packunused](https://hackage.haskell.org/package/packunused), but
  implemented quite differently.\n* Your package has entries in the `other-modules`
  field that are either unused (and thus should be deleted), or are missing (and thus
  should be added). The `stack` tool warns about the latter already.\n* A source file
  is used between two different sections in a `.cabal` file - e.g. in both the library
  and the executable. Usually it's better to arrange for the executable to depend
  on the library, but sometimes that would unnecessarily pollute the interface. Useful
  to be aware of, and sometimes worth fixing, but not always.\n* A file has not been
  compiled despite being mentioned in the `.cabal` file. This situation can be because
  the file is unused, or the `stack` compilation was incomplete. I recommend compiling
  both benchmarks and tests to avoid this warning where possible - running `weeder
  . --build` will use a suitable command line.\n\nBeware of conditional compilation
  (e.g. `CPP` and the [Cabal `flag` mechanism](https://www.haskell.org/cabal/users-guide/developing-packages.html#configurations)),
  as these may mean that something is currently a weed, but in different configurations
  it is not.\n\nI recommend fixing the warnings relating to `other-modules` and files
  not being compiled first, as these may cause other warnings to disappear.\n\n##
  Ignoring weeds\n\nIf you want your package to be detected as \"weed free\", but
  it has some weeds you know about but don't consider important, you can add a `.weeder.yaml`
  file adjacent to the `stack.yaml` with a list of exclusions. To generate an initial
  list of exclusions run `weeder . --yaml > .weeder.yaml`.\n\nYou may wish to generalise/simplify
  the `.weeder.yaml` by removing anything above or below the interesting part. As
  an example of the [`.weeder.yaml` file from `ghcid`](https://github.com/ndmitchell/ghcid/blob/master/.weeder.yaml):\n\n```yaml\n-
  message: Module reused between components\n- message:\n  - name: Weeds exported\n
  \ - identifier: withWaiterPoll\n```\n\nThis configuration declares that I am not
  interested in the message about modules being reused between components (that's
  the way `ghcid` works, and I am aware of it). It also says that I am not concerned
  about `withWaiterPoll` being a weed - it's a simplified method of file change detection
  I use for debugging, so even though it's dead now, I sometimes do switch to it.\n"
license-name: BSD3
