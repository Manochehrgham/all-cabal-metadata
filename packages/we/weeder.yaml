homepage: https://github.com/ndmitchell/weeder#readme
changelog-type: text
hash: ee6159e1f33a341ab201c50eb6cb23571e51029579c16c8ec54a441226834957
test-bench-deps: {}
maintainer: Neil Mitchell <ndmitchell@gmail.com>
synopsis: Detect dead code
changelog: ! "Changelog for Weeder\n\n0.1.6\n    #10, find files generated by alex/happy\n0.1.5\n
  \   If --yaml and no hints give no output\n0.1.4\n    #9, allow --dist-dir to set
  the stack dist-dir\n    Deal with operators including | in them\n    Allow arrays
  of arrays of strings in the .weeder.yaml\n0.1.3\n    #5, document how to install
  weeder\n    #8, detect unused imports, even import Foo()\n    #7, don't say modules
  with only instances are always redundant\n    #6, don't give partial pattern matches
  when reading .weeder.yaml\n0.1.2\n    #3, deal with space-separated hs-source-dirs\n0.1.1\n
  \   #2, use \"stack query\" rather than parsing stack.yaml\n0.1\n    Initial version\n"
basic-deps:
  bytestring: -any
  extra: -any
  base: ! '>=4.6 && <5'
  unordered-containers: -any
  text: -any
  filepath: -any
  process: ! '>=1.2.3.0'
  cmdargs: -any
  hashable: -any
  aeson: -any
  yaml: -any
  vector: -any
all-versions:
- '0.1'
- '0.1.1'
- '0.1.2'
- '0.1.3'
- '0.1.4'
- '0.1.5'
- '0.1.6'
author: Neil Mitchell <ndmitchell@gmail.com>
latest: '0.1.6'
description-type: markdown
description: ! "# Weeder [![Hackage version](https://img.shields.io/hackage/v/weeder.svg?label=Hackage)](https://hackage.haskell.org/package/weeder)
  [![Stackage version](https://www.stackage.org/package/weeder/badge/lts?label=Stackage)](https://www.stackage.org/package/weeder)
  [![Linux Build Status](https://img.shields.io/travis/ndmitchell/weeder.svg?label=Linux%20build)](https://travis-ci.org/ndmitchell/weeder)
  [![Windows Build Status](https://img.shields.io/appveyor/ci/ndmitchell/weeder.svg?label=Windows%20build)](https://ci.appveyor.com/project/ndmitchell/weeder)\n\nThe
  principle is to delete dead code (pulling up the weeds). To do that, run:\n\n* GHC
  with `-fwarn-unused-binds -fwarn-unused-imports`, which finds unused definitions
  and unused imports in a module.\n* [HLint](https://github.com/ndmitchell/hlint#readme),
  looking for \"Redundant extension\" hints, which finds unused extensions.\n* The
  `weeder` tool, which detects functions that are exported internally but not available
  from outside this package. It also detects redundancies and missing information
  in your `.cabal` file.\n\n## Running Weeder locally\n\nWeeder piggy-backs off files
  generated by [`stack`](https://www.haskellstack.org), so first obtain stack, then:\n\n*
  Install `weeder` by running `stack install weeder --resolver=nightly`.\n* Ensure
  your project has a `stack.yaml` file. If you don't normally build with `stack` then
  run `stack init` to generate one.\n* Run `weeder . --build`, which builds your project
  with `stack` and checks it for weeds.\n\n## What does Weeder detect?\n\nWeeder detects
  a bunch of weeds, including:\n\n* You export a function `helper` from module `Foo.Bar`,
  but nothing else in your package uses `helper`, and `Foo.Bar` is not an `exposed-module`.
  Therefore, the export of `helper` is a weed. Note that `helper` itself may or may
  not be a weed - once it is no longer exported `-fwarn-unused-binds` will tell you
  if it is entirely redundant.\n* Your package `depends` on another package but doesn't
  use anything from it - the dependency should usually be deleted. This functionality
  is quite like [packunused](https://hackage.haskell.org/package/packunused), but
  implemented quite differently.\n* Your package has entries in the `other-modules`
  field that are either unused (and thus should be deleted), or are missing (and thus
  should be added). The `stack` tool warns about the latter already.\n* A source file
  is used between two different sections in a `.cabal` file - e.g. in both the library
  and the executable. Usually it's better to arrange for the executable to depend
  on the library, but sometimes that would unnecessarily pollute the interface. Useful
  to be aware of, and sometimes worth fixing, but not always.\n* A file has not been
  compiled despite being mentioned in the `.cabal` file. This situation can be because
  the file is unused, or the `stack` compilation was incomplete. I recommend compiling
  both benchmarks and tests to avoid this warning where possible - running `weeder
  . --build` will use a suitable command line.\n\nBeware of conditional compilation
  (e.g. `CPP` and the [Cabal `flag` mechanism](https://www.haskell.org/cabal/users-guide/developing-packages.html#configurations)),
  as these may mean that something is currently a weed, but in different configurations
  it is not.\n\nI recommend fixing the warnings relating to `other-modules` and files
  not being compiled first, as these may cause other warnings to disappear.\n\n##
  Ignoring weeds\n\nIf you want your package to be detected as \"weed free\", but
  it has some weeds you know about but don't consider important, you can add a `.weeder.yaml`
  file adjacent to the `stack.yaml` with a list of exclusions. To generate an initial
  list of exclusions run `weeder . --yaml > .weeder.yaml`.\n\nYou may wish to generalise/simplify
  the `.weeder.yaml` by removing anything above or below the interesting part. As
  an example of the [`.weeder.yaml` file from `ghcid`](https://github.com/ndmitchell/ghcid/blob/master/.weeder.yaml):\n\n```yaml\n-
  message: Module reused between components\n- message:\n  - name: Weeds exported\n
  \ - identifier: withWaiterPoll\n```\n\nThis configuration declares that I am not
  interested in the message about modules being reused between components (that's
  the way `ghcid` works, and I am aware of it). It also says that I am not concerned
  about `withWaiterPoll` being a weed - it's a simplified method of file change detection
  I use for debugging, so even though it's dead now, I sometimes do switch to it.\n\n##
  Running with Continuous Integration\n\nBefore running Weeder on your continuous
  integration (CI) server, you should first ensure there are no existing weeds. One
  way to achieve that is to ignore existing hints by running `weeder . --yaml > .weeder.yaml`
  and checking in the resulting `.weeder.yaml`.\n\nOn the CI you should then run `weeder
  .` (or `weeder . --build` to compile as well). To avoid the cost of compilation
  you may wish to fetch the [latest Weeder binary release](https://github.com/ndmitchell/weeder/releases/latest).
  For certain CI environments there are helper scripts to do that.\n\n**Travis:**
  Execute the following command:\n\n    curl -sL https://raw.github.com/ndmitchell/weeder/master/misc/travis.sh
  | sh -s .\n\nThe arguments after `-s` are passed to `weeder`, so modify the final
  `.` if you want other arguments.\n\n**Appveyor:** Add the following statement to
  `.appveyor.yml`:\n\n    - ps: Invoke-Command ([Scriptblock]::Create((Invoke-WebRequest
  'https://raw.githubusercontent.com/ndmitchell/weeder/master/misc/appveyor.ps1').Content))
  -ArgumentList @('.')\n\nThe arguments inside `@()` are passed to `weeder`, so add
  new arguments surrounded by `'`, space separated - e.g. `@('.' '--build')`.\n"
license-name: BSD3
