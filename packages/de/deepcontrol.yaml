homepage: https://github.com/ocean0yohsuke/deepcontrol
changelog-type: ''
hash: 2e1b061145df37481caeec74717b1eb3fe768cdcd390f70d73ea40f286ba97d4
test-bench-deps:
  base: -any
  deepcontrol: -any
  doctest: ! '>=0.9.3'
  HUnit: ! '>=1.3.0'
  containers: -any
  mtl: -any
  transformers: -any
  QuickCheck: ! '>=2.8.1'
  safe: -any
maintainer: ocean0yohsuke@gmail.com
synopsis: Enable more deeper level style of programming than the usual Control.xxx
  modules express
changelog: ''
basic-deps:
  base: ! '>=4.8 && <5'
  mtl: ! '>=2.2'
  mmorph: ! '>=1.0'
  transformers: ! '>=0.4'
all-versions:
- '0.1.0.0'
- '0.2.0.0'
- '0.3.0.0'
author: KONISHI Yohsuke
latest: '0.3.0.0'
description-type: markdown
description: ! "# deepcontrol\n\nA Haskell library that enables more deeper level
  style programming than the usual Control.xxx modules provide, especially for Applicative
  and Monad.\n\n## Installing with [Stack](https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md)\n\nIf
  you haven't installed Stack yet, install [Stack](https://github.com/commercialhaskell/stack#readme).\n\nIf
  you have never even used Stack, launch the terminal and go to your working directory:\n\n
  \   .../yourworkingdirectory$\n\nTo create your own Stack new project folder, type
  as below:\n\n    ../yourworkingdirectory$ stack new yourproject simple\n    Downloading
  template \"simple\" to create project \"yourproject\" in yourproject/ ...\n    ...\n\nGo
  into your project folder:\n\n    ../yourworkingdirectory$ cd yourproject/\n\nTo
  install GHC on your Stack project folder, type as below:\n\n    .../yourproject$
  stack setup\n    stack will use a locally installed GHC\n\nNow start ghci and see
  if it works well.\n\n    .../yourproject$ stack ghci\n    ...\n    Prelude>\n\n###
  Fetch from [Stackage](http://www.stackage.org/)\n\nAdd `deepcontrol` to your .cabal
  file:\n\nyourproject.cabal:\n\n      ...\n      build-depends:       ...\n                         ,
  deepcontrol\n\nOn your project folder run \"stack build\" to get Stack to install
  `deepcontrol` into your project.\n\n    .../yourproject$ stack build\n\nIf Stack
  yields a messeage below, it means that `deepcontrol` failed to be resolved on yourproject's
  Stack resolver.\nProbably you will get this message since `deepcontrol` is just
  one of miner libraries yet.\n\n    .../yourproject$ stack build\n    While constructing
  the BuildPlan the following exceptions were encountered:\n    ...\n\nIf you want
  to try other resolver, type as below:\n\n    .../yourproject$ stack init\n    Refusing
  to overwrite existing stack.yaml, please delete before running stack init or if
  you are sure use \"--force\"\n\nPlease follow the message direction.\n\n### Fetch
  from [Hackage](https://hackage.haskell.org/package/deepcontrol)\n\nOk, I(you) got
  `deepcontrol` isn't in Stackage. Then let's fetch `deepcontrol` from Hackage.\nAdd
  `deepcontrol-0.3.0.0` to your extra-deps field in stack.yaml too:\n\nstack.yaml:\n\n
  \   extra-deps:\n    ...\n    - deepcontrol-0.3.0.0\n\nAnd type as below:\n\n    .../yourproject$
  stack build\n\nStack must fetch and install `deepcontrol` automatically.\n\n    ../yourproject$
  stack build\n    deepcontrol-0.3.0.0: configure\n    ...\n\nNow start ghci and see
  if it works well.\n\n    .../yourproject$ stack ghci\n    ...\n    Prelude> :m DeepControl.Applicative\n\n##
  Installing with Cabal\n\n`deepcontrol` is available from\n[Hackage](https://hackage.haskell.org/package/deepcontrol).\n\nLaunch
  the terminal and go to your project folder:\n\n    .../yourproject$\n\nIf you haven't
  done setup cabal sandbox on your project folder yet, type as below so that `deepcontrol`
  will be installed locally on your project folder:\n\n    .../yourproject$ cabal
  sandbox init\n    Writing a default package environment file to\n    ...\n\nTo install
  `deepcontrol` on your project folder, type as below:\n\n    .../yourproject$ cabal
  update\n    Downloading the latest package list from hackage.haskell.org\n    ...\n
  \   .../yourproject$ cabal install deepcontrol\n    Resolving dependencies...\n
  \   ...\n\nNow start ghci and see if it works well.\n\n    .../yourproject$ cabal
  repl\n    ...\n\n    Prelude> :m DeepControl.Applicative\n\n## Examples\n\n### [Applicative](https://hackage.haskell.org/package/deepcontrol-0.3.0.0/docs/DeepControl-Applicative.html)\n\nThis
  module enables you to program in applicative style for more deeper level than the
  usual Applicative module expresses.\nYou would soon realize exactly what more deeper
  level means by reading the example codes below in order.\n\n    Prelude> :m DeepControl.Applicative\n\n####
  Level-0\n\nbra-ket notation:\n\n    > (1+) |> 2\n    3\n    > 1 <| (+2)\n    3\n\n
  \   > 1 <|(+)|> 2\n    3\n    > 1 <|(+)|> 2 <|(*)|> 3\n    9\n\n    > 1 <|(,)|>
  2\n    (1,2)\n\n#### Level-1\n\nbra-ket notation:\n\n    > (1+) |$> [2]\n    [3]\n
  \   > [1] <$| (+2)\n    [3]\n    > (\"<\"++)|$> [\"a\",\"b\"] <$|(++\">\")\n    [\"<a>\",\"<b>\"]\n\n
  \   > [(1+)] |*> [2]\n    [3]\n\n    > [1] <$|(+)|*> [2]\n    [3]\n    > [1] <$|(+)|*>
  [0,1,2]\n    [1,2,3]\n    > [0,1] <$|(+)|*> [2,3] <$|(+)|*> [4,5]\n    [6,7,7,8,7,8,8,9]\n\n
  \   > foldr (\\x acc -> x <$|(:)|*> acc) ((*:) []) [Just 1, Just 2,  Just 3]\n    Just
  [1,2,3]\n    > foldr (\\x acc -> x <$|(:)|*> acc) ((*:) []) [Just 1, Nothing, Just
  3]\n    Nothing\n\n    > filter (even <$|(&&)|*> (10 >)) [1..100]\n    [2,4,6,8]\n
  \   > filter (even <$|(&&)|*> (10 >) <$|(&&)|*> (5 <)) [1..100]\n    [6,8]\n\nbraket-cover
  notation\n\n    > [(1+)] |* 2\n    [3]\n    > [1] <$|(+)|* 2\n    [3]\n    > [1]
  <$|(+)|* 2 <$|(*)|* 3\n    [9]\n\n    > Just 1 <$|(,)|* 2\n    Just (1,2)\n\n    >
  1 *| [(+2)]\n    [3]\n    > 1 *| [(+)] |* 2\n    [3]\n    > 1 *|[(+),(-),(*),(^)]|*
  2\n    [3,-1,2,1]\n\n    > 1 *|Just (,)|* 2\n    Just (1,2)\n\n#### Level-2\n\nbra-ket
  notation:\n\n    > (+1) |$>> [[2]]\n    [[3]]\n    > [[2]] <<$| (+1)\n    [[3]]\n\n
  \   > [Just 1] <<$|(+)|*>> [Just 2]\n    [Just 3]\n    > [Just 1] <<$|(,)|*>> [Just
  2]\n    [Just (1,2)]\n\n    > [[1]] <<$|(+)|*>> [[2]] <<$|(-)|*>> [[3]]\n    [[0]]\n\n
  \   > foldr (\\n acc -> n <<$|(+)|*>> acc) ((**:) 0) [Right (Just 1), Right (Just
  2), Right (Just 3)] :: Either () (Maybe Int)\n    Right (Just 6)\n    > foldr (\\n
  acc -> n <<$|(+)|*>> acc) ((**:) 0) [Right (Just 1), Right Nothing, Right (Just
  3)] :: Either () (Maybe Int)\n    Right Nothing\n    > foldr (\\n acc -> n <<$|(+)|*>>
  acc) ((**:) 0) [Right (Just 1), Right Nothing, Left ()]\n    Left ()\n\nbraket-cover
  notation:\n\n    > [Just 1] <<$|(+)|** 2\n    [Just 3]\n    > 1 **|(+)|$>> [Just
  2]\n    [Just 3]\n    > 1 **|[Just (+)]|**  2\n    [Just 3]\n    > 1 **|[Just (+),
  Just (-), Just (*), Nothing]|** 2\n    [Just 3,Just (-1),Just 2,Nothing]\n\n    >
  [Just 1] <<$|(+)|-* [2]\n    [Just 3]\n    > [Just 1] <<$|(+)|*- Just 2\n    [Just
  3]\n    >      [1]  -*|(+)|$>> [Just 2]\n    [Just 3]\n    >   Just 1  *-|(+)|$>>
  [Just 2]\n    [Just 3]\n    >   Just 1  *-|[Just (+)]|** 2\n    [Just 3]\n    >
  \  Just 1  *-|[Just (+)]|*- Just 2\n    [Just 3]\n    >      [1]  -*|[Just (+)]|*-
  Just 2\n    [Just 3]\n    >      [1]  -*|[Just (+), Just (-), Just (*), Nothing]|*-
  Just 2\n    [Just 3,Just (-1),Just 2,Nothing]\n    >    [0,1]  -*|[Just (+), Just
  (-), Just (*), Nothing]|*- Just 2\n    [Just 2,Just 3,Just (-2),Just (-1),Just 0,Just
  2,Nothing,Nothing]\n\n#### Level-3\n\nWork well likewise.\n\n#### Level-4, Level-5\n\nNot
  completely written up yet.\n\n### [Monad](https://hackage.haskell.org/package/deepcontrol-0.3.0.0/docs/DeepControl-Monad.html)\n\nThis
  module enables you to program in Monad for more deeper level than the usual Monad
  module expresses.\nYou would soon realize exactly what more deeper level means by
  reading the example codes below in order.\n\n#### Level-2\n\n```haskell\nimport
  DeepControl.Applicative ((**:))\nimport DeepControl.Monad\n\nlistlist :: [[String]]
  \            -- List-List Monad\nlistlist = [[\"a\",\"b\"]] >>== \\x ->\n           [[0],[1,2]]
  >>== \\y ->\n           (**:) $ x ++ show y\n\n-- > listlist\n-- [[\"a0\",\"b0\"],[\"a0\",\"b1\",\"b2\"],[\"a1\",\"a2\",\"b0\"],[\"a1\",\"a2\",\"b1\",\"b2\"]]\n```\n\n```haskell\nimport
  DeepControl.Applicative\nimport DeepControl.Monad\nimport DeepControl.Monad.Trans.Writer\n\nfactorial
  :: Int ->\n             Maybe (Writer [Int] Int)  -- Maybe-Writer Monad\nfactorial
  n | n < 0  = (-*) Nothing\nfactorial n | n == 0 = (*:) $ tell [0] >> return 1\nfactorial
  n | n > 0  =\n    factorial (n-1) >>== \\v ->\n    tell [v] ->~\n    (**:) (n *
  v)\n\n-- > runWriter |$> factorial 5\n-- Just (120,[0,1,1,2,6,24])\n```\n\n####
  Level-3\n\n```haskell\nimport DeepControl.Applicative\nimport DeepControl.Monad\nimport
  DeepControl.Monad.Trans.Writer\n\nfactorial :: Int ->\n             IO (Maybe (Writer
  [Int] Int))    -- IO-Maybe-Writer Monad\nfactorial n | n < 0  = (*-*) Nothing\nfactorial
  n | n == 0 = (**:) $ tell [0] >> return 1\nfactorial n | n > 0  =\n    factorial
  (n-1) >>>== \\v ->\n    print v >--~\n    tell [v] -->~\n    (***:) (n * v)\n\n--
  > runWriter |$>> factorial\n-- 0\n-- 1\n-- 1\n-- 2\n-- 6\n-- 24\n-- Just (120,[0,1,1,2,6,24])\n```\n###
  [Monad-Transformer](https://hackage.haskell.org/package/deepcontrol-0.3.0.0/docs/DeepControl-Monad-Trans.html)\n\n####
  Level-2\n\nHere is a monad transformer example how to implement Ackermann function,
  improved to stop within a certain limit of time, with ReaderT2-IO-Maybe monad, a
  level-2 monad-transformation.\n\n```haskell\nimport DeepControl.Applicative\nimport
  DeepControl.Commutative (commute)\nimport DeepControl.Monad ((>-))\nimport DeepControl.Monad.Trans
  (trans2)\nimport DeepControl.Monad.Trans.Reader\n\nimport System.Timeout (timeout)\n\ntype
  TimeLimit = Int\n\nackermannTimeLimit :: TimeLimit -> Int -> Int ->\n                      IO
  (Maybe Int)                 -- IO-Maybe monad\nackermannTimeLimit timelimit x y
  = timeout timelimit (ackermannIO x y)\n  where\n    ackermannIO :: Int -> Int ->
  IO Int\n    ackermannIO 0 n = (*:) $ n + 1\n    ackermannIO m n | m > 0 && n ==
  0 = ackermannIO (m-1) 1\n                    | m > 0 && n > 0  = ackermannIO m (n-1)
  >>= ackermannIO (m-1)\n\nackermannR :: Int -> Int ->\n              ReaderT2 TimeLimit
  IO Maybe Int        -- ReaderT2-IO-Maybe monad\nackermannR x y = do\n    timelimit
  <- ask\n    trans2 $ ackermannTimeLimit timelimit x y        -- transform(lift)
  IO-Maybe function to ReaderT2-IO-Maybe function\n\ncalc_ackermann :: TimeLimit ->
  Int -> Int -> IO (Maybe Int)\ncalc_ackermann timelimit x y = ackermannR x y >- \\r
  -> runReaderT2 r timelimit\n\n-- λ> commute $ calc_ackermann 1000 |$> [0..4] |*
  4\n-- [Just 5,Just 6,Just 11,Just 125,Nothing]\n```\n\n### [Monad-Morph](https://hackage.haskell.org/package/deepcontrol-0.3.0.0/docs/DeepControl-Monad-Morph.html)\n\n###
  [Commutative](https://hackage.haskell.org/package/deepcontrol-0.3.0.0/docs/DeepControl-Commutative.html)\n\n###
  [Arrow](https://hackage.haskell.org/package/deepcontrol-0.3.0.0/docs/DeepControl-Arrow.html)\n"
license-name: BSD3
