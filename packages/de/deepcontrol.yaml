homepage: https://github.com/ocean0yohsuke/deepcontrol
changelog-type: ''
hash: d4139f7ed7279e28c93cde318300232335a046a8de47520a33c3e3967ba24d4b
test-bench-deps:
  base: -any
  deepcontrol: -any
  doctest: ! '>=0.9.3'
  HUnit: ! '>=1.3.0'
  containers: -any
  mtl: -any
  transformers: -any
  QuickCheck: ! '>=2.8.1'
  safe: -any
maintainer: ocean0yohsuke@gmail.com
synopsis: Provide more deeper level style of programming than the usual Control.xxx
  modules express
changelog: ''
basic-deps:
  base: ! '>=4.8 && <5'
  mtl: ! '>=2.2'
  mmorph: ! '>=1.0'
  transformers: ! '>=0.4'
all-versions:
- '0.1.0.0'
- '0.2.0.0'
- '0.3.0.0'
- '0.3.2.0'
- '0.3.3.0'
- '0.4.1.0'
- '0.4.1.1'
- '0.4.2.0'
- '0.4.2.1'
author: KONISHI Yohsuke
latest: '0.4.2.1'
description-type: markdown
description: ! "# deepcontrol\n\nA Haskell library that enables more deeper level
  style programming than the usual Control.xxx modules provide, especially for Applicative
  and Monad.\n\n## Examples\n\n### [Applicative](https://hackage.haskell.org/package/deepcontrol-0.4.2.1/docs/DeepControl-Applicative.html)\n\nThis
  module enables you to program in applicative style for more deeper level than the
  usual Applicative module expresses.\nYou would soon realize exactly what more deeper
  level means by reading the example codes below in order.\n\n    Prelude> :m DeepControl.Applicative\n\n####
  Level-0\n\nbra-ket notation:\n\n    > (1+) |> 2\n    3\n    > 1 <| (+2)\n    3\n\n
  \   > 1 <|(+)|> 2\n    3\n    > 1 <|(+)|> 2 <|(*)|> 3\n    9\n\n    > 1 <|(,)|>
  2\n    (1,2)\n\n#### Level-1\n\nbra-ket notation:\n\n    > (1+) |$> [2]\n    [3]\n
  \   > [1] <$| (+2)\n    [3]\n    > (\"<\"++)|$> [\"a\",\"b\"] <$|(++\">\")\n    [\"<a>\",\"<b>\"]\n\n
  \   > [(1+)] |*> [2]\n    [3]\n\n    > [1] <$|(+)|*> [2]\n    [3]\n    > [1] <$|(+)|*>
  [0,1,2]\n    [1,2,3]\n    > [0,1] <$|(+)|*> [2,3] <$|(+)|*> [4,5]\n    [6,7,7,8,7,8,8,9]\n\n
  \   > foldr (\\x acc -> x <$|(:)|*> acc) ((*:) []) [Just 1, Just 2,  Just 3]\n    Just
  [1,2,3]\n    > foldr (\\x acc -> x <$|(:)|*> acc) ((*:) []) [Just 1, Nothing, Just
  3]\n    Nothing\n\n    > filter (even <$|(&&)|*> (10 >)) [1..100]\n    [2,4,6,8]\n
  \   > filter (even <$|(&&)|*> (10 >) <$|(&&)|*> (5 <)) [1..100]\n    [6,8]\n\ncover
  notation:\n\n    > :t (*:)\n    (*:) :: Applicative f => a -> f a\n\n    > (*:)
  1 :: Maybe Int\n    Just 1\n    > (*:) 1 :: [Int]\n    [1]\n    > (*:) 1 :: Either
  () Int\n    Right 1\n\ncover-braket notation:\n\n    > :t (|*)\n    (|*) :: Applicative
  f => f (a -> b) -> a -> f b\n\n    > [(1+)] |* 2\n    [3]\n    > [1] <$|(+)|* 2\n
  \   [3]\n\n    > (,) |$> [\"a1\",\"a2\"] |* 'b'\n    [(\"a1\",'b'),(\"a2\",'b')]\n\n
  \   > (,,) 'a' |$> [\"b1\",\"b2\"] |* 'c'\n    [('a',\"b1\",'c'),('a',\"b2\",'c')]\n\n
  \   > (,,,) 'a' |$> [\"b1\",\"b2\"] |* 'c' |* 'd'\n    [('a',\"b1\",'c','d'),('a',\"b2\",'c','d')]\n
  \   > (,,,) 'a' |$> [\"b1\",\"b2\"] |* 'c' |*> [\"d1\",\"d2\"]\n    [('a',\"b1\",'c',\"d1\"),('a',\"b1\",'c',\"d2\"),('a',\"b2\",'c',\"d1\"),('a',\"b2\",'c',\"d2\")]\n\n
  \   > 1 *| [(+2)]\n    [3]\n    > 1 *| [(+)] |* 2\n    [3]\n    > 1 *|[(+),(-),(*),(^)]|*
  2\n    [3,-1,2,1]\n\n    > 1 *|Just (,)|* 2\n    Just (1,2)\n\n#### Level-2\n\nbra-ket
  notation:\n\n    > (+1) |$>> [[2]]\n    [[3]]\n    > [[2]] <<$| (+1)\n    [[3]]\n\n
  \   > [Just 1] <<$|(+)|*>> [Just 2]\n    [Just 3]\n    > [Just 1] <<$|(,)|*>> [Just
  2]\n    [Just (1,2)]\n\n    > [[1]] <<$|(+)|*>> [[2]] <<$|(-)|*>> [[3]]\n    [[0]]\n\n
  \   > foldr (\\n acc -> n <<$|(+)|*>> acc) ((**:) 0) [Right (Just 1), Right (Just
  2), Right (Just 3)] :: Either () (Maybe Int)\n    Right (Just 6)\n    > foldr (\\n
  acc -> n <<$|(+)|*>> acc) ((**:) 0) [Right (Just 1), Right Nothing, Right (Just
  3)] :: Either () (Maybe Int)\n    Right Nothing\n    > foldr (\\n acc -> n <<$|(+)|*>>
  acc) ((**:) 0) [Right (Just 1), Right Nothing, Left ()]\n    Left ()\n\ncover notation:\n\n
  \   > :t (**:)\n    (**:) :: (Applicative f1, Applicative f2) => a -> f1 (f2 a)\n
  \   > :t (-*)\n    (-*) :: (Applicative f1, Applicative f2) => f1 a -> f1 (f2 a)\n\n
  \   > (**:) 1 :: Maybe [Int]\n    Just [1]\n    > (-*) (Just 1) :: Maybe [Int]\n
  \   Just [1]\n    > (*:) [1] :: Maybe [Int]\n    Just [1]\n\ncover-braket notation:\n\n
  \   > :t (|**)\n    (|**) :: (Applicative f1, Applicative f2) => f1 (f2 (a -> b))
  -> a -> f1 (f2 b)\n\n    > [Just 1] <<$|(+)|** 2\n    [Just 3]\n    > 1 **|(+)|$>>
  [Just 2]\n    [Just 3]\n    > 1 **|[Just (+)]|**  2\n    [Just 3]\n    > 1 **|[Just
  (+), Just (-), Just (*), Nothing]|** 2\n    [Just 3,Just (-1),Just 2,Nothing]\n\n
  \   > :t (|-*)\n    (|-*) :: (Applicative f1, Applicative f2) => f1 (f2 (a -> b))
  -> f1 a -> f1 (f2 b)\n    > :t (|*-)\n    (|*-) :: (Applicative f1, Applicative
  f2) => f1 (f2 (a -> b)) -> f2 a -> f1 (f2 b)\n\n    > [Just 1] <<$|(+)|-* [2]\n
  \   [Just 3]\n    > [Just 1] <<$|(+)|*- Just 2\n    [Just 3]\n    >      [1]  -*|(+)|$>>
  [Just 2]\n    [Just 3]\n    >   Just 1  *-|(+)|$>> [Just 2]\n    [Just 3]\n    >
  \  Just 1  *-|[Just (+)]|** 2\n    [Just 3]\n    >   Just 1  *-|[Just (+)]|*- Just
  2\n    [Just 3]\n    >      [1]  -*|[Just (+)]|*- Just 2\n    [Just 3]\n    >      [1]
  \ -*|[Just (+), Just (-), Just (*), Nothing]|*- Just 2\n    [Just 3,Just (-1),Just
  2,Nothing]\n    >    [0,1]  -*|[Just (+), Just (-), Just (*), Nothing]|*- Just 2\n
  \   [Just 2,Just 3,Just (-2),Just (-1),Just 0,Just 2,Nothing,Nothing]\n\n#### Level-3,
  Level-4 and Level-5\n\nWork well likewise.\n\n### [Commutative](https://hackage.haskell.org/package/deepcontrol-0.4.2.1/docs/DeepControl-Commutative.html)\n\n
  \   Prelude> :m DeepControl.Commutative\n\n[], Maybe, Either, Except and Writer
  monads are all commutative each other.\n\n    > :t commute\n    commute :: (Applicative
  f, Commutative c) => c (f a) -> f (c a)\n\n    > commute $ Just [1]\n    [Just 1]\n
  \   > commute $ [Just 1]\n    Just [1]\n\n    > commute $ Right (Just 1)\n    Just
  (Right 1)\n    > commute $ Just (Right 1)\n    Right (Just 1)\n\nSo these monads
  can be deepened to Monad2, Monad3, Monad4 and Monad5.\n\n### [Monad](https://hackage.haskell.org/package/deepcontrol-0.4.2.1/docs/DeepControl-Monad.html)\n\nThis
  module enables you to program in Monad for more deeper level than the usual Monad
  module expresses.\nYou would soon realize exactly what more deeper level means by
  reading the example codes below in order.\n\n#### Level-0\n\n```haskell\nimport
  DeepControl.Monad ((>-))\n\nplus :: Int -> Int -> Int\nplus x y = \n    x >- \\a
  ->   -- (>-) is the level-0 bind function, analogous for (>>=)\n    y >- \\b ->\n
  \   a + b\n\n-- > plus 3 4\n-- 7\n```\n\n#### Level-2\n\n```haskell\nimport DeepControl.Applicative
  ((**:))\nimport DeepControl.Monad ((>>==))\n\nlistlist :: [[String]]             --
  List-List monad\nlistlist = [[\"a\",\"b\"]] >>== \\x ->  -- (>>==) is the level-2
  bind function, analogous for (>>=)\n           [[0],[1,2]] >>== \\y ->\n           (**:)
  $ x ++ show y\n\n-- > listlist\n-- [[\"a0\",\"b0\"],[\"a0\",\"b1\",\"b2\"],[\"a1\",\"a2\",\"b0\"],[\"a1\",\"a2\",\"b1\",\"b2\"]]\n```\n\n```haskell\nimport
  DeepControl.Applicative ((|$>), (-*), (*:), (**:))\nimport DeepControl.Monad ((>>),
  (>>==), (->~))\nimport Control.Monad.Writer\n\nfactorial :: Int ->\n             Maybe
  (Writer [Int] Int)               -- Maybe-Writer monad\nfactorial n | n < 0  = (-*)
  Nothing\n            | n == 0 = (*:) $ tell [0] >> (*:) 1\n            | n > 0  =
  factorial (n-1) >>== \\v ->   \n                       tell [v] ->~                 --
  (->~) is a level-2 cover-bind function, analogous for (>>)\n                       (**:)
  (n * v)\n\n-- > runWriter |$> factorial 5\n-- Just (120,[0,1,1,2,6,24])\n```\n\n####
  Level-3\n\n```haskell\nimport DeepControl.Applicative ((|$>>), (*-*), (*:), (**:),
  (***:))\nimport DeepControl.Monad ((>>), (>>>==), (>--~), (-->~))\nimport Control.Monad.Writer\n\nfactorial
  :: Int ->\n             IO (Maybe (Writer [Int] Int))            -- IO-Maybe-Writer
  monad\nfactorial n | n < 0  = (*-*) Nothing                  -- (*-*) is a level-3
  cover function\n            | n == 0 = (**:) $ tell [0] >> (*:) 1\n            |
  n > 0  = factorial (n-1) >>>== \\v ->    -- (>>>==) is the level-3 bind function,
  analogous for (>>=)\n                       print v >--~                   -- (>--~)
  is a level-3 cover-bind function, analogous for (>>)\n                       tell
  [v] -->~                  -- (-->~) is a level-3 cover-bind function too, analogous
  for (>>)\n                       (***:) (n * v)\n\n-- > runWriter |$>> factorial
  5\n-- 1\n-- 1\n-- 2\n-- 6\n-- 24\n-- Just (120,[0,1,1,2,6,24])\n```\n#### Level-4
  and Level-5\n\nWork well likewise.\n\n### [Monad-Transformer](https://hackage.haskell.org/package/deepcontrol-0.4.2.1/docs/DeepControl-Monad-Trans.html)\n\n####
  Level-2\n\nHere is a monad transformer example how to implement Ackermann function,
  improved to stop within a certain limit of time, with ReaderT-IdentityT2-IO-Maybe
  monad, a level-2 monad-transformation.\n\n```haskell\nimport DeepControl.Applicative\nimport
  DeepControl.Commutative (commute)\nimport DeepControl.Monad ((>-))\nimport DeepControl.Monad.Morph
  ((|>|))\nimport DeepControl.Monad.Trans (liftTT2, transfold2, untransfold2)\nimport
  DeepControl.Monad.Trans.Identity\nimport Control.Monad.Reader\nimport Control.Monad.Trans.Maybe\n\nimport
  System.Timeout (timeout)\n\ntype TimeLimit = Int\n\nackermannTimeLimit :: TimeLimit
  -> Int -> Int -> \n                      IO (Maybe Int)                     -- IO-Maybe
  monad\nackermannTimeLimit timelimit x y = timeout timelimit (ackermannIO x y)\n
  \ where\n    ackermannIO :: Int -> Int -> IO Int\n    ackermannIO 0 n = (*:) $ n
  + 1\n    ackermannIO m n | m > 0 && n == 0 = ackermannIO (m-1) 1\n                    |
  m > 0 && n > 0  = ackermannIO m (n-1) >>= ackermannIO (m-1)\n \nackermann :: Int
  -> Int -> \n             ReaderT TimeLimit (IdentityT2 IO Maybe) Int -- ReaderT-IdentityT2-IO-Maybe
  monad\nackermann x y = do\n    timelimit <- ask\n    liftTT2 $ ackermannTimeLimit
  timelimit x y           -- lift IO-Maybe function to ReaderT-IdentityT2-IO-Maybe
  function\n\ncalc_ackermann :: TimeLimit -> Int -> Int -> IO (Maybe Int)\ncalc_ackermann
  timelimit x y = ackermann x y >- \\r -> runReaderT r timelimit\n                                             >-
  runIdentityT2\n\n-- λ> commute $ calc_ackermann 1000 |$> [0..4] |* 4\n-- [Just 5,Just
  6,Just 11,Just 125,Nothing]\n\nackermann' :: Int -> Int -> \n              ReaderT
  TimeLimit (MaybeT IO) Int                -- ReaderT-MaybeT-IO monad\nackermann'
  x y = (runIdentityT . transfold2) |>| ackermann x y -- You can get usual ReaderT-MaybeT-IO
  function from ReaderT-IdentityT2-IO-Maybe function\n\nackermann'' :: Int -> Int
  -> \n               ReaderT TimeLimit (IdentityT2 IO Maybe) Int      -- ReaderT-IdentityT2-IO-Maybe
  monad\nackermann'' x y = (untransfold2 . IdentityT) |>| ackermann' x y -- You can
  get ReaderT-IdentityT2-IO-Maybe function from usual ReaderT-MaybeT-IO function\n```\n\nHere
  is a monad transformer example showing how to use trans-cover functions.\n\n```haskell\nimport
  DeepControl.Applicative ((|$>))\nimport DeepControl.Monad (Monad2)\nimport DeepControl.Monad.Morph
  ((|>|))\nimport DeepControl.Monad.Trans (liftT, (|*|), (|-*|), (|*-|))\nimport DeepControl.Monad.Trans.Identity\nimport
  Control.Monad.Writer\nimport Control.Monad.State\n\ntick :: State Int ()\ntick =
  modify (+1)\n\ntock                         ::                   StateT Int IO ()\ntock
  = do\n    (|*|) tick               :: (Monad      m) => StateT Int m  ()  -- (|*|)
  is the level-1 trans-cover function, analogous for (*:)\n    liftT $ putStrLn \"Tock!\"
  :: (MonadTrans t) => t          IO ()  -- 'liftT' is the level-1 trans-lift function,
  alias to 'lift'\n\n-- λ> runStateT tock 0\n-- Tock!\n-- ((),1)\n\nsave :: StateT
  Int (Writer [Int]) ()\nsave = do\n    n <- get\n    liftT $ tell [n]\n\nprogram
  ::               StateT Int (IdentityT2 IO (Writer [Int])) () -- StateT-IdentityT2-IO-Writer
  monad, a level-2 monad-transform\nprogram = replicateM_ 4 $ do\n    ((|-*|).liftT)
  |>| tock                                           -- (|-*|) is a level-2 trans-cover
  function, analogous for (-*)\n        :: (Monad2 m) => StateT Int (IdentityT2 IO
  m             ) ()\n    ((|*-|).liftT) |>| save                                           --
  (|*-|) is a level-2 trans-cover function, analogous for (*:)\n        :: (Monad
  \ m) => StateT Int (IdentityT2 m  (Writer [Int])) ()\n\n-- λ> execWriter |$> runIdentityT2
  (runStateT program 0)\n-- Tock!\n-- Tock!\n-- Tock!\n-- Tock!\n-- [1,2,3,4]\n```\n####
  Level-3, Level-4 and Level-5\n\nWork well likewise.\n\n### [Monad-Morph](https://hackage.haskell.org/package/deepcontrol-0.4.2.1/docs/DeepControl-Monad-Morph.html)\n\nHere
  is a monad-morph example, a level-2 monad-morph.\n\n```haskell\nimport DeepControl.Monad.Morph\nimport
  Control.Monad.Writer\nimport Control.Monad.State\n\n-- i.e. :: StateT Int Identity
  ()\ntick    :: State Int ()\ntick = modify (+1)\n\ntock                        ::
  \                  StateT Int IO ()\ntock = do\n    generalize |>| tick     :: (Monad
  \     m) => StateT Int m  ()  -- (|>|) is the level-1 trans-map function, analogous
  for (|$>)\n    lift $ putStrLn \"Tock!\" :: (MonadTrans t) => t          IO ()\n\n--
  λ> runStateT tock 0\n-- Tock!\n-- ((),1)\n\n-- i.e. :: StateT Int (WriterT [Int]
  Identity) ()\nsave    :: StateT Int (Writer  [Int]) ()\nsave = do\n    n <- get\n
  \   lift $ tell [n]\n\nprogram ::                   StateT Int (WriterT [Int] IO)
  ()\nprogram = replicateM_ 4 $ do\n    lift |>| tock\n        :: (MonadTrans t) =>
  StateT Int (t             IO) ()\n    generalize |>>| save                                        --
  (|>>|) is the level-2 trans-map function, analogous for (|$>>)\n        :: (Monad
  \     m) => StateT Int (WriterT [Int] m ) ()\n\n-- λ> execWriterT (runStateT program
  0)\n-- Tock!\n-- Tock!\n-- Tock!\n-- Tock!\n-- [1,2,3,4]\n```\n\n#### Level-3, Level-4
  and Level-5\n\nWork well likewise.\n\n### [Arrow](https://hackage.haskell.org/package/deepcontrol-0.4.2.1/docs/DeepControl-Arrow.html)\n"
license-name: BSD3
