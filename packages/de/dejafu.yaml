homepage: https://github.com/barrucadu/dejafu
changelog-type: ''
hash: aa60d577349a4667a6be5e6da7bbb9baf7c896236c141e4f4bf615f2595667c8
test-bench-deps: {}
maintainer: mike@barrucadu.co.uk
synopsis: Overloadable primitives for testable, potentially non-deterministic, concurrency.
changelog: ''
basic-deps:
  exceptions: ! '>=0.7'
  stm: -any
  base: ! '>=4.5 && <5'
  monad-loops: -any
  monad-control: -any
  semigroups: -any
  array: -any
  dpor: -any
  containers: -any
  atomic-primops: -any
  mtl: -any
  transformers-base: -any
  transformers: -any
  deepseq: -any
  template-haskell: -any
all-versions:
- '0.1.0.0'
- '0.2.0.0'
- '0.3.0.0'
author: Michael Walker
latest: '0.3.0.0'
description-type: haddock
description: ! '/[Déjà Fu is] A martial art in which the user''s limbs move in time
  as well as space, […] It is best described as "the feeling that you have been kicked
  in the head this way before"/ -- Terry Pratchett, Thief of Time


  Concurrency is nice, deadlocks and race conditions not so much. The

  @Par@ monad family, as defined in

  <https://hackage.haskell.org/package/abstract-par/docs/Control-Monad-Par-Class.html
  abstract-par>

  provides deterministic parallelism, but sometimes we can tolerate a

  bit of nondeterminism.


  This package provides a class of monads for potentially

  nondeterministic concurrency, with an interface in the spirit of

  GHC''s normal concurrency abstraction.


  == @MonadConc@ with ''IO'':


  The intention of the @MonadConc@ class is to provide concurrency

  where any apparent nondeterminism arises purely from the scheduling

  behaviour. To put it another way, a given computation, parametrised

  with a fixed set of scheduling decisions, is deterministic. This

  assumption is used by the testing functionality provided by

  Test.DejaFu.


  Whilst this assumption may not hold in general when ''IO'' is

  involved, you should strive to produce test cases where it does.


  == Memory Model


  The testing functionality supports a few different memory models,

  for computations which use non-synchronised `CRef` operations. The

  supported models are:


  * __Sequential Consistency:__ A program behaves as a simple

  interleaving of the actions in different threads. When a CRef is

  written to, that write is immediately visible to all threads.


  * __Total Store Order (TSO):__ Each thread has a write buffer. A

  thread sees its writes immediately, but other threads will only

  see writes when they are committed, which may happen later. Writes

  are committed in the same order that they are created.


  * __Partial Store Order (PSO):__ Each CRef has a write buffer. A

  thread sees its writes immediately, but other threads will only

  see writes when they are committed, which may happen later. Writes

  to different CRefs are not necessarily committed in the same order

  that they are created.


  If a testing function does not take the memory model as a parameter,

  it uses TSO.


  See the <https://github.com/barrucadu/dejafu README> for more

  details.'
license-name: MIT
