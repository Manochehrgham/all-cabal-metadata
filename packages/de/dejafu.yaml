homepage: https://github.com/barrucadu/dejafu
changelog-type: ''
hash: c55eb1b3a318be34d3a791c3d506789410a98d69ad7a24fb289b31fa9a1b0d50
test-bench-deps:
  base: -any
  dejafu: -any
maintainer: mike@barrucadu.co.uk
synopsis: Overloadable primitives for testable, potentially non-deterministic, concurrency.
changelog: ''
basic-deps:
  exceptions: ! '>=0.7'
  stm: -any
  base: ! '>=4.5 && <5'
  monad-loops: -any
  containers: -any
  mtl: -any
  transformers: -any
  random: -any
  deepseq: -any
all-versions:
- '0.1.0.0'
author: Michael Walker
latest: '0.1.0.0'
description-type: haddock
description: ! '/[Déjà Fu is] A martial art in which the user''s limbs move in time
  as well as space, […] It is best described as "the feeling that you have been kicked
  in the head this way before"/ -- Terry Pratchett, Thief of Time


  Concurrency is nice, deadlocks and race conditions not so much. The

  @Par@ monad family, as defined in

  <https://hackage.haskell.org/package/abstract-par/docs/Control-Monad-Par-Class.html
  abstract-par>

  provides deterministic parallelism, but sometimes we can tolerate a

  bit of nondeterminism.


  This package provides a class of monads for potentially

  nondeterministic concurrency, with an interface in the spirit of

  GHC''s normal concurrency abstraction.


  == @MonadConc@ with ''IO'':


  The intention of the @MonadConc@ class is to provide concurrency

  where any apparent nondeterminism arises purely from the scheduling

  behaviour. To put it another way, a given computation, parametrised

  with a fixed set of scheduling decisions, is deterministic. This

  assumption is used by the testing functionality provided by

  Test.DejaFu.


  Whilst this assumption may not hold in general when ''IO'' is

  involved, you should strive to produce test cases where it does.


  See the <https://github.com/barrucadu/dejafu README> for more

  details.'
license-name: MIT
