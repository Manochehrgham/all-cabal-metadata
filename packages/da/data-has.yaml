homepage: https://github.com/winterland1989/data-has
changelog-type: ''
hash: 9e2596d621e8909ab13fdd5d4a9621aa72f3dd47b536af71cfad83640855a4bf
test-bench-deps:
  data-has: -any
  base: -any
  criterion: ! '>=1.0.2.0'
  transformers: -any
maintainer: winterland1989@gmail.com
synopsis: Simple extensible product
changelog: ''
basic-deps:
  base: <5
all-versions:
- '0.1.0.0'
author: winterland1989
latest: '0.1.0.0'
description-type: markdown
description: ! "data-has\n========\n\n[![Hackage](https://img.shields.io/hackage/v/data-has.svg?style=flat)](http://hackage.haskell.org/package/data-has)\n[![Build
  Status](https://travis-ci.org/winterland1989/data-has.svg)](https://travis-ci.org/winterland1989/data-has)\n\nA
  simple extensible product system, a typical usage is to free you from considering
  how to layer your monad stack, because your can now extend your monad in one layer:\n\n```haskell\n
  {-# LANGUAGE FlexibleContexts #-}\n\n -- in some library code\n ...\n logInAnyReaderHasLogger
  :: (Has Logger r, MonadReader r m) => LogString -> m ()\n logInAnyReaderHasLogger
  s = asks get >>= logWithLogger s\n\n queryInAnyReaderHasSQL :: (Has SqlBackEnd r,
  MonadReader r m) => Query -> m a\n queryInAnyReaderHasSQL q = asks get >>= queryWithSQL
  q\n ...\n\n -- now you want to use these effects together\n ...\n logger <- initLogger
  \ ...\n sql <- initSqlBackEnd ...\n\n (`runReader` (logger, sql)) $ do\n       ...\n
  \      logInAnyReaderHasLogger ...\n       ...\n       x <- queryInAnyReaderHasSQL
  ...\n       ...\n...\n```\n"
license-name: BSD3
