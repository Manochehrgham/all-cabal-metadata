homepage: https://github.com/PseudoPower/AFSM
changelog-type: markdown
hash: d7ea22e90eeae5adf0ed015a60f836c64383da9860f4f442d11f1204f5391bf6
test-bench-deps: {}
maintainer: hanzh.xu@gmail.com
synopsis: Arrowized functional state machines
changelog: ! "## 0.1.2.0\r\n\r\n  * switch ```SM :: s -> (SMState s a b) -> SM a b```
  to ```SM :: (SMState s a b) -> s -> SM a b```.\r\n  * the ArrowApp instance\r\n
  \ * new functions: foldlSM, foldlDelaySM, delaySM, concatSM.\r\n  * working on Event,
  several undefined functions about Event.\r\n  * It's always hard to pick a name!
  'Event', 'Evnt', 'Ev' or 'E'? "
basic-deps:
  base: ! '>=4.7 && <5'
all-versions:
- '0.1.2.0'
author: Hanzhong Xu, Meng Meng
latest: '0.1.2.0'
description-type: markdown
description: ! "# Arrowized functional state machines\n\n## Introduction\n\nThe intuitive
  way to understand the state machine is that it have four parts, state, storage,
  input and output. Each state has its own transition function which takes the storage
  and the input, updates the storage and the state, and gives the output.\n\nThe abstract
  way is thinking the state machine as the stateful function.\n\nNow, let us put these
  two ways together. Our plan is using the stateful function as the interface(making
  it to be an instance of the ```Arrow``` type class), but users can build state machines
  in an intuitive way.\n\n## Basic Concepts\n\nThe ```SM a b``` type denotes stateful
  functions from ```a``` to ```b```. Also, It is an instance of the ```Arrow``` type
  class.\n```\n-- | 'SMState' is the type of transition functions\n--     s: storage,
  a: input, b: output\ntype SMState s a b = (s -> a -> (SM a b, b))\n\n-- | 'SM' is
  the type representing state machines.\ndata SM a b where\n  SM :: (SMState s a b)
  -> s -> SM a b\n--\n--    a  /--------\\  b\n--  >--->| SM a b |>--->\n--       \\--------/\n--\n--
  (>>>) :: SM a b -> SM b c -> SM a c\n--\n--    a  /--------\\  b  /--------\\  c\n--
  \ >--->| SM a b |>--->| SM b c |>--->\n--       \\--------/     \\--------/\n--\n--\n--
  first :: SM a b -> SM (a, c) (b, c)\n--\n--    a  /--------------\\  b\n--  >--->|>->
  SM a b >->|>--->\n--       |              |\n--  >--->|>------------>|>--->\n--
  \   c  \\--------------/  c\n--\n-- (***) :: SM a b -> SM c d -> SM (a, c) (b, d)\n--\n--
  \   a  /--------------\\  b\n--  >--->|>-> SM a b >->|>--->\n--       |              |\n--
  \ >--->|>-> SM c d >->|>--->\n--    c  \\--------------/  d\n--\n-- (&&&) :: SM
  a b -> SM a c -> SM a (b, c)\n--\n--            /--------\\  b\n--       /--->|
  SM a b |>---\\\n--    a  |    \\--------/    |  (b,c)\n--  >--->|                  |>------->\n--
  \      |    /--------\\  c |\n--       \\--->| SM a c |>---/\n--            \\--------/\n--\n\n--
  execute SM a b with input [a].\nexec :: SM a b -> [a] -> (SM a b, [b])\n```\n\nFrom
  a theoretical point of view, this model is a simplified version of FRP, but adding
  states on functions directly. In another word, it is switching the focus from time
  to states.\n\nFrom an engnieering point of view, the other difference from AFRP(Yampa)
  is that we provide the constructor to use the transition function ```SMState s a
  b :: s -> a -> (SM a b, b)``` to build ```SM a b``` directly where ```s``` donates
  the storage type.\n\n### Simplifed model\n\nIn functional reactive programming(FRP),
  the key concepts are the signal, ```Signal a :: Time -> a```, and the signal function
  from signal to signal, ```SF a b :: Signal a -> Signal b```.\n\nThe model of FRP
  is beautiful, but one diffcult thing is that the signal is continuous function,
  and our computers are discrete systems.\n\nHowever, what if we do not care about
  time, and only focus on the sequence of input. There is reason to believe that computational
  tasks usually are time-insensitive. For example, the parsing process. So ```[a]```
  and ```[Event a]``` are the only things we expected in our system.\n\nFor discrete
  system, simplifying the input type is kind of generalizing ```[(Time,a)]``` to ```[a]```.
  This simplifed model is still able to process the time sequences by using ```[(Time,
  a)]``` as the input. In conclusion, we doesn't consider time as an essential part
  of the input, but if the input involves time, users can add time back as a part
  of the input.\n\n### Stateful function(Storage)\n\nUsually, the state can be abstracted
  to the summary of input history. With the ArrowLoop instance, we can create stateful
  functions in FPR. For example, if we want to get a function ```SF a b``` with state
  ```c```. We first write a function ```SF (a, c) (b, c)```, then use ```loop :: SF
  (a, c) (b, c) -> SF a b``` to get the stateful function ```SF a b```.\n\nBut I prefer
  to think the pure function as the stateful function with state ```()```, because
  the stateful function gives us a more natural way to represent the control flow.
  Also, it give us the ability to switch the function itself based on different inputs.\n\n##
  Implementation\n\nThe key idea is using the GADTs extension to hide the state(storage)
  type. If we do not use the GADTs extension, then ```SM a b``` will become ```SM
  s a b``` where ```s``` denotes the state(storage) type.\n\n## Examples\n\n### Reverse
  Polish notation([RPN.hs](https://github.com/PseudoPower/AFSM/blob/master/examples/RPN.hs))\n\nIt
  is also known as postfix notation, and it is very straightforward example. The input
  is the infix expression, and the output is the value. First, we build a SM named
  in2post to convert infix notation to postfix expression. Then we build a SM named
  post2ret to evaluate the valus. Finally, we use them to compose ```in2ret = in2post
  >>> post2ret```.\n\n\n## To-Do\n  * Basic state machines\n  * Event\n  * More high
  order functions\n  * Another DSL to build transition functions?\n\n## References\n\n[Functional
  Reactive Programming, Continued](http://haskell.cs.yale.edu/wp-content/uploads/2011/02/workshop-02.pdf)\n\n[Yampa
  - Haskell Wiki](https://wiki.haskell.org/Yampa)\n\n[Haskell/Arrow tutorial](https://en.wikibooks.org/wiki/Haskell/Arrow_tutorial)\n\n
  \ * Just realize that both AFRP and our model are very similar with ```Circuit```.
  Actually, FRP is simulating signal systems, also it's why I prefer to use the name
  ```signal function``` instead of ```behavior function```. On the other hand, AFRP
  is AFSM with fix storage type ```DTime```, and the benefit is that it does not require
  the GADTs extension.\n"
license-name: MIT
