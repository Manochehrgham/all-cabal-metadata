changelog-type: ''
hash: f559d26d1f531022173412216ba2e5e2513fcadccd8339a1cf8a68ba9a41276d
test-bench-deps: {}
synopsis: A perfect hashing library for mapping bytestrings to values.
changelog: ''
basic-deps:
  bytestring: -any
  base: ! '>=4.5 && <4.8'
  time: -any
  array: -any
  containers: -any
  binary: -any
  digest: -any
all-versions:
- '0.1'
- '0.1.1'
- '0.1.2'
- '0.1.3'
- '0.1.4'
latest: '0.1.4'
description-type: text
description: ! "This is a thin haskell wrapper around the CMPH library, obtainable
  at http://cmph.sf.net.\nI assume you have it installed in /usr/local/lib.\n\nThe
  motivation is mostly speed, and wren thornton's bytestring-trie seems to be the
  main competition:\n\n% ./dist/build/benchmark_trie/benchmark_trie\n* trie lookup:
  \  1.136ns per iteration / 880403.98 per second.\n\n% ./dist/build/benchmark/benchmark
  \         \n* perfect lookup:   0.687ns per iteration / 1456455.69 per second.\n\nit
  also uses less space in the haskell heap, building once and doing the same number
  of lookups:\n\nPerfectHash:\n\ttotal alloc = 2,525,223,964 bytes  (excludes profiling
  overheads)\n\nTrie:\n\ttotal alloc = 9,806,202,096 bytes  (excludes profiling overheads)\n\nalthough
  this is not an entirely fair comparison given how much PerfectHash stores on the
  C side.\n"
