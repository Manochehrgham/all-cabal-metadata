homepage: ''
changelog-type: ''
hash: e7fdb3f8d0340ca03b14affbca4325772c51b08740bd11b726396285815ba559
test-bench-deps: {}
maintainer: kai@kzhang.org
synopsis: Scientific workflow management system
changelog: ''
basic-deps:
  shelly: -any
  bytestring: -any
  split: -any
  base: ! '>=4.0 && <5.0'
  data-default-class: -any
  text: -any
  graphviz: -any
  containers: -any
  lens: ! '>=4.0'
  fgl: -any
  mtl: -any
  transformers: -any
  optparse-applicative: -any
  th-lift: -any
  template-haskell: -any
  yaml: -any
all-versions:
- '0.1.0'
- '0.2.0'
- '0.3.0'
- '0.4.0'
- '0.4.1'
author: Kai Zhang
latest: '0.4.1'
description-type: markdown
description: ! "Scientific workflow management system\n=====================================\n\nA
  scientific workflow is a series of computational steps which usually can be presented
  as a Directed Acyclic Graph (DAG).\n\nSciFlow is to help programmers design complex
  workflows with ease. Here is a trivial example. (Since we use template haskell,
  we need to divide this small program into two parts.)\n\n```haskell\n---------------------------------------------------\n--
  File 1: MyModule.hs\n---------------------------------------------------\n{-# LANGUAGE
  OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\nmodule Functions\n    (builder)
  where\n\nimport Control.Lens ((^.), (.=))\nimport qualified Data.Text as T\nimport
  Shelly hiding (FilePath)\nimport Text.Printf (printf)\n\nimport Scientific.Workflow\n\ncreate
  :: () -> IO FilePath\ncreate _ = do\n    writeFile \"hello.txt\" \"hello world\"\n
  \   return \"hello.txt\"\n\ncountWords :: FilePath -> IO Int\ncountWords fl = do\n
  \   content <- readFile fl\n    return $ length $ words content\n\ncountChars ::
  FilePath -> IO Int\ncountChars fl = do\n    content <- readFile fl\n    return $
  sum $ map length $ words content\n\noutput :: (Int, Int) -> IO Bool\noutput (ws,
  cs) = do\n    putStrLn $ printf \"Number of words: %d\" ws\n    putStrLn $ printf
  \"Number of characters: %d\" cs\n    return True\n\ncleanUp :: (Bool, FilePath)
  -> IO ()\ncleanUp (toBeRemoved, fl) = if toBeRemoved\n    then shelly $ rm $ fromText
  $ T.pack fl\n    else return ()\n\n-- builder monad\nbuilder :: Builder ()\nbuilder
  = do\n    node \"step0\" 'create $ label .= \"write something to a file\"\n    node
  \"step1\" 'countWords $ label .= \"word count\"\n    node \"step2\" 'countChars
  $ label .= \"character count\"\n    node \"step3\" 'output $ label .= \"print\"\n
  \   node \"step4\" 'cleanUp $ label .= \"remove the file\"\n\n    [\"step0\"] ~>
  \"step1\"\n    [\"step0\"] ~> \"step2\"\n    [\"step1\", \"step2\"] ~> \"step3\"\n
  \   [\"step3\", \"step0\"] ~> \"step4\"\n\n---------------------------------------------------\n--
  File 2: main.hs\n---------------------------------------------------\n{-# LANGUAGE
  TemplateHaskell #-}\n\nimport System.Environment\n\nimport qualified Functions as
  F\nimport qualified Data.Text.Lazy.IO as T\n\nimport Scientific.Workflow\nimport
  Scientific.Workflow.Visualize\n\nbuildWorkflow \"wf\" F.builder\n\nmain :: IO ()\nmain
  = do\n    (cmd:args) <- getArgs\n    case cmd of\n        \"run\" -> runWorkflow
  wf def\n        \"view\" -> T.putStrLn $ renderBuilder F.builder\n```\n\nThe workflow
  can be visualized by running `runghc main.hs view | dot -Tpng > example.png`.\n\n![example](examples/example.png)\n\nTo
  run the workflow, simply type `runghc main.hs run`. The program will create a directory
  to store results of each step. If being terminated prematurely, the program will
  use the saved data to continue from the last step.\n"
license-name: MIT
