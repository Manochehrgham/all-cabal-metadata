changelog-type: ''
hash: da2c8a8ca2bf3d942f2d36ea7459edc6a6814f5ee1844322563108c45707dbd4
synopsis: Numbers represented using scientific notation
changelog: ''
all-versions:
- '0.0.0.0'
- '0.0.0.1'
- '0.0.0.2'
- '0.1.0.0'
- '0.1.0.1'
- '0.2.0.0'
- '0.2.0.1'
- '0.2.0.2'
- '0.3.0.0'
- '0.3.0.1'
- '0.3.0.2'
- '0.3.1.0'
- '0.3.2.0'
- '0.3.2.1'
- '0.3.2.2'
- '0.3.3.0'
- '0.3.3.1'
- '0.3.3.2'
- '0.3.3.3'
- '0.3.3.4'
- '0.3.3.5'
- '0.3.3.6'
- '0.3.3.7'
- '0.3.3.8'
latest: '0.3.3.8'
description-type: haddock
description: ! '@Data.Scientific@ provides a space efficient and arbitrary precision

  scientific number type.


  ''Scientific'' numbers are represented using

  <http://en.wikipedia.org/wiki/Scientific_notation scientific notation>. It

  uses a coefficient @c :: ''Integer''@ and a base-10 exponent @e :: ''Int''@ (do

  note that since we''re using an ''Int'' to represent the exponent these numbers

  aren''t truly arbitrary precision). A scientific number corresponds to the

  ''Fractional'' number: @''fromInteger'' c * 10 ''^^'' e@.


  The main application of ''Scientific'' is to be used as the target of parsing

  arbitrary precision numbers coming from an untrusted source. The advantages

  over using ''Rational'' for this are that:


  * A ''Scientific'' is more efficient to construct. Rational numbers need to be

  constructed using ''%'' which has to compute the ''gcd'' of the ''numerator'' and

  ''denominator''.


  * ''Scientific'' is safe against numbers with huge exponents. For example:

  @1e1000000000 :: ''Rational''@ will fill up all space and crash your

  program. Scientific works as expected:


  > > read "1e1000000000" :: Scientific

  > 1.0e1000000000


  * Also, the space usage of converting scientific numbers with huge exponents to

  @''Integral''s@ (like: ''Int'') or @''RealFloat''s@ (like: ''Double'' or ''Float'')

  will always be bounded by the target type.'
