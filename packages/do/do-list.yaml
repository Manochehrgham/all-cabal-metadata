homepage: https://github.com/tserduke/do-list
changelog-type: markdown
hash: 0a31dda3ad13128d50650592de814a311a6b54fb18300243c6f4c639219d48f8
test-bench-deps:
  base: <5
  hspec: -any
  criterion: -any
  do-list: -any
  mtl: -any
maintainer: taras.serduke@gmail.com
synopsis: List construction with do notation
changelog: ! '# Change Log


  ## 0.9.0 (2016-09-08)

  * Changed back result type of item to polymorphic

  * Added IsString instance

  * Renamed unDoList to toDList

  * Documentation edits

  * Added benchmarks


  ## 0.8.1 (2016-09-07)

  * Reified result type of item to ()

  * Added note about Control.Monad.Writer

  * Minor documentation edits

'
basic-deps:
  base: <5
  dlist: -any
all-versions:
- '0.8.0'
- '0.8.1'
- '0.9.0'
author: Taras Serduke
latest: '0.9.0'
description-type: markdown
description: ! "# do-list\n[DoList] makes it easy to use do notation for defining
  list structures.\n\n## Examples\n\n### Benchmarks\n```haskell\nmodule Main (main)
  where\n\nimport Criterion.Main\nimport Data.DoList (DoList, item, toList)\n\nmain
  :: IO ()\nmain = defaultMain $ toList $ do\n  doBench \"plus\"  $ whnf (2 +) (1
  :: Int)\n  doBench \"minus\" $ whnf (2 -) (1 :: Int)\n\n-- Now we can define benchmarks
  with do notation.\ndoBench :: String -> Benchmarkable -> DoList Benchmark ()\ndoBench
  name = item . bench name\n```\n\n### Multiline Text\n```haskell\n{-# LANGUAGE NoImplicitPrelude
  #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# OPTIONS_GHC -fno-warn-unused-do-bind
  #-}\n\nmodule Main (main) where\n\nimport BasicPrelude\nimport Data.DoList (DoList,
  toList)\n\nmain :: IO ()\nmain = putStr $ runLines $ do\n  \"fib 0 = 0\"\n  \"fib
  1 = 1\"\n  \"fib n = fib (n-1) + fib (n-2)\"\n\nrunLines :: DoList Text () -> Text\nrunLines
  = unlines . toList\n```\n\n[DoList]: https://hackage.haskell.org/package/do-list/docs/Data-DoList.html\n"
license-name: BSD3
