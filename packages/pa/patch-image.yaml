homepage: http://hub.darcs.net/thielema/patch-image/
changelog-type: markdown
hash: 557cef34e8f0945bbfb8eb0b62a5029cdffffe59148f1f58d435d2f918c62e0f
test-bench-deps: {}
maintainer: Henning Thielemann <haskell@henning-thielemann.de>
synopsis: Compose a big image from overlapping parts
changelog: ! "# Change log for the `patch-image` package\n\n## 0.2:\n\n * Add new
  executable that is based on LLVM and `knead`.\n\n * Add new algorithm for assembling
  the image from its parts.\n   The algorithm finds exactly matching part shapes,\n
  \  such that the border of the shapes is where it hurts least visually.\n\n## 0.1.0.2:\n\n
  * Switch from `accelerate-fft` to `accelerate-cufft`.\n\n## 0.1:\n\n * Implement
  the patching algorithm using `accelerate-cuda`.\n\n## 0.0:\n\n * Tests for a weighting
  algorithm using `GeomAlgLib`.\n   The goal is to find a reasonable weighting\n   for
  mixing arbitrary overlapping polygons.\n"
basic-deps:
  llvm-tf: ! '>=3.1 && <3.2'
  JuicyPixels: ! '>=2.0 && <3.3'
  accelerate-fourier: ! '>=0.0 && <0.1'
  carray: ! '>=0.1.5 && <0.2'
  accelerate-utility: ! '>=0.1 && <0.2'
  accelerate-arithmetic: ! '>=0.1 && <0.2'
  Cabal: ! '>=1.18 && <2'
  base: ==4.*
  knead: ! '>=0.2.1 && <0.3'
  accelerate-cufft: ! '>=0.0 && <0.1'
  filepath: ==1.3.*
  array: ! '>=0.5 && <0.6'
  pqueue: ! '>=1.2 && <1.4'
  accelerate-cuda: ! '>=0.15 && <0.15.1'
  enumset: ! '>=0.0.4 && <0.1'
  utility-ht: ! '>=0.0.1 && <0.1'
  containers: ! '>=0.4.2 && <0.6'
  fft: ! '>=0.1.7 && <0.2'
  llvm-extra: ! '>=0.7 && <0.8'
  accelerate-io: ! '>=0.15 && <0.16'
  accelerate: ! '>=0.15 && <0.16'
  tfp: ! '>=1.0 && <1.1'
  gnuplot: ! '>=0.5 && <0.6'
  hmatrix: ==0.15.*
  vector: ! '>=0.10 && <0.13'
all-versions:
- '0.1'
- '0.1.0.1'
- '0.1.0.2'
- '0.2'
author: Henning Thielemann <haskell@henning-thielemann.de>
latest: '0.2'
description-type: markdown
description: ! "This is the workflow:\nScan parts of an image that considerably overlap.\nThey
  must all be approximately oriented correctly.\nThe program uses the overlapping
  areas for reconstruction\nof the layout of the parts.\nIf all parts are in the directory
  `part`\nthen in the best case you can simply run:\n\n    patch-image --output=collage.jpeg
  part/*.jpeg\n\nIf you get blurred areas,\nyou might enable an additional rotation
  correction:\n\n    patch-image --finetune-rotate --output=collage.jpeg part/*.jpeg\n\nIt
  follows an overview of how the program works.\nIt implies some things you should
  care about when using the program.\n\nThe program runs three phases:\n\n* Orientate
  each image part individually\n\n* Find overlapping areas in the parts\n  and reconstruct
  the part positions within the big image\n\n* Blend the parts in order to get the
  big image\n\nThe first phase orientates each part\nsuch that horizontal structures
  become perfectly aligned.\nOnly the brightness channel of the image is analysed.\nHorizontal
  structures can be text or the border of the image.\nThis also means that you should
  orientate the parts\nhorizontally, not vertically.\nI also recommend not to mix
  horizontal and vertical scanned parts\nsince the horizontal and vertical resolution
  of your scanner\nmight differ slightly.\nHowever, it should be fine to rotate the
  image source by 180Â°\nand rotate it back digitally,\nbefore feeding it to the patch-image
  program.\n\n## 1st Phase\n\nOptions for the first phase:\n\n* `--maximum-absolute-angle`:\n
  \ Maximum angle to test for.\n\n* `--number-angles`:\n  Number of angles minus one\n
  \ to test between negative and positive maximum angle.\n\n* `--hint-angle`:\n  If
  the search for horizontal structures\n  does not yield satisfying results for an
  image part,\n  you may prepend the `--hint-angle` option with the wanted angle\n
  \ to the image path.\n\n## 2nd Phase\n\nIn the second phase the program looks\nfor
  overlapping parts between all pairs of images.\nFor every pair it computes a convolution
  via a Fourier transform.\nOnly the brightness channel of the image is analysed.\n\n*
  `--pad-size`:\n  Computing a convolution of two big images may exceed your graphics
  memory.\n  To this end, images are shrunk before convolution.\n  The pad size is
  the size in pixels after shrinking\n  that holds 2x2 shrunken image parts.\n  After
  determination of the distance between the shrunken parts\n  the matching is repeated
  on a non-reduced clip of the original image part,\n  in order to get precise coordinates.\n\n*
  `--minimum-overlap`:\n  There must be a minimum of overlap\n  in order to accept
  that the images actually overlap.\n  The overlap is measured as a portion of the
  image part size.\n\n* `--maximum-difference`:\n  The maximum allowed mean difference\n
  \ within an overlapping area of two overlapping images.\n  If the difference is
  larger,\n  then the program assumes that the parts do not overlap.\n\n* `--smooth`:\n
  \ It is important to eliminate a brightness offset,\n  that is, big black and big
  white areas should be handled equally.\n  To this end the image is smoothed\n  and
  the smoothed image is subtracted from the original one.\n  This option allows to
  specify the degree (radius) of the smoothing.\n  I don't think you ever need to
  touch this parameter.\n\n* `--output-overlap`:\n  Writes images for all pairs of
  image parts.\n  These images allow you to diagnose\n  where the matching algorithm
  failed.\n  It may help you to adjust the matching parameters.\n  In the future we
  might add an option to ignore problematic pairs.\n\nSince in the first phase every
  image part is oriented individually\nit may happen that the part orientations don't
  match.\nThis would result in blurred areas in the final collage.\nIn order to correct
  this,\nyou can run phase two in an extended mode,\nthat also re-evaluates the part
  orientations.\nThe orientation of the composed image is then determined\nby the
  estimated orientation of the first image.\n\nOptions:\n\n* `--finetune-rotate`:\n
  \ Enables the extended overlapping mode.\n  The option `--output-overlap` will then
  be ignored.\n\n* `--number-stamps`:\n  The extended mode selects many small clips
  in the overlapping area\n  and tries to match them.\n  We call these clips /stamps/.\n
  \ This option controls the number of stamps per overlapping area minus one.\n\n*
  `--stamp-size`:\n  Size of a square stamp in pixels.\n\n## 3rd Phase\n\nThe third
  phase composes a big image from the parts.\nThe parts are weighted such that the
  part boundaries cannot be seen anymore\nand differences in brightness are faded
  into another.\nThe downside is that the superposition may lead to blur.\n\nOptions:\n\n*
  `--output`:\n  Path of the output JPEG image with the weighted collage.\n\n* `--output-hard`:\n
  \ Alternative output of a JPEG collage\n  where the image parts are simply averaged.\n
  \ You will certainly see bumps in brightness\n  at the borders of the image parts.\n
  \ This output may be mostly useful to promote the great weighting algorithm\n  employed
  by `--output`.\n\n* `--output-distance-map`:\n  The weight for every pixel is chosen
  according to the distance\n  to an image part boundary that lies within other parts.\n
  \ The rationale is that the weight shall become zero\n  when the pixel is close
  to a position\n  that will be affected by a disruption otherwise.\n  This option
  allows to emit the distance map for every image part.\n\n* `--distance-gamma`:\n
  \ If the distances are used for weighting as they are,\n  the program fades evenly
  between the overlapping image parts\n  over the entire overapping area.\n  This
  may mean that the overlapping area is blurred.\n  Raising the distance to a power
  greater than one reduces the area of blur.\n  The downside is that it also reduces
  the area for adaption\n  of differing brightness.\n\nThe LLVM implementation provides
  an additional way to assemble the image parts.\nThe weighting approach tries to
  blend across all the overlapping area.\nThis can equalize differences in brightness.\nThe
  downside is that imperfectly matching image parts\nlead to blurred content in the
  overlapping area.\nAn alternative algorithm tries to make the overlapping as small
  as possible\nand additionally performs blending where it hurts least.\nMore precisely,
  parts are blended where they differ least.\nHowever, if the brightness of the image
  parts differ\nthen the blending boundaries may become visible.\n\nOptions:\n\n*
  `--output-shaped`:\n  Path of the output JPEG image with smoothly blended image
  parts\n  along curves of low image difference.\n\n* `--output-shaped-hard`:\n  Like
  before but the image parts are not smoothly faded.\n  Instead, every pixel belongs
  to exactly one original image part.\n  This is more for debugging purposes than
  of practical use.\n\n* `--output-shape`:\n  Emit the smoothed mask of each image
  part used for blending.\n\n* `--output-shape-hard`:\n  Emit the non-smoothed masks.\n\n*
  `--shape-smooth`:\n  Smooth radius of the image masks.\n  The higher, the smoother
  is the blending between parts.\n\nGeneral options:\n\n* `--quality`:\n  JPEG quality
  percentage for writing the images.\n"
license-name: BSD3
