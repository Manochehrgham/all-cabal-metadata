changelog-type: ''
hash: 91d56562fc5b7de5b5ba01ad30d3195ca24b960f3d9e875d143f699cb00a5446
test-bench-deps: {}
synopsis: A composable exception handler
changelog: ''
basic-deps:
  base: ! '>=4.5 && <4.9'
all-versions:
- '0.1.0'
- '0.1.1'
- '1.0.0.0'
latest: '1.0.0.0'
description-type: haddock
description: ! 'If you have ever had to compose an exception handler for exceptions
  of multiple types,

  you know how frustraiting it can get.

  This library approaches this issue by providing a composable exception handler type,

  which has a Monoid instance.


  Composability means that you can define custom partial handlers and

  reuse them by composing other handlers from them.


  Here is an example of a composable partial handler,

  which only defines what to do in case of a ThreadKilled exception

  (the code uses the LambdaCase extension):


  >ignoreThreadKilled :: PartialHandler ()

  >ignoreThreadKilled =

  >  typed $ \case

  >    ThreadKilled -> Just $ return ()

  >    _ -> Nothing


  Here''s how you can construct a handler of type @SomeException -> IO ()@

  using this library:


  >totalizeRethrowing $

  >  ignoreThreadKilled <>

  >  onAlreadyExists (putStrLn "Already exists")


  and here is how you would do it traditionally (with the MultiWayIf extension):


  >\e -> if

  >  | Just ThreadKilled <- fromException e ->

  >      return ()

  >  | Just e'' <- fromException e, isAlreadyExistsError e'' ->

  >      putStrLn "Already exists"

  >  | otherwise ->

  >      throwIO e


  Putting all the syntactic trickery to make it shorter aside,

  this handler is a monolith block of code.

  Unlike with PartialHandler you can neither decompose it into simpler ones,

  nor compose it with other handlers to form a more complex one.'
