homepage: http://hub.darcs.net/thielema/pathtype/
changelog-type: text
hash: 6c2c3321f84a15ef4928ced66219eda53dd2b3d28a934de8a07113e45f5fd0ce
test-bench-deps:
  base: -any
  pathtype: -any
  random: ! '>=1.0 && <1.2'
maintainer: haskell@henning-thielemann.de, ben@moseley.name
synopsis: Type-safe replacement for System.FilePath etc
changelog: ! "0.7\n---\n* Move absRel and fileDir out of their classes.\n  A problem
  would arise if someone writes\n    import System.Path (AbsRelClass(absRel))\n  He
  would have to replace it by\n    import System.Path (AbsRelClass, absRel)\n\n* Monoid
  instance for Path.RelDir\n  Requires helper classes IsRel, IsDir.\n  IsAbs and IsFile
  added for completeness.\n\n* Declare infix precedences of </>, <.> and <++> such
  that we can write:\n    dir0 </> dir1 </> dir2 </> base <++> \"-foo\" <++> \"-bar\"
  <.> \"tar\" <.> \"gz\"\n  This is similar to the fixities in the 'filepath' package,\n
  \ but differs slightly\n  since in our package paths and extensions have different
  types.\n\n* Import packages 'transformers' and 'utility-ht'\n  that allow for some
  simplifications.\n\n* Deprecate asPath,\n    asRelFile, asRelDir, asAbsFile, asAbsDir,\n
  \   asRelPath, asAbsPath, asFilePath, asDirPath\n\n* Recommended are now the checking
  constructors 'path', maybePath, parsePath,\n    relFile, relDir, absFile, absDir,\n
  \   relPath, absPath, filePath, dirPath\n\n* replace IsString instance for OverloadedStrings\n
  \ by an instance that cannot be implemented.\n\n* getDirectoryContents is no longer
  synonym to relDirectoryContents.\n  Instead it returns the list of all directory
  objects as RelFileOrDir.\n  This is closer to the getDirectoryContents function\n
  \ from the 'directory' package.\n\n* clarify meaning of AbsRel and FileDir tags
  of a path\n\n* clarify meaning of drive-relative paths on Windows\n\n* clarify handling
  of file system links\n\n0.6\n---\n* joinPath: restrict to RelPath and atomic path
  components\n\n* Add type class constraints and restrict types\n  in order to make
  the functions work with the new datatype.\n  E.g. we need to fix the type to FilePath\n
  \ wherever a function requires a non-empty path.\n\n* Add support for MS Windows
  paths with leading drive labels\n\n0.5.5\n-----\n* AbsRelClass, FileDirClass: turn
  into closed-world classes.\n  Strict accordance to PVP would require to bump version
  to 0.6,\n  but since the user cannot write instances of this class,\n  we can hardly
  break code.\n\n* instance {Show, Read} Path now emit and parse valid Haskell expressions\n\n*
  IO.withFile restricted to FilePath\n  This changes API but it should only break
  buggy code.\n\n0.5.4.3\n-------\n* Make test suite static part of the source code,\n
  \ but maintain a program to update the test suite to changed tests.\n\n0.5.4.1\n-------\n*
  Merge git back to darcs, continue on hub.darcs.net\n\n0.5.4\n-----\n* Migrated from
  darcs to git (on GitHub)\n\n0.5.3\n-----\n* Upgrades + changes for GHC 7.6.1 - by
  Ben Millwood\n\n0.5.0\n-----\n* Added System.Path.Windows and System.Path.Posix
  modules. These are modelled on the System.FilePath approach to supporting the two
  styles of path.\n\n0.0.2\n-----\n* Split System.Path.Directory into its own module\n*
  Implemented covers for all the remaining System.Directory functions\n* Renamed 'hasExtension'
  to 'hasAnExtension', and added new 'hasExtension' fn which checks for a given extension\n*
  Renamed the '...FileOrDir...' functions to be 'generic...' (thanks to Neil Mitchell
  for the suggestion!)\n* Added support for OverloadedStrings\n* Renamed the 'mk...'
  unchecked construction functions to 'as...' to better reflect what they do\n* Added:
  makeAbsolute, makeAbsoluteFromCwd, genericMakeAbsolute, genericMakeAbsoluteFromCwd\n*
  Added: mkAbsPath, mkAbsPathFromCwd\n* Added System.Path.IO to cover System.IO\n*
  Made the internal 'Path' type strict\n* Removed 'splitDirectories' as it serves
  no purpose not covered by 'splitPath'\n* Changed behaviour of 'getDirectoryContents'
  to return relative paths\n* Fixed the type of 'setCurrentDirectory'\n\n0.0.1\n-----\nInitial
  Release\n"
basic-deps:
  base: ==4.*
  time: ! '>=1.0 && <2'
  utility-ht: ! '>=0.0.12 && <0.1'
  tagged: ! '>=0.7 && <0.9'
  old-time: ! '>=1.0 && <2'
  transformers: ! '>=0.3 && <0.5'
  deepseq: ! '>=1.3 && <1.5'
  QuickCheck: ! '>=2.1.0.1 && <3'
  directory: ! '>=1 && <1.2'
all-versions:
- '0.0.1'
- '0.0.2'
- '0.0.3'
- '0.5'
- '0.5.1'
- '0.5.2'
- '0.5.3'
- '0.5.4'
- '0.5.4.1'
- '0.5.4.2'
- '0.5.4.3'
- '0.5.5'
- '0.6'
- '0.7'
- '0.7.0.1'
author: Ben Moseley, Ben Millwood, Henning Thielemann
latest: '0.7.0.1'
description-type: haddock
description: ! 'This package provides type-safe access to filepath manipulations.


  "System.Path" is designed to be used instead of "System.FilePath".

  (It is intended to provide versions of functions from that

  module which have equivalent functionality but are more

  typesafe). "System.Path.Directory" is a companion module

  providing a type-safe alternative to "System.Directory".


  The heart of this module is the @''Path'' ar fd@ abstract type which

  represents file and directory paths. The idea is that there are

  two type parameters - the first should be ''Abs'' or ''Rel'',

  and the second ''File'' or ''Dir''. A number of type synonyms are

  provided for common types:


  > type AbsFile     = Path Abs File

  > type RelFile     = Path Rel File

  > type AbsDir      = Path Abs Dir

  > type RelDir      = Path Rel Dir

  >

  > type AbsPath  fd = Path Abs fd

  > type RelPath  fd = Path Rel fd

  > type FilePath ar = Path ar File

  > type DirPath  ar = Path ar Dir


  The type of the ''combine'' (aka ''</>'') function gives the idea:


  > (</>) :: DirPath ar -> RelPath fd -> Path ar fd


  Together this enables us to give more meaningful types to

  a lot of the functions, and (hopefully) catch a bunch more

  errors at compile time.


  You can use the construction functions as follows:


  > f :: Path.RelFile

  > f = relDir "tmp" </> relFile "someFile" <.> "ext"


  or...


  > f :: Path.RelFile

  > f = dirPath "tmp" </> filePath "someFile" <.> "ext"


  or...


  > f :: Path.RelFile

  > f = path "tmp" </> path "someFile" <.> "ext"


  or just...


  > f :: Path.RelFile

  > f = relFile "tmp/someFile.ext"


  The first and the last implementations force the most specific types

  and thus should be prefered.


  Overloaded string literals are no longer supported,

  since this extension is intended for alternative text storage types.

  It would also decrease the type safety

  if you could omit the path type and let the compiler guess its type.


  You will typically want to import as follows:


  > import qualified System.Path.Directory as Dir

  > import qualified System.Path.IO as PathIO

  > import qualified System.Path as Path

  > import System.Path ((</>))


  "System.Path.Generic" provides all functions with the OS as type parameter.

  "System.Path.Posix" and "System.Path.Windows"

  offers only path constructors and destructors

  fixed to the corresponding operating system.

  "System.Path" exports either "System.Path.Posix" or "System.Path.Windows"

  depending on the host system

  and additionally the manipulation functions from "System.Path.Generic".

  This mix should be appropriate for the average use

  and should free the user from writing type annotations.


  The basic API (and properties satisfied) are heavily influenced

  by Neil Mitchell''s "System.FilePath" module.



  Some notes on how to choose proper type parameters:


  The @ar@ and the @fd@ type parameters have quite different meaning.

  The types @Abs@ and @Rel@ refer to a property of the path,

  whereas the type @File@ and @Dir@ refers to a property of a disk object.

  You can decide whether a path is absolute or relative

  by just watching (the beginning of) the path string.

  In contrast to that, you have to access the disk

  in order to check the existence and type of an disk object.

  Even more, the disk object might change at any time,

  e.g. the user might delete a file and create a directory of the same name,

  or the disk object might not exist,

  and the purpose of the path is to create an according file or directory.

  That''s why even if you have a path of type @FilePath ar@,

  every function accessing the file must check

  that the refered object exists and is a file.

  Conversely, there is not much sense in checking the disk object type

  and then chosing the path accordingly.

  Instead, you must choose the path type according

  to what type of disk object your application needs.

  The reality check must be performed

  and is performed by the standard functions

  for every access to the object.

  If an disk object is not of the type required by the path type

  then this is a runtime exception that must be handled at runtime

  but it is not a programming error.


  Sometimes you have to change the type of a path

  as an intermediate step to construct a path for an object of different type.

  E.g. you may convert the path \"pkg\" from @DirPath@ to @FilePath@

  because in the next step you like to extend it to \"pkg.tar.gz\".

  This is valid use of the @Path@ type.

  E.g. the function @dropExtensions@

  reduces the @FilePath@ \"pkg.tar.gz\" to the new @FilePath@ \"pkg\"

  although no-one expects that there is or will be a file with name \"pkg\".

  Thus, if a function has a @FilePath@ parameter

  then there is no warranty that it accesses the according file

  and does not touch related disk objects.

  It may well be that the function derives other file and directory names

  from the path and accesses them.

  That is, a @FilePath@ or @DirPath@ parameter

  is mainly for documentation purposes

  but it cannot prevent you seriously from any damage.


  How to cope with user input?

  You may get a path from the user, e.g. as command-line argument.

  It might be either absolute or relative

  and it might refer to an actual file or directory or

  to something yet non-existing.

  In most cases it will not be important

  whether the path is absolute or relative,

  thus you should choose the @AbsOrRel@ type parameter.

  If somewhere in the program an @Abs@ path is needed

  then you can assert that the path is actually absolutized somewhere

  e.g. by @dynamicMakeAbsolute@.

  If you prevent usage of @genericMakeAbsolute@

  then you avoid to absolutize a path that is already absolutized.


  The choice of the @fd@ type parameter follows a different reasoning:

  Often you have a clear idea of

  whether the user must pass a file or directory path.

  The rule is: Just give the path the type you expect

  but do not perform any checking

  (unless you want to warn the user earlier about imminent danger).

  The disk object type must checked for every access to the object, anyway,

  so there is no point in checking it immediately.

  With your choice of the @fd@ parameter

  you just document its intended use.


  It might be that the path is only a base name

  used to construct other directory and file names.

  E.g. for an Audacity project named @music@

  you have to create the directory @music_data@ and the file @music.aup@.

  In this case we recommend to give @music@ the type @FilePath@.

  This type warrants that there is at least one final path component

  in contrast to a directory path that might be empty.

  You can easily convert a file path to a directory path

  using @Path.dirFromFile@.

  The reverse conversion is partial.



  Some notes on file system links:


  This package does not explicitly handle file system links.

  We treat a file path containing links like any other file path.

  The same holds for directory paths.

  A link is handled like any other path component.



  Some notes on drive-relative paths on Windows:


  We use the @Rel@ type for paths that can be relative to any directory.

  We use the @Abs@ type for all other paths,

  i.e. for paths with explicit locations or

  with restrictions on the set of locations.

  Windows has a notion of drives and

  maintains a current directory for every drive.

  E.g. the path @\"c:text.txt\"@ refers to the current directory of drive @C@.

  Since it cannot be freely combined with other directories

  we treat this path like an absolute path.

  This is consistent with the behaviour of the @filepath@ package.

  E.g. @filepath@ evaluates all of the expressions

  @\"\\\\abs\" \<\/\> \"c:driverel\"@, @\"c:\\\\abs\" \<\/\> \"c:driverel\"@,

  @\"d:\\\\abs\" \<\/\> \"c:driverel\"@ to @\"c:driverel\"@.

  In our package you would have to use @genericMakeAbsolute@

  but we recommend to avoid its use.


  Related packages:


  * @path@: Provides a wrapper type around ''FilePath''

  and maps to functions from @filepath@ package.

  This warrants consistency with @filepath@ functions.

  Requires Template Haskell.


  * @data-filepath@:

  Requires ''Typeable'' and Template Haskell.'
license-name: BSD3
