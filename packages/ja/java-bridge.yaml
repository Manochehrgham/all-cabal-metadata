changelog-type: ''
hash: 544ddc065c1442c47d544a8508dd277edfa5519c0848bd06c902512a0299d42e
synopsis: Bindings to the JNI and a high level interface generator.
changelog: ''
all-versions:
- '0.9'
- '0.99'
- '0.20130602'
- '0.20130606'
- '0.20130606.1'
- '0.20130606.2'
- '0.20130606.3'
latest: '0.20130606.3'
description-type: haddock
description: ! 'This package offers bindings to the

  /Java Native Interface/ and a high level interface

  generator.


  [@low level bindings to the JNI@]

  The low level bindings are located in

  "Foreign.Java.JNI.Safe" and "Foreign.Java.JNI.Unsafe".

  When using these bindings you will have to deal with

  pointers and manage global references manually.


  [@medium level interface@]

  The medium level interface is located in

  "Foreign.Java". It offers an abstraction over the JNI,

  i.e. you will not have to deal with pointers

  explicitly nor do you need to manually do conversions

  between native types and Haskell types.

  Also references will automatically be released by

  the Haskell runtime when no longer needed. You will

  still need to manually lookup classes and methods in

  order to use them.


  [@high level bindings generator@]

  You can also generate high level bindings using the

  tools @j2hs@ and @hs2j@ that come along with this

  package. The tools works in both directions, i.e. you

  can generate glue code to use existing Java libraries

  from within Haskell as well as to use Haskell from

  within Java. This is the most convenient way to deal

  with a Java library.



  >>> INSTALLATION / USAGE


  It should suffice to do @cabal install@ (or

  @cabal install java-bridge@ when installing from

  hackageDB). /You need to have a JDK installed prior to

  installing this library/.


  Setup will try to find the location of your java

  installation automatically. This is needed in order to

  load @libjvm@. Note that this library is loaded

  dynamically, which  means that linking errors might not

  show up during installation.


  You can specify the location of @libjvm@ manually using

  the environment variable @FFIJNI_LIBJVM@. This

  environment variable is consulted by @Setup.hs@ as well

  as by the library each time @libjvm@ is loaded - which

  means that you can override the path to @libjvm@ at any

  time. The function @getCompiledLibjvmPath@ in

  "Foreign.Java.JNI.Safe" will tell you what path to

  @libjvm@ has been set during compilation of the library.



  >>> FUN WITH (cabal-) FLAGS


  The following cabal flags are available to you for

  configuring your installation:


  [@ONLY_CORE@]

  Build only the Core Modules which offer a

  direct binding to the Java Native Interface.

  The core modules are "Foreign.Java.JNI",

  "Foreign.Java.JNI.Safe",

  and "Foreign.Java.JNI.Unsafe".

  This implies @NO_TOOLS@.

  Defaults to @False@.


  [@NO_TOOLS@]

  Do not build the @j2hs@ and @hs2j@ executables.

  Defaults to @False@.


  [@DEBUG@]

  Enable a debug build. Defaults to @False@.


  [@OSX_GUI@]

  Build the library with special support for

  Cocoa on Mac OS X (you will not be able to

  use AWT or Swing without). Defaults to @True@

  on Darwin (OS X).


  [@OSX_FRAMEWORK@]

  Use the JavaVM framework on MacOS X instead

  of loading the dynamic library. Defaults to

  @False@. Enable this flag if building on your

  OS X machine fails. Defaults to @False@.


  [@EXAMPLES@]

  Build a set of examples. They are prefixed

  with @java-@ and located along your haskell

  executables. Defaults to @False@.


  Use for example

  @cabal install -f OSX_FRAMEWORK -f EXAMPLES@

  or @cabal configure -f DEBUG@.



  >>> HACKING


  See @HACKING.txt@ and @ISSUES.txt@ in the tar.gz-package.'
