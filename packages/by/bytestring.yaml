changelog-type: ''
hash: 9da8b942d379eed8dd5659e65fbe0e6c99d0a59fb59aeae6fbcf78ad7d6b02aa
synopsis: Fast, compact, strict and lazy byte strings with a list interface
changelog: ''
all-versions:
- '0.9'
- '0.9.0.1'
- '0.9.0.2'
- '0.9.0.3'
- '0.9.0.4'
- '0.9.1.0'
- '0.9.1.1'
- '0.9.1.2'
- '0.9.1.3'
- '0.9.1.4'
- '0.9.1.5'
- '0.9.1.6'
- '0.9.1.7'
- '0.9.1.8'
- '0.9.1.9'
- '0.9.1.10'
- '0.9.2.0'
- '0.9.2.1'
- '0.10.0.0'
- '0.10.0.1'
- '0.10.0.2'
- '0.10.2.0'
- '0.10.4.0'
- '0.10.4.1'
- '0.10.6.0'
latest: '0.10.6.0'
description-type: haddock
description: ! 'An efficient compact, immutable byte string type (both strict and
  lazy)

  suitable for binary or 8-bit character data.


  The ''ByteString'' type represents sequences of bytes or 8-bit characters.

  It is suitable for high performance use, both in terms of large data

  quantities, or high speed requirements. The ''ByteString'' functions follow

  the same style as Haskell\''s ordinary lists, so it is easy to convert code

  from using ''String'' to ''ByteString''.


  Two ''ByteString'' variants are provided:


  * Strict ''ByteString''s keep the string as a single large array. This

  makes them convenient for passing data between C and Haskell.


  * Lazy ''ByteString''s use a lazy list of strict chunks which makes it

  suitable for I\/O streaming tasks.


  The @Char8@ modules provide a character-based view of the same

  underlying ''ByteString'' types. This makes it convenient to handle mixed

  binary and 8-bit character content (which is common in many file formats

  and network protocols).


  The ''Builder'' module provides an efficient way to build up ''ByteString''s

  in an ad-hoc way by repeated concatenation. This is ideal for fast

  serialisation or pretty printing.


  There is also a ''ShortByteString'' type which has a lower memory overhead

  and can can be converted to or from a ''ByteString'', but supports very few

  other operations. It is suitable for keeping many short strings in memory.


  ''ByteString''s are not designed for Unicode. For Unicode strings you should

  use the ''Text'' type from the @text@ package.


  These modules are intended to be imported qualified, to avoid name clashes

  with "Prelude" functions, e.g.


  > import qualified Data.ByteString as BS'
