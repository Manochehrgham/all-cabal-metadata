homepage: http://github.com/CRogers/should-not-typecheck
changelog-type: ''
hash: 22fb2af896da5d01a5557f2ee05e51c2f36453348f37f923657177f1f67d9397
test-bench-deps:
  base: -any
  hspec: ! '>=2.1'
  HUnit: ! '>=1.2'
  should-not-typecheck: -any
  hspec-expectations: ! '>=0.6'
maintainer: message.me.on@github.com
synopsis: A HUnit/hspec assertion library to verify that an expression does not typecheck
changelog: ''
basic-deps:
  base: ! '>=4.6 && <5'
  HUnit: ! '>=1.2'
all-versions:
- '0.1.0.0'
- '1.0'
author: Callum Rogers
latest: '1.0'
description-type: markdown
description: ! "# should-not-typecheck [![Build Status](https://travis-ci.org/CRogers/should-not-typecheck.svg?branch=master)](https://travis-ci.org/CRogers/should-not-typecheck)\n\n`should-not-typecheck`
  is a Haskell library which allows you to assert that an expression does not typecheck
  in your unit tests. It provides one function, `shouldNotTypecheck :: a -> Assertion`,
  which takes an expression and will fail the test if it typechecks. `shouldNotTypecheck`
  returns an HUnit `Assertion` (so it can be used with both `HUnit` and `hspec`).\n\nAvaliable
  on Hackage as [`should-not-typecheck`](https://hackage.haskell.org/package/should-not-typecheck).\n\n##
  Example (hspec)\n\nThe secret sauce is the [Deferred Type Errors GHC extension](https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/defer-type-errors.html).
  This allows you to write a non-typechecking expression which will throw an exception
  at run time (rather than erroring out at compile time). `shouldNotTypecheck` tries
  to catch that exception and fails the test if no deferred type error is caught.\n\n```haskell\n{-#
  OPTIONS_GHC -fdefer-type-errors #-} -- Very important!\n\nmodule Main where\n\nimport
  Test.Hspec (hspec, describe, it)\nimport Test.ShouldNotTypecheck (shouldNotTypecheck)\n\nmain
  :: IO ()\nmain = hspec $ do\n  describe \"Type Tests\" $ do\n    it \"should not
  allow an Int to be a String\" $\n      shouldNotTypecheck (4 :: String)\n```\n\nIt
  can be used similarly with HUnit.\n\n## Motivation\n\nSometimes you want to ensure
  that it is impossible to type a particular expression. For example, imagine if we
  were making a typesafe Abstract Syntax Tree of mathematical expressions:\n\n```haskell\n{-#
  LANGUAGE GADTs #-}\n\ndata Expr t where\n  IntVal :: Int -> Expr Int\n  BoolVal
  :: Bool -> Expr Bool\n  Add :: Expr Int -> Expr Int -> Expr Int\n  -- ...\n```\n\nWe
  might want to make sure that `Add (BoolVal True) (IntVal 4)` is not well typed.
  However, we can't even compile code like this to put in a unit test! This is where
  `should-not-typecheck` steps in.\n\n## Limitations\n\nUnfortunately, we can only
  turn on deferred type errors for the entire test file rather than just specific
  expressions. This means that any type error will compile but fail at runtime. For
  example:\n\n```haskell\n{-# OPTIONS_GHC -fdefer-type-errors #-}\n\n-- ...\n\nmain
  :: IO ()\nmain = hspec $ do\n  decsribe 4 $ do -- Oops!\n   -- ...\n```\n\nWill
  create a warning at compile time but not an error. All of the ill-typed expressions
  we are testing will also produce warnings and it will hard to immediately see which
  ones matter. The upside is that the test-suite will still fail if there are errors.\n\n###
  Workaround\n\nYou can separate out the ill-typed expressions we are testing and
  test boilerplate into separate files and only turn on deferred type errors for the
  expressions. This means that type errors in test code will still be found at compile
  time. The downside is your tests may now be harder to read.\n"
license-name: BSD3
