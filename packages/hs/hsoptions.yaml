changelog-type: ''
hash: 8585434826cf32636859ec77083363934d9e21286643576cf4208e624e8bd439
synopsis: Haskell library that supports command-line flag processing
changelog: ''
all-versions:
- '1.0.0.0'
latest: '1.0.0.0'
description-type: haddock
description: ! 'Haskell library that supports command-line flag processing.


  Too see an user guide and list of features go to

  <https://github.com/josercruz01/hsoptions#table-of-contents>.


  Flags are declared in the code by using the ''make'' function, which takes the

  flag''s name, help text and type as arguments.


  The flags are parsed from the command line stream of from a file

  if the @--usingFile \<filename\>@ flag is sent to the program.


  Flags can be customized by calling configuration function, such as

  ''defaultIs'' or ''aliasIs'', that change how the flag behaves, how it

  is parsed and validated.


  The ''processMain'' function needs to be called at the beginning of the ''main''

  function. This function takes as arguments:


  * The @program description@


  * A list of @all declared flags@


  * Three callbacks:


  * * @success@


  * * @failure@


  * * @display help@


  If there is any kind of validation error @failure@ is

  called with the list of errors. If the @--help@ flag was sent by the user

  @display help@ is called. Otherwise if there are no problems the @success@

  function is called.


  A default implementation of @failure@ and @display help@ is provided in the

  library (''defaultDisplayHelp'', ''defaultDisplayErrors'') with a basic bahavior.


  Basically @success@ becomes the \''real\'' main function. It takes as argument

  a tuple (''FlagResults'', ''ArgsResults''). ''FlagResults'' is a data structure

  that can be used to query flags by using the ''get'' function. ''ArgsResults'' is

  just an array of ''String'' containing the remaining not-flag arguments.


  A simple example (more in

  <https://github.com/josercruz01/hsoptions/tree/master/examples>)


  > import System.Console.HsOptions

  >

  > userName = make ( "user_name",

  >                 , "the user name of the app",

  >                 , [ parser stringParser,

  >                   , aliasIs ["u"]

  >                   ]

  >                 )

  > userAge = make ("age", "the age of the user", [parser intParser])

  >

  > flagData = combine [flagToData userName, flagToData userAge]

  >

  > main :: IO ()

  > main = processMain "Simple example for HsOptions."

  >                    flagData

  >                    success

  >                    failure

  >                    defaultDisplayHelp

  >

  > success :: ProcessResults -> IO ()

  > success (flags, args) = do let nextAge = (flags `get` userAge) + 5

  >                            putStrLn ("Hello " ++ flags `get` userName)

  >                            putStrLn ("In 5 years you will be " ++

  >                                      show nextAge ++

  >                                      " years old!")

  >

  > failure :: [FlagError] -> IO ()

  > failure errs = do putStrLn "Some errors occurred:"

  >                   mapM_ print errs


  At the ''processMain'' function each of the input flags is validated against the

  declared flags. Within the @success@ function you can be sure that all required

  flags exist, all flag types are correct and all validation was successful.'
