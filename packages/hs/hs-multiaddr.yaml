homepage: https://github.com/MatrixAI/haskell-multiaddr#readme
changelog-type: ''
hash: a5ae7a5a8362bf081d4d0d58f6bcb89d6805efdd774ebf9c4c5257dd6021aec1
test-bench-deps:
  bytestring: -any
  base: -any
  hspec: -any
  multihash: -any
  hs-multiaddr: -any
  either-unwrap: -any
  iproute: -any
  sandi: -any
maintainer: roger.qiu@matrix.ai
synopsis: Multiaddr Library for LibP2P
changelog: ''
basic-deps:
  cereal: -any
  bytestring: -any
  base: ! '>=4.7 && <4.9'
  text: -any
  multihash: -any
  filepath: -any
  io-streams: ! '>=1.2 && <1.3'
  iproute: -any
  optparse-applicative: ! '>=0.11 && <0.12'
  sandi: -any
  bytes: -any
all-versions:
- '0.1.0.0'
author: CMCDragonkai
latest: '0.1.0.0'
description-type: markdown
description: ! 'Matrix Multi Address

  =========================


  Here is an experiment to combine the haskell implementation of Multiaddress with
  the Haskell implementation of Multihash.


  Along the way, we must learn how stack works.


  -- Multiaddr is a record wrapping a list of MultiaddrParts

  -- a Multiaddr here is a typed Multiaddr within Haskell

  -- in the outside world, there are 2 kinds of Multiaddr

  -- a textual human readable version

  -- a binary encoded version

  -- this library exposes the typed Multiaddr

  -- while allowing Multiaddr to be created from

  -- human readable text or binary encoded string


  There is any number of slashes.

'
license-name: BSD3
