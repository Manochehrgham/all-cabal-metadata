homepage: https://github.com/sol/hspec-expectations#readme
changelog-type: ''
hash: 198fe79e9fa03ae663bd1440e7f157b6634e3c7955f810ca423c0dd1d72d7c36
test-bench-deps:
  base: -any
  hspec: ==2.*
  markdown-unlit: -any
  HUnit: -any
  silently: -any
maintainer: Simon Hengel <sol@typeful.net>
synopsis: Catchy combinators for HUnit
changelog: ''
basic-deps:
  base: ==4.*
  HUnit: -any
all-versions:
- '0.3.0'
- '0.3.0.1'
- '0.3.0.2'
- '0.3.0.3'
- '0.3.1'
- '0.3.2'
- '0.3.3'
- '0.4.0'
- '0.5.0'
- '0.5.0.1'
- '0.6.0'
- '0.6.0.1'
- '0.6.1'
- '0.6.1.1'
author: Simon Hengel <sol@typeful.net>
latest: '0.6.1.1'
description-type: text
description: ! "# Catchy combinators for HUnit\n\n(inspired by [ScalaTest's ShouldMatchers](http://www.scalatest.org/))\n\nThe
  three main primitives are `shouldBe`, `shouldSatisfy` and\n`shouldThrow`. They can
  be used with\n[HUnit](http://hackage.haskell.org/package/HUnit), or any framework
  that\nintegrates with HUnit, like\n[test-framework](http://hackage.haskell.org/package/test-framework)
  or\n[Hspec](http://hackage.haskell.org/package/hspec).\n\n## An introductory example\n\nHere
  is an example that uses Hspec. It's a partial specification of\nitself.\n\n~~~ {.haskell
  .literate}\nimport Test.Hspec\nimport Control.Exception\n\nmain :: IO ()\nmain =
  hspec $ do\n  describe \"shouldBe\" $ do\n    it \"asserts equality\" $ do\n      \"foo\"
  `shouldBe` \"foo\"\n\n  describe \"shouldSatisfy\" $ do\n    it \"asserts that a
  predicate holds\" $ do\n      \"bar\" `shouldSatisfy` (not . null)\n\n  describe
  \"shouldThrow\" $ do\n    it \"asserts that an exception is thrown\" $ do\n      evaluate
  (1 `div` 0 :: Int) `shouldThrow` (== DivideByZero)\n~~~\n\n## shouldBe\n\n`shouldBe`
  is just an alias for HUnit's `@?=`.\n\n## shouldSatisfy\n\n`shouldSatisfy` asserts
  that some predicate holds for a given value.\n\n~~~ {.haskell}\n\"bar\" `shouldSatisfy`
  (not . null)\n~~~\n\nIt is similar to HUnit's `assertBool`, but gives a useful error
  message.\n\n    >>> 23 `shouldSatisfy` (> 42)\n    *** Exception: HUnitFailure \"23
  did not satisfy predicate!\"\n\n## shouldReturn\n\n`shouldReturn` asserts that an
  action returns a given value.\n\n~~~ {.haskell}\nlaunchMissiles `shouldReturn` Left
  \"permission error\"\n~~~\n\n## shouldThrow\n\n`shouldThrow` asserts that an exception
  is thrown. The precise nature of\nthat exception is described with a `Selector`.\n\n~~~
  {.haskell}\nerror \"foobar\" `shouldThrow` anyException\n~~~\n\nA `Selector` is
  a predicate, it can simultaneously constrain the type\nand value of an exception.\n\n~~~
  {.haskell}\nthrow DivideByZero `shouldThrow` (== DivideByZero)\n~~~\n\nTo select
  all exceptions of a given type, `const True` can be used.\n\n~~~ {.haskell}\nerror
  \"foobar\" `shouldThrow` (const True :: Selector ErrorCall)\n~~~\n\nFor convenience,
  predefined selectors for some standard exceptions are\nprovided.\n\n~~~ {.haskell}\nerror
  \"foobar\" `shouldThrow` anyErrorCall\n~~~\n\nSome exceptions (like `ErrorCall`)
  have no `Eq` instance, so checking\nfor a specific value requires pattern matching.\n\n~~~
  {.haskell}\nerror \"foobar\" `shouldThrow` (\\e -> case e of\n    ErrorCall \"foobar\"
  -> True\n    _ -> False\n    )\n~~~\n\nFor such exceptions, combinators that construct
  selectors are provided.\nEach combinator corresponds to a constructor; it takes
  the same\narguments, and has the same name (but starting with a lower-case\nletter).\n\n~~~
  {.haskell}\nerror \"foobar\" `shouldThrow` errorCall \"foobar\"\n~~~\n"
license-name: MIT
