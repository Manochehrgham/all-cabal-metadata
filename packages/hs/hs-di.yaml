homepage: https://github.com/Wizek/hs-di#readme
changelog-type: ''
hash: e88548001a4a919e1ba34856fca2c3996984676d3c65272cefedd90ed1d5cf91
test-bench-deps:
  MissingH: -any
  compose-ltr: -any
  base: -any
  time: -any
  hspec: -any
  hs-di: -any
  QuickCheck: -any
  template-haskell: -any
maintainer: 123.wizek@gmail.com
synopsis: Dependency Injection library for Haskell
changelog: ''
basic-deps:
  compose-ltr: -any
  base: ! '>=4.7 && <5'
  template-haskell: -any
all-versions:
- '0.2.0'
- '0.2.1'
author: Milan Nagy
latest: '0.2.1'
description-type: markdown
description: ! "# Haskell Dependency Injection\n\nA promising Dependency Injection
  system for Haskell.\n\n# Why\n\nThe main motivation behind this project is to make
  it very easy to mock dependencies of functions for unit testing, even if they are
  nested many levels deep.\n\nAnother motivation of mine was to find a technique that
  works entirely at compile time, having the following benefits:\n\n- compile-time
  type checking of all dependencies and wether they fit together\n- no run-time performance
  penalty\n- no run-time Dependency Injection related errors\n\n# Example\n\nA motivating
  example:\n\n```haskell\n-- Lib.hs\n{-# language TemplateHaskell #-}\n\nmodule Lib
  where\n\nimport DI\n\ninj\nnoun = \"World\"\n\ninj\nsentence noun = \"Hello \" ++
  noun\n\ninj\nstatement sentence = sentence ++ \"!\"\n```\n\n```haskell\n-- Spec.hs\n{-#
  language TemplateHaskell #-}\n\nimport DI\nimport Lib\n\ninj\nnounMock = \"Dear
  Reader\" \n\nmain = do\n  $(assemble statementD) `shouldBe` \"Hello World!\"\n  $(assemble
  $ override \"noun\" \"nounMock\" $ statementD) `shouldBe` \"Hello Dear Reader!\"\n\n--
  assertion function\nshouldBe = shouldBeF show\nshouldBeF f actual expected | actual
  == expected = putStrLn $ \"OK \" ++ f actual\n                            | otherwise
  \         = error $ \"FAIL \" ++ f actual ++ \" /= \" ++ f expected\n```\n\nWhich
  when executed should output:\n\n```\nOK \"Hello World!\"\nOK \"Hello Dear Reader!\"\n```\n\n*Note:
  `noun` is being overwritten while we are testing `statement`, which is not an immediate
  dependency but rather at the depth of 2.*\n\n# How\n\nIn this project I am trying
  to emulate the manual assembly\nof deeply nested and injected dependencies with
  the help of TemplateHaskell\nand config compile-time dependency graphs.\n\nTo go
  into more details, this is what happens behind the scenes in the above example:\n\n```haskell\nLib.hs:8:1-3:
  Splicing declarations\n    inj\n  ======>\n    nounD = Dep \"noun\" []\n    nounT
  = (noun)\n    nounA = noun\n    nounI = noun\nLib.hs:11:1-3: Splicing declarations\n
  \   inj\n  ======>\n    sentenceD = Dep \"sentence\" [nounD]\n    sentenceT = (sentence,
  nounT)\n    sentenceA = sentence nounA\n    sentenceI = sentence\nLib.hs:14:1-3:
  Splicing declarations\n    inj\n  ======>\n    statementD = Dep \"statement\" [sentenceD]\n
  \   statementT = (statement, sentenceT)\n    statementA = statement sentenceA\n
  \   statementI = statement\n```\n```haskell\nSpec.hs:7:1-3: Splicing declarations\n
  \   inj\n  ======>\n    nounMockD = Dep \"nounMock\" []\n    nounMockT = (nounMock)\n
  \   nounMockA = nounMock\n    nounMockI = nounMock\nSpec.hs:11:5-23: Splicing expression\n
  \   assemble statementD\n  ======>\n    let (statement, (sentence, noun)) = statementT\n
  \   in statement (sentence noun)\nSpec.hs:12:5-54: Splicing expression\n    assemble
  $ override \"noun\" \"nounMock\" $ statementD\n  ======>\n    let (statement, (sentence,
  _)) = statementT\n    in statement (sentence nounMock)\n```\n\nA couple things to
  note:\n\n- You may be wondering what the suffix letters mean in the declarations.\n
  \ \n  You don't have to concern yourself with them, it's part of the internal hidden
  API of the DI framework by design.\n  \n  (If you are curious however, they stand
  for \"Dependency definitions/`Defs`\", \"Tuple\", \"Assembled\", and \"Injectable\",
  respectively.)\n- As you can see, at the end of the day, all this machinery achieves
  pretty much the same what a developer would do by hand: `statement (sentence noun)`\n
  \ \n  The beauty, however, is that this doesn't have to be done by hand, as it would
  become immensly tideous and time-consuming as soon as we start to handle more than
  a couple dependencies.\n- Mocking is equally elegant:\n  \n  `let (statement, (sentence,
  _)) = statementT in statement (sentence nounMock)` \n  \n  (translated from `$(assemble
  $ override \"noun\" \"nounMock\" $ statementD)`)\n\n\n## To try\n\nTo execute and
  experiment with modifying the above example:\n\n```shell\ngit clone git@github.com:Wizek/hs-di.git\ncd
  hs-di/examples/simple\nstack test\n```\n\n### Pros and cons of this approach\n\n
  \ - `(+)` Supports values to be injected\n  - `(+)` Supports functions to be injected\n
  \ - `(++)` Supports overriding of arbitrary number and depth of dependencies\n  -
  `(++)` Compile time type checking (despites strings being used, those too are checked)\n
  \ - `(+)` Supports type variables\n  - `(+)` Theoretically also supports surgically
  only overriding some subsets of dependencies\n\n  - `(+)` Emulates how a human would
  do DI by hand, and does the hard work automatically\n\n  - `(+)` Some module support\n\n
  \   - `(-0.5)` The module support is not yet fully perfect\n\n  - `(?)` How is performance
  impacted? Does GHC notice `f (g x) (g x)`?\n\n### Todos\n\n- [x] TODO: make multiple
  argumetns work\n- [x] TODO: Simplify Deps\n- [x] TODO: reorder arguments of override\n-
  [x] TODO: try with some real-life code\n- [x] TODO: Write quasi quoter or TH splicer
  that writes the `Deps` definitions too\n- [x] TODO: look for a way to have full
  module support (without having to explicitly re-export and risk name-clashes)\n-
  [ ] TODO: have GHC support Dec TH splices in let bindings: https://ghc.haskell.org/trac/ghc/ticket/9880#comment:7\n
  \     Which could make overriding dependencies with mocks more pleasant\n- [ ] TODO:
  have GHC lift stage restriction\n"
license-name: BSD3
