homepage: https://github.com/Wizek/hs-di#readme
changelog-type: ''
hash: 15ce5ca35fabece896007f544a61ee3f88e51b86355f93da20ef870b3dd68f2e
test-bench-deps:
  MissingH: -any
  compose-ltr: -any
  base: -any
  time: -any
  hspec: -any
  hs-di: -any
  QuickCheck: -any
  template-haskell: -any
maintainer: 123.wizek@gmail.com
synopsis: Dependency Injection library for Haskell
changelog: ''
basic-deps:
  compose-ltr: -any
  base: ! '>=4.7 && <5'
  template-haskell: -any
all-versions:
- '0.2.0'
- '0.2.1'
- '0.2.2'
author: Milan Nagy
latest: '0.2.2'
description-type: markdown
description: ! "# Haskell Dependency Injection\n\nA promising Dependency Injection
  system for Haskell.\n\n# Why\n\nThe main motivation behind this project is to make
  it very easy to mock dependencies of functions for unit testing, even if they are
  nested many levels deep.\n\nAnother motivation of mine was to find a technique that
  works entirely at compile time, having the following benefits:\n\n- compile-time
  type checking of all dependencies and whether they fit together\n- no run-time performance
  penalty\n- no run-time Dependency Injection related errors\n\n# Example\n\nA motivating
  example:\n\n```haskell\n-- Lib.hs\n{-# language TemplateHaskell #-}\n\nmodule Lib
  where\n\nimport DI\n\ninj\nnoun = \"World\"\n\ninj\nsentence noun = \"Hello \" ++
  noun\n\ninj\nstatement sentence = sentence ++ \"!\"\n```\n\n```haskell\n-- Spec.hs\n{-#
  language TemplateHaskell #-}\n\nimport DI\nimport Lib\n\ninj\nnounMock = \"Dear
  Reader\" \n\nmain = do\n  $(assemble statementD) `shouldBe` \"Hello World!\"\n  $(assemble
  $ override \"noun\" \"nounMock\" $ statementD) `shouldBe` \"Hello Dear Reader!\"\n\n--
  assertion function\nshouldBe = shouldBeF show\nshouldBeF f actual expected | actual
  == expected = putStrLn $ \"OK \" ++ f actual\n                            | otherwise
  \         = error $ \"FAIL \" ++ f actual ++ \" /= \" ++ f expected\n```\n\nWhich
  when executed should output:\n\n```\nOK \"Hello World!\"\nOK \"Hello Dear Reader!\"\n```\n\n*Observe*:
  In the second assertion, `noun` is being overridden while we are testing `statement`.
  `noun` is not an immediate dependency of `statement` but a dependency at 2 levels
  deep.\n\n# How\n\nIn this project I am trying to emulate the manual assembly\nof
  deeply nested and injected dependencies with the help of TemplateHaskell\nand compile-time
  dependency graphs as configuration.\n\nTo go into more details, this is what happens
  behind the scenes in the above example:\n\n```haskell\nLib.hs:8:1-3: Splicing declarations\n
  \   inj\n  ======>\n    nounD = Dep \"noun\" []\n    nounT = (noun)\n    nounA =
  noun\n    nounI = noun\nLib.hs:11:1-3: Splicing declarations\n    inj\n  ======>\n
  \   sentenceD = Dep \"sentence\" [nounD]\n    sentenceT = (sentence, nounT)\n    sentenceA
  = sentence nounA\n    sentenceI = sentence\nLib.hs:14:1-3: Splicing declarations\n
  \   inj\n  ======>\n    statementD = Dep \"statement\" [sentenceD]\n    statementT
  = (statement, sentenceT)\n    statementA = statement sentenceA\n    statementI =
  statement\n```\n```haskell\nSpec.hs:7:1-3: Splicing declarations\n    inj\n  ======>\n
  \   nounMockD = Dep \"nounMock\" []\n    nounMockT = (nounMock)\n    nounMockA =
  nounMock\n    nounMockI = nounMock\nSpec.hs:11:5-23: Splicing expression\n    assemble
  statementD\n  ======>\n    let (statement, (sentence, noun)) = statementT\n    in
  statement (sentence noun)\nSpec.hs:12:5-54: Splicing expression\n    assemble $
  override \"noun\" \"nounMock\" $ statementD\n  ======>\n    let (statement, (sentence,
  _)) = statementT\n    in statement (sentence nounMock)\n```\n\nA couple things to
  note:\n\n- You may be wondering what the suffix letters mean in the declarations.
  \ \n  You don't have to concern yourself with them, it's part of the internal hidden
  API of the DI framework by design.  \n  (If you are curious however, they stand
  for \"Dependency definitions/`Defs`\", \"Tuple\", \"Assembled\", and \"Injectable\",
  respectively.)  \n- As you can see, at the end of the day, all this machinery achieves
  pretty much the same what a developer would do by hand: `statement (sentence noun)`
  \ \n  The beauty, however, is that this doesn't have to be done by hand, as it would
  become immensly tideous and time-consuming as soon as we start to handle more than
  a couple dependencies.  \n- Mocking is equally elegant:  \n  `let (statement, (sentence,
  _)) = statementT in statement (sentence nounMock)`  \n  (translated from `$(assemble
  $ override \"noun\" \"nounMock\" $ statementD)`)\n\nSee more advanced example below.\n\n##
  To try\n\nTo execute the above example:\n\n```shell\ngit clone git@github.com:Wizek/hs-di.git\ncd
  hs-di/examples/simple\nstack test\n```\n\nYou may also experiment with modifying
  the files in `hs-di/examples/simple` then re-running `stack test` to get an intuitive
  understanding of how this library works.\n\n## More advanced example\n\nWhile the
  following code may not be the most elegant or useful, it at least shows the power
  of dependency injection when it comes to mocking and testing IO code that deals
  with `putStrLn` and `getCurrentTime` in a fully deterministic way.\n\n```haskell\ninj\nmakeTimer
  putStrLn getCurrentTime = liftIO $ do\n  prevTime <- newIORef Nothing\n  return
  $ liftIO $ do\n    pTime <- readIORef prevTime\n    time <- getCurrentTime\n    writeIORef
  prevTime $ Just time\n    case pTime of\n      Nothing -> putStrLn $ show time\n
  \     Just a  -> putStrLn $ show time ++ \", diff: \" ++ (show $ diffUTCTime time
  a)\n```\n\n*source: https://github.com/Wizek/hs-di/blob/v0.2.1/test/NotSoEasyToTestCode.hs#L17-L26*
  \n\n```haskell\nwriteIORef mockConsole []\nwriteIORef cTime $ parseTime \"2016-01-01
  14:00:00\"\ntimer <- $(makeTimerD\n    $> override \"putStrLn\" \"putStrLnMock\"\n
  \   $> override \"getCurrentTime\" \"getCurrentTimeMock\"\n    $> assemble\n  )\n\nwriteIORef
  cTime $ parseTime \"2016-01-01 14:00:00\"\ntimer\nwriteIORef cTime $ parseTime \"2016-01-01
  14:00:01\"\ntimer\nreadMockConsole >>= (`shouldBe`\n  [ \"2016-01-01 14:00:00 UTC\",
  \"2016-01-01 14:00:01 UTC, diff: 1s\"])\n```\n\n*excerpt from: https://github.com/Wizek/hs-di/blob/v0.2.1/test/MainSpec.hs#L95-L149*\n\n###
  Pros and cons of this approach\n\n  - `(+)` Supports values to be injected\n  -
  `(+)` Supports functions to be injected\n  - `(+2)` Supports overriding of arbitrary
  number and depth of dependencies\n  - `(+2)` Compile time type checking (despites
  strings being used, those too are checked)\n  - `(+)` Supports type variables\n
  \ - `(+)` Theoretically also supports surgically only overriding some subsets of
  dependencies\n  - `(+)` Emulates how a human would do DI by hand, and does the hard
  work automatically\n  - `(+)` Some module support\n    - `(-.5)` The module support
  is not yet fully perfect\n    - `(-.5)` Due to limitations of Template Haskell declaration
  splices, \"variable not in scope\" errors can pop up that are annoying. Although
  it is in theory possible to work around these, and it is planned for a later release.\n
  \ - `(?)` How is performance impacted? Does GHC notice `f (g x) (g x)`?\n\n### Todo
  checklist\n\n- [x] make multiple arguments work\n- [x] Simplify Deps\n- [x] reorder
  arguments of override\n- [x] try with some real-life code\n- [x] Write quasi quoter
  or TH splicer that writes the `Deps` definitions too\n- [x] look for a way to have
  full module support (without having to explicitly re-export and risk name-clashes)\n-
  [ ] work around \"variable not in scope\" error by collecting all declarations in
  a splice at the end of the file\n- [ ] have GHC support Dec TH splices in let bindings:
  https://ghc.haskell.org/trac/ghc/ticket/9880#comment:7\n      Which could make overriding
  dependencies with mocks more pleasant\n- [ ] have GHC lift stage restriction\n"
license-name: BSD3
