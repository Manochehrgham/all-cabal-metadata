changelog-type: ''
hash: 7c6ec3be59741418bdc8e70db09c52081b4917d8f51df3df543d84a9bfb3c48d
synopsis: collection of crypto hashes, fast, pure and practical
changelog: ''
all-versions:
- '0.4'
- '0.4.1'
- '0.5'
- '0.5.1'
- '0.5.2'
- '0.5.3'
- '0.6'
- '0.6.1'
- '0.6.2'
- '0.6.3'
- '0.7.0'
- '0.7.1'
- '0.7.2'
- '0.7.3'
- '0.7.4'
- '0.7.5'
- '0.7.6'
- '0.7.7'
- '0.7.8'
- '0.7.9'
- '0.7.10'
- '0.8.0'
- '0.8.1'
- '0.8.2'
- '0.8.3'
- '0.8.4'
- '0.9.0'
- '0.9.1'
- '0.10.0'
- '0.11.0'
- '0.11.1'
- '0.11.2'
- '0.11.3'
- '0.11.4'
- '0.11.5'
- '0.11.6'
latest: '0.11.6'
description-type: haddock
description: ! 'A collection of crypto hashes, with a practical incremental and one-pass,
  pure APIs,

  with performance close to the fastest implementations available in other languages.


  The implementations are made in C with a haskell FFI wrapper that hide the C implementation.


  Simple examples using the unified API:


  > import Crypto.Hash

  >

  > sha1 :: ByteString -> Digest SHA1

  > sha1 = hash

  >

  > hexSha3_512 :: ByteString -> String

  > hexSha3_512 bs = show (hash bs :: Digest SHA3_512)


  Simple examples using the module API:


  > import qualified Crypto.Hash.SHA1 as SHA1

  >

  > main = putStrLn $ show $ SHA1.hash (Data.ByteString.pack [0..255])


  > import qualified Crypto.Hash.SHA3 as SHA3

  >

  > main = putStrLn $ show $ digest

  >   where digest = SHA3.finalize ctx

  >         ctx    = foldl'' SHA3.update iCtx (map Data.ByteString.pack [ [1,2,3],
  [4,5,6] ]

  >         iCtx   = SHA3.init 224'
