changelog-type: ''
hash: 48e2a1fa9f757055d6f303e275fb8d3aa8a1c5684ae829794dce2fbd3db5cfac
test-bench-deps:
  bytestring: -any
  base: ==4.*
  criterion: -any
  HUnit: -any
  tasty-quickcheck: -any
  tasty-hunit: -any
  byteable: -any
  tasty: -any
  QuickCheck: ! '>=2'
  cryptohash: -any
synopsis: collection of crypto hashes, fast, pure and practical
changelog: ''
basic-deps:
  bytestring: -any
  base: ! '>=4 && <6'
  ghc-prim: -any
  byteable: -any
all-versions:
- '0.4'
- '0.4.1'
- '0.5'
- '0.5.1'
- '0.5.2'
- '0.5.3'
- '0.6'
- '0.6.1'
- '0.6.2'
- '0.6.3'
- '0.7.0'
- '0.7.1'
- '0.7.2'
- '0.7.3'
- '0.7.4'
- '0.7.5'
- '0.7.6'
- '0.7.7'
- '0.7.8'
- '0.7.9'
- '0.7.10'
- '0.8.0'
- '0.8.1'
- '0.8.2'
- '0.8.3'
- '0.8.4'
- '0.9.0'
- '0.9.1'
- '0.10.0'
- '0.11.0'
- '0.11.1'
- '0.11.2'
- '0.11.3'
- '0.11.4'
- '0.11.5'
- '0.11.6'
latest: '0.11.6'
description-type: markdown
description: ! "CryptoHash\n==========\n\nhs-cryptohash provides lots of different
  secure digest algorithms, also\ncalled cryptohashes. It exposes every common hashes,
  but also some\nmore exotic hashes, provides an extensive list of hashes available\nwith
  a consistant API.\n\nThe general performance are comparable to the most optimised
  hashes\navailable.\n\nThe complete list of supported hashes:\n\n* MD2, MD4, MD5
  \n* RIPEMD160\n* SHA1\n* SHA-2 family: 224, 256, 384, 512 and the newer 512t\n*
  SHA-3 (aka Keccak)\n* Skein: 256, 512\n* Tiger\n* Whirlpool\n\nYou can easily import
  any hash with the following:\n\n    import qualified Crypto.Hash.<HASH> as <Hash>\n\nsuggestion:
  it's easier to import qualified since there's\na collision with the init symbol,
  but for only importing\nthe hash or hashlazy function there's no such need.\n\nEvery
  hashes, exposes a very similar API.\n\nIncremental API\n---------------\n\nit's
  based on 4 different functions, similar to the lowlevel operations\nof a typical
  hash:\n\n* init: create a new hash context\n* update: update non-destructively a
  new hash context with a strict bytestring\n* updates: same as update, except that
  it takes a list of strict bytestring\n* finalize: finalize the context and returns
  a digest bytestring.\n\nall those operations are completely pure, and instead of
  changing the\ncontext as usual in others language, it re-allocates a new context
  each time.\n\nOne Pass API\n------------\n\nThe one pass API use the incremental
  API under the hood, but expose\ncommon operations to create digests out of a bytestring
  and lazy bytestring.\n\n* hash: create a digest (init+update+finalize) from a strict
  bytestring\n* hashlazy: create a digest (init+update+finalize) from a lazy bytestring\n\nMore
  Type safety\n----------------\n\nA more type safe API is also available from Crypto.Hash.
  The API provides\nall the supported hashes in the same namespace, through unified
  functions.\n\nIt introduces 2 new types, the Context type and the Digest type.\nBoth
  those types are parametrized with the HashAlgorithm used.\n\nThe API is very similar
  to each single hash module, except the types are\nslightly different.\n\n    import
  Crypto.Hash\n\n    -- use the incremental API to hash the byte [1,2,3] with SHA1\n
  \   -- and print the hexadecimal digest.\n    example1 = do\n        let ctx = hashInit\n
  \           ctx' = hashUpdates ctx [ Data.ByteString.pack [1,2,3] ]\n            dgt
  \ = hashFinalize ctx' :: Digest SHA1\n        putStrLn $ show dgt\n\n    -- use
  the one-pass API to hash the byte 1,2,3 with SHA3_512\n    -- and print the hexadecimal
  digest.\n    example2 = do\n        let dgt  = hash (Data.ByteString.pack [1,2,3])
  :: Digest SHA3_512\n        putStrLn $ show dgt\n\nPerformance\n-----------\n\nCryptohash
  uses C implementations to provide maximum performance.\nsee the cbits directory
  for more information\n"
