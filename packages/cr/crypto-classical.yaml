changelog-type: ''
hash: 13ac1e62f7d3ac1d5980513e6702378e3514f847022fc22f286f4284b707a841
test-bench-deps: {}
synopsis: An educational tool for studying classical cryptography schemes.
changelog: ''
basic-deps:
  bytestring: -any
  base: ! '>=4.7 && <4.9'
  text: ! '>=1.2.0.4'
  crypto-numbers: ! '>=0.2.7'
  random-shuffle: ! '>=0.0.4'
  containers: ! '>=0.5.5.1'
  lens: ! '>=4.7'
  crypto-random: -any
  transformers: ! '>=0.4.2.0'
  random: -any
  QuickCheck: ! '>=2.8.1'
  modular-arithmetic: ! '>=1.2.0.0'
all-versions:
- '0.0.1'
- '0.0.2'
- '0.0.3'
- '0.1.0'
latest: '0.1.0'
description-type: haddock
description: ! 'An educational tool for studying classical cryptography

  schemes. Do not encrypt anything of worth with this

  library.


  /Included Ciphers:/


  * Caesar


  * Affine (Linear)


  * Substitution


  * Stream


  * Vigenere


  * Enigma (Wehrmacht Enigma I)


  Thanks to polymorphism, we can generate keys and encrypt

  ByteStrings without worrying much about types:


  > > import Crypto.Classical

  > > import Control.Lens

  > > :set -XOverloadedStrings

  > > (key <$> prng) >>= \k -> return (encrypt k "What a great day for an attack!"
  ^. enigma)

  > "PXQS D KXSGB CFC AYK XJ DEGMON!"

  > > (key <$> prng) >>= \k -> return (encrypt k "What a great day for an attack!"
  ^. caesar)

  > "RCVO V BMZVO YVT AJM VI VOOVXF!"'
