changelog-type: text
hash: e37c92e6337ccbacd95f77938a1d0459f52cdb1a51c920a96610793cf2b5e4dc
test-bench-deps: {}
synopsis: Command line argument processing
changelog: ! "Changelog for CmdArgs\n\n0.10.12\n    GHC 7.2 compatibility\n0.10.11\n
  \   #15, never put [brackets] around optional args in Explicit\n0.10.10\n    #14,
  fix @ file arguments\n0.10.9\n    #10, fix versionArgs (broken in 0.10.8)\n0.10.8\n
  \   Avoid compilation warnings on GHC 7.8\n    #9, add --numeric-version flag\n
  \   Update the copyright year\n    Change GetOpt.usageInfo to be more like GetOpt\n0.10.7\n
  \   #1, fix timestamps in .tar.gz dist file\n0.10.6\n    #625, more documentation
  about args/argPos\n    #626, ensure initial lists don't get reversed (fix after
  #610)\n0.10.5\n    #615, support lists inside a newtype\n0.10.4\n    #610, make
  sure it is O(n) to append arguments, not O(n^2)\n0.10.3\n    Append list items under
  an enum\n    Support &= ignore on enum fields\n0.10.2\n    Relax upper bounds to
  be GHC 7.7 compatible\n0.10.1\n    #569, set the test program to off by default\n\tComplete
  revamp of cmdargs-browser, far better Javascript\n    Add a missing case for Helper
  marshalling FlagNone\n0.10\n    Revert to 0.9.6, including modeExpandAt\n0.9.7\n
  \   Revert to 0.9.5, to fix up PVP breakage\n0.9.6\n    #539, hopefully more fixes
  to compiling in profile mode\n    #522, add modeExpandAt and noAtExpand annotation\n
  \   #522, don't @expand after --\n0.9.5\n    Don't specify TH extension unless quotation
  is true\n0.9.4\n    #539, specify the TH extension in the Cabal file\n    Allow
  transformers 0.3.*\n    Correct copyright in license and cabal file\n0.9.3\n    Add
  expandArgsAt and support for @ flag file directives\n0.9.2\n    Don't build the
  test program if quotation is turned off\n0.9.1\n    Improve the documentation for
  the Explicit module\n    #433, propagate groupname on modes in the Implicit code\n0.9\n
  \   #467, add completions for people running bash\n    #334, add a Quote module,
  to write pure in the impure syntax\n    #482, fix the sample in Explicit, don't
  use def\n    #461, fix the translation for enum/enum_\n    Make showHelp take an
  argument for the prefix bits\n    Add Helper interface, and initial cmdargs-browser
  code\n    Add splitArgs/joinArgs\n0.8\n    #450, redo the manual generator so Maker
  example is not cut off\n    Support all the types in Data.Int/Data.Word\n    Make
  modeArgs take a list of arguments as well\n0.7\n    No changes, just a version bump
  to allow requiring the GHC fix\n0.6.10\n    Change the annotate module to cope better
  with GHC's CSE\n0.6.9\n    #422, support newtype value as the underlying type\n0.6.8\n
  \   Allow versionArgs [summary] to override --version\n    Improve the documentation
  surrounding opt\n    Add modeReform to Mode\n    Add modeEmpty, to construct blank
  Mode values\n    Improve the documentation surrounding pure annotations.\n0.6.7\n
  \   #395, don't put two newlines after --help or --version\n0.6.6\n    #392, support
  helpArgs [groupname \"something\"]\n0.6.5\n    Don't fail with ambiguous enum if
  you exactly match a value\n    Put errors on stderr\n0.6.4\n    Eliminate the filepath
  dependence\n0.6.3\n    Switch mtl for transformers\n0.6.2\n    Build on GHC 7.0
  RC2, add an extra type signature\n    Add verbosityArgs to customise the verbose/quiet
  flags\n    Add helpArg/versionArg flags to customise those flags\n    Support multiline
  summary using \\n escape codes\n0.6.1\n    Build on GHC 6.10, don't rely on record
  name disambiguation\n0.6\n    Add ignore annotation for modes and flags\n    #350,
  make top-level help appear properly\n0.5\n    #351, name/explicit attributes on
  mode were broken (regression)\n0.4\n    #342, display common fields only once\n
  \   Raise errors if annotations are placed in invalid places\n    Rewrite the translation
  of annotation to explicit modes\n    Treat anything after -- as an argument\n    Add
  a pure annotation mechanism\n    Introduce System.Console.CmdArgs.Annotate\n0.3\n
  \   Add a documentation example for the Explicit mode\n    Improve the purity and
  annotations a bit, try disabling CSE\n    Change the help format\n    Rename groupHiden
  to groupHidden, patch from Matthew Cox\n    Bug, missing fields and explicit enums
  didn't work together\n0.2\n    #252, add support for grouped flags/modes\n    #333,
  support missing fields\n    Add support for reading tuple values (including nested)\n
  \   #292, add support for automatic enumerations\n    #221, make argpos work with
  non-string fields\n    #222, support opt and args together\n    #230, different
  modes can share short flags\n    #295, make verbosity flags explicit\n    #231,
  add support for Maybe\n    #256, add --option=false support\n    Complete rewrite
  to introduce Explicit module\n0.1.1\n    Start of changelog\n"
basic-deps:
  base: ! '>=4 && <4.3 || >=4.4 && <5'
  filepath: -any
  process: ! '>=1.0'
  transformers: ! '>=0.2'
  template-haskell: -any
all-versions:
- '0.1'
- '0.2'
- '0.3'
- '0.4'
- '0.5'
- '0.6'
- '0.6.1'
- '0.6.2'
- '0.6.3'
- '0.6.4'
- '0.6.5'
- '0.6.6'
- '0.6.7'
- '0.6.8'
- '0.6.9'
- '0.6.10'
- '0.7'
- '0.8'
- '0.9'
- '0.9.1'
- '0.9.2'
- '0.9.3'
- '0.9.4'
- '0.9.5'
- '0.9.6'
- '0.9.7'
- '0.10'
- '0.10.1'
- '0.10.2'
- '0.10.3'
- '0.10.4'
- '0.10.5'
- '0.10.6'
- '0.10.7'
- '0.10.8'
- '0.10.9'
- '0.10.10'
- '0.10.11'
- '0.10.12'
latest: '0.10.12'
description-type: markdown
description: ! "# CmdArgs: Easy Command Line Processing [![Hackage version](https://img.shields.io/hackage/v/cmdargs.svg?style=flat)](http://hackage.haskell.org/package/cmdargs)
  [![Build Status](http://img.shields.io/travis/ndmitchell/cmdargs.svg?style=flat)](https://travis-ci.org/ndmitchell/cmdargs)\n\n<p>\n\tCmdArgs
  is a Haskell library for defining command line parsers. The two features that make
  it a better choice than the standard <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html\">getopt
  library</a> are:\n</p>\n<ol>\n\t<li>It's very concise to use. The HLint command
  line handling is three times shorter with CmdArgs.</li>\n\t<li>It supports programs
  with multiple modes, such as <a href=\"http://darcs.net\">darcs</a> or <a href=\"http://haskell.org/cabal/\">Cabal</a>.</li>\n</ol>\n<p>\n\tA
  very simple example of a command line processor is:\n</p>\n<pre>\ndata Sample =
  Sample {hello :: String} deriving (Show, Data, Typeable)\n\nsample = Sample{hello
  = def &amp;= help \"World argument\" &amp;= opt \"world\"}\n         &amp;= summary
  \"Sample v1\"\n\nmain = print =&lt;&lt; cmdArgs sample\n</pre>\n<p>\n\tDespite being
  very concise, this processor is already fairly well featured:\n</p>\n<pre>\n$ runhaskell
  Sample.hs --hello=world\nSample {hello = \"world\"}\n\n$ runhaskell Sample.hs --help\nSample
  v1, (C) Neil Mitchell 2009\n\nsample [FLAG]\n\n  -? --help[=FORMAT]  Show usage
  information (optional format)\n  -V --version        Show version information\n
  \ -v --verbose        Higher verbosity\n  -q --quiet          Lower verbosity\n
  \ -h --hello=VALUE    World argument (default=world)\n</pre>\n\n<h2>User Manual</h2>\n\n<p>\n\tThe
  rest of this document explains how to write the \"hello world\" of command line
  processors, then how to extend it with features into a complex command line processor.
  Finally this document gives three samples, which the <tt>cmdargs</tt> program can
  run. The three samples are:\n</p>\n<ol>\n    <li><tt>hlint</tt> - the <a href=\"http://community.haskell.org/~ndm/hlint/\">HLint</a>
  program.</li>\n    <li><tt>diffy</tt> - a program to compare the differences between
  directories.</li>\n    <li><tt>maker</tt> - a make style program.</li>\n</ol>\n<p>\n\tFor
  each example you are encouraged to look at it's source (see the <a href=\"http://community.haskell.org/~ndm/darcs/hlint\">darcs
  repo</a>, or the bottom of this document) and run it (try <tt>cmdargs hlint --help</tt>).
  The HLint program is fairly standard in terms of it's argument processing, and previously
  used the <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html\">System.Console.GetOpt</a>
  library. Using GetOpt required 90 lines and a reasonable amount of duplication.
  Using CmdArgs the code requires 30 lines, and the logic is much simpler.\n</p>\n<h3>Acknowledgements</h3>\n<p>\n\tThanks
  to Kevin Quick for substantial patches, and additional code contributions from Sebastian
  Fischer and Daniel Schoepe.\n</p>\n\n\n<h2>Hello World Example</h2>\n<p>\n\tThe
  following code defines a complete command line argument processor:\n</p>\n\n    {-#
  LANGUAGE DeriveDataTypeable #-}\n    module Sample where\n    import System.Console.CmdArgs\n
  \   \n    data Sample = Sample {hello :: String}\n                  deriving (Show,
  Data, Typeable)\n    \n    sample = Sample{hello = def}\n    \n    main = print
  =<< cmdArgs sample\n\n<p>\n\tTo use the CmdArgs library there are three steps:\n</p>\n<ol>\n\t<li>Define
  a record data type (<tt>Sample</tt>) that contains a field for each argument. This
  type needs to have instances for <tt>Show</tt>, <tt>Data</tt> and <tt>Typeable</tt>.</li>\n\t<li>Give
  a value of that type (<tt>sample</tt>) with default values (<tt>def</tt> is a default
  value of any type, but I could also have written <tt>\"\"</tt>). This value is turned
  into a command line by calling the <tt>cmdArgs</tt> function.</li>\n</ol>\n<p>\n\tNow
  we have a reasonably functional command line argument processor. Some sample interactions
  are:\n</p>\n<pre>\n$ runhaskell Sample.hs --hello=world\nSample {hello = \"world\"}\n\n$
  runhaskell Sample.hs --version\nThe sample program\n\n$ runhaskell Sample.hs --help\nThe
  sample program\n\nsample [OPTIONS]\n\n  -? --help        Display help message\n
  \ -V --version     Print version information\n  -h --hello=ITEM\n</pre>\n<p>\n\tCmdArgs
  uses defaults to automatically infer a command line parser for a value, and provides
  annotations to override any of the the defaults. CmdArgs automatically supports
  <tt>--help</tt> and <tt>--version</tt> flags, and optionally supports verbosity
  flags.\n</p>\n\n<h2>Specifying Attributes</h2>\n<p>\n\tIn order to control the behaviour
  we can add attributes. For example to add an attribute specifying the help text
  for the <tt>--hello</tt> argument we can write:\n</p>\n<pre>\nsample = Sample{hello
  = def &= help \"Who to say hello to\"}\n</pre>\n<p>\n\tWe can add additional attributes,
  for example to specify the type of the value expected by hello:\n</p>\n<pre>\nsample
  = Sample {hello = def &= help \"Who to say hello to\" &= typ \"WORLD\"}\n</pre>\n<p>\n\tNow
  when running <tt>--help</tt> the final line is:\n</p>\n<pre>\n  -h --hello=WORLD
  \ Who to say hello to\n</pre>\n<p>\n\tThere are many more attributes, detailed in
  the <a href=\"http://hackage.haskell.org/packages/archive/cmdargs/latest/doc/html/System-Console-CmdArgs.html#2\">Haddock
  documentation</a>.\n</p>\n\n\n<h2>Multiple Modes</h2>\n<p>\n\tTo specify a program
  with multiple modes, similar to <a href=\"http://darcs.net/\">darcs</a>, we can
  supply a data type with multiple constructors, for example:\n</p>\n\n    \n    data
  Sample = Hello {whom :: String}\n                | Goodbye\n                  deriving
  (Show, Data, Typeable)\n    \n    hello = Hello{whom = def}\n    goodbye = Goodbye\n
  \   \n    main = print =<< cmdArgs (modes [hello,goodbye])\n\n<p>\n\tCompared to
  the first example, we now have multiple constructors, and a sample value for each
  constructor is passed to <tt>cmdArgs</tt>. Some sample interactions with this command
  line are:\n</p>\n<pre>\n$ runhaskell Sample.hs hello --whom=world\nHello {whom =
  \"world\"}\n\n$ runhaskell Sample.hs goodbye\nGoodbye\n\n$ runhaskell Sample.hs
  --help\nThe sample program\n\nsample [OPTIONS]\n\n Common flags\n  -? --help       Display
  help message\n  -V --version    Print version information\n\nsample hello [OPTIONS]\n\n
  \ -w --whom=ITEM\n\nsample goodbye [OPTIONS]\n</pre>\n<p>\n\tAs before, the behaviour
  can be customised using attributes.\n</p>\n\n<h2>Larger Examples</h2>\n\n<p>\n\tFor
  each of the following examples we first explain the purpose of the program, then
  give the source code, and finally the output of <tt>--help=HTML</tt>. The programs
  are intended to show sample uses of CmdArgs, and are available to experiment with
  through <tt>cmdargs <i>progname</i></tt>.\n</p>\n\n<h3>HLint</h3>\n\n<p>\n\tThe
  <a href=\"http://community.haskell.org/~ndm/hlint/\">HLint</a> program analyses
  a list of files, using various options to control the analysis. The command line
  processing is simple, but a few interesting points are:\n</p>\n<ul>\n\t<li>The <tt>--report</tt>
  flag can be used to output a report in a standard location, but giving the flag
  a value changes where the file is output.</li>\n\t<li>The <tt>color</tt> field is
  assigned two flag aliases, <tt>--colour</tt> and <tt>-c</tt>. Assigning the <tt>-c</tt>
  short flag explicitly stops either of the CPP fields using it.</li>\n\t<li>The <tt>show_</tt>
  field would clash with <tt>show</tt> if given the expected name, but CmdArgs automatically
  strips the trailing underscore.</li>\n\t<li>The <tt>cpp_define</tt> field has an
  underscore in it's name, which is transformed into a hyphen for the flag name.</li>\n</ul>\n\n<!--
  BEGIN code hlint -->\n<pre>\n{-# LANGUAGE DeriveDataTypeable #-}\nmodule HLint where\nimport
  System.Console.CmdArgs\n\ndata HLint = HLint\n    {report :: [FilePath]\n    ,hint
  :: [FilePath]\n    ,color :: Bool\n    ,ignore_ :: [String]\n    ,show_ :: Bool\n
  \   ,extension :: [String]\n    ,language :: [String]\n    ,utf8 :: Bool\n    ,encoding
  :: String\n    ,find :: [FilePath]\n    ,test_ :: Bool\n    ,datadir :: [FilePath]\n
  \   ,cpp_define :: [String]\n    ,cpp_include :: [FilePath]\n    ,files :: [FilePath]\n
  \   }\n    deriving (Data,Typeable,Show,Eq)\n\nhlint = HLint\n    {report = def
  &= opt \"report.html\" &= typFile &= help \"Generate a report in HTML\"\n    ,hint
  = def &= typFile &= help \"Hint/ignore file to use\"\n    ,color = def &= name \"c\"
  &= name \"colour\" &= help \"Color the output (requires ANSI terminal)\"\n    ,ignore_
  = def &= typ \"MESSAGE\" &= help \"Ignore a particular hint\"\n    ,show_ = def
  &= help \"Show all ignored ideas\"\n    ,extension = def &= typ \"EXT\" &= help
  \"File extensions to search (defaults to hs and lhs)\"\n    ,language = def &= name
  \"X\" &= typ \"LANG\" &= help \"Language extension (Arrows, NoCPP)\"\n    ,utf8
  = def &= help \"Use UTF-8 text encoding\"\n    ,encoding = def &= typ \"ENC\" &=
  help \"Choose the text encoding\"\n    ,find = def &= typFile &= help \"Find hints
  in a Haskell file\"\n    ,test_ = def &= help \"Run in test mode\"\n    ,datadir
  = def &= typDir &= help \"Override the data directory\"\n    ,cpp_define = def &=
  typ \"NAME[=VALUE]\" &= help \"CPP #define\"\n    ,cpp_include = def &= typDir &=
  help \"CPP include path\"\n    ,files = def &= args &= typ \"FILES/DIRS\"\n    }
  &=\n    verbosity &=\n    help \"Suggest improvements to Haskell source code\" &=\n
  \   summary \"HLint v0.0.0, (C) Neil Mitchell\" &=\n    details [\"Hlint gives hints
  on how to improve Haskell code\",\"\"\n            ,\"To check all Haskell files
  in 'src' and generate a report type:\",\"  hlint src --report\"]\n\nmode = cmdArgsMode
  hlint\n</pre>\n\n    HLint v0.0.0, (C) Neil Mitchell\n    \n    hlint [OPTIONS]
  [FILES/DIRS]\n    Suggest improvements to Haskell source code\n    \n    Common
  flags:\n      -r --report[=FILE]\t        Generate a report in HTML\n      -h --hint=FILE\t
  \           Hint/ignore file to use\n      -c --colour --color\t        Color the
  output (requires ANSI terminal)\n      -i --ignore=MESSAGE\t        Ignore a particular
  hint\n      -s --show                     Show all ignored ideas\n         --extension=EXT
  \           File extensions to search (defaults to hs and lhs)\n      -X --language=LANG\t
  \       Language extension (Arrows, NoCPP)\n      -u --utf8\t                    Use
  UTF-8 text encoding\n         --encoding=ENC\t            Choose the text encoding\n
  \     -f --find=FILE\t            Find hints in a Haskell file\n      -t --test\t
  \                   Run in test mode\n      -d --datadir=DIR\t            Override
  the data directory\n         --cpp-define=NAME[=VALUE]  CPP #define\n         --cpp-include=DIR\t
  \       CPP include path\n      -? --help\t                    Display help message\n
  \     -V --version\t                Print version information\n      -v --verbose\t
  \               Loud verbosity\n      -q --quiet\t                Quiet verbosity\n
  \   \n    Hlint gives hints on how to improve Haskell code\n    \n    To check all
  Haskell files in 'src' and generate a report type:\n      hlint src --report\n\t\n\n<h3>Diffy</h3>\n\n<p>\n\tThe
  Diffy sample is a based on the idea of creating directory listings and comparing
  them. The tool can operate in two separate modes, <tt>create</tt> or <tt>diff</tt>.
  This sample is fictional, but the ideas are drawn from a real program. A few notable
  features:\n</p>\n<ul>\n\t<li>There are multiple modes of execution, creating and
  diffing.</li>\n\t<li>The diff mode takes exactly two arguments, the old file and
  the new file.</li>\n\t<li>Default values are given for the <tt>out</tt> field, which
  are different in both modes.</li>\n</ul>\n\n<!-- BEGIN code diffy -->\n<pre>\n{-#
  LANGUAGE DeriveDataTypeable #-}\nmodule Diffy where\nimport System.Console.CmdArgs\n\ndata
  Diffy = Create {src :: Maybe FilePath, out :: FilePath}\n           | Diff {old
  :: FilePath, new :: FilePath, out :: FilePath}\n             deriving (Data,Typeable,Show,Eq)\n\noutFlags
  x = x &= help \"Output file\" &= typFile\n\ncreate = Create\n    {src = def &= help
  \"Source directory\" &= typDir\n    ,out = outFlags \"ls.txt\"\n    } &= help \"Create
  a fingerprint\"\n\ndiff = Diff\n    {old = def &= typ \"OLDFILE\" &= argPos 0\n
  \   ,new = def &= typ \"NEWFILE\" &= argPos 1\n    ,out = outFlags \"diff.txt\"\n
  \   } &= help \"Perform a diff\"\n\nmode = cmdArgsMode $ modes [create,diff] &=
  help \"Create and compare differences\" &= program \"diffy\" &= summary \"Diffy
  v1.0\"\n</pre>\n<!-- END -->\n<!-- BEGIN help diffy -->\n\tDiffy v1.0\n\t \n\tdiffy
  [COMMAND] ... [OPTIONS]\n\t  Create and compare differences\n\t \n\tCommon flags:\n\t
  \ -o --out=FILE\t Output file\n\t  -? --help\t     Display help message\n\t  -V
  --version\t Print version information\n\t \n\tdiffy create [OPTIONS]\n\t  Create
  a fingerprint\n\t \n\t  -s  --src=DIR  Source directory\n\t \n\tdiffy diff [OPTIONS]
  OLDFILE NEWFILE\n\t  Perform a diff\n\n<!-- END -->\n\n<h3>Maker</h3>\n\n<p>\n\tThe
  Maker sample is based around a build system, where we can either build a project,
  clean the temporary files, or run a test. Some interesting features are:\n</p>\n<ul>\n\t<li>The
  build mode is the default, so <tt>maker</tt> on it's own will be interpretted as
  a build command.</li>\n\t<li>The build method is an enumeration.</li>\n\t<li>The
  <tt>threads</tt> field is in two of the constructors, but not all three. It is given
  the short flag <tt>-j</tt>, rather than the default <tt>-t</tt>.</li>\n</ul>\n\n\n<!--
  BEGIN code maker -->\n<pre>\n{-# LANGUAGE DeriveDataTypeable #-}\nmodule Maker where\nimport
  System.Console.CmdArgs\n\ndata Method = Debug | Release | Profile\n              deriving
  (Data,Typeable,Show,Eq)\n\ndata Maker\n    = Wipe\n    | Test {threads :: Int, extra
  :: [String]}\n    | Build {threads :: Int, method :: Method, files :: [FilePath]}\n
  \     deriving (Data,Typeable,Show,Eq)\n\nthreadsMsg x = x &= help \"Number of threads
  to use\" &= name \"j\" &= typ \"NUM\"\n\nwipe = Wipe &= help \"Clean all build objects\"\n\ntest_
  = Test\n    {threads = threadsMsg def\n    ,extra = def &= typ \"ANY\" &= args\n
  \   } &= help \"Run the test suite\"\n\nbuild = Build\n    {threads = threadsMsg
  def\n    ,method = enum\n        [Release &= help \"Release build\"\n        ,Debug
  &= help \"Debug build\"\n        ,Profile &= help \"Profile build\"]\n    ,files
  = def &= args\n    } &= help \"Build the project\" &= auto\n\nmode = cmdArgsMode
  $ modes [build,wipe,test_] &= help \"Build helper program\" &= program \"maker\"
  &= summary \"Maker v1.0\\nMake it\"\n</pre>\n<!-- END -->\n<!-- BEGIN help maker
  -->\n    Maker v1.0\n      Make it\n     \n    maker [COMMAND] ... [OPTIONS]\n      Build
  helper program\n     \n    Common flags:\n      -? --help     Display help message\n
  \     -V --version  Print version information\n     \n    maker [build] [OPTIONS]
  [ITEM]\n      Build the project\n     \n      -j --threads=NUM  Number of threads
  to use\n      -r --release      Release build\n      -d --debug        Debug build\n
  \     -p --profile      Profile build\n     \n    maker wipe [OPTIONS]\n      Clean
  all build objects\n     \n    maker test [OPTIONS] [ANY]\n      Run the test suite\n
  \    \n      -j --threads=NUM  Number of threads to use\n<!-- END -->\n"
