changelog-type: ''
hash: 6dd25c7bfe6dd2cd49c6bc68825fa8f5aa91a6522a38404f4a082b942671f4bf
test-bench-deps: {}
synopsis: Interpolate JSON object values into SQL strings
changelog: ''
basic-deps:
  bytestring: -any
  base: ! '>=4.6 && <4.8'
  unordered-containers: -any
  text: ! '>=1.1.0.0'
  string-qq: -any
  HUnit: -any
  containers: -any
  attoparsec: ! '>=0.10.4.0'
  optparse-applicative: -any
  scientific: -any
  aeson: ! '>=0.8.0.1'
  vector: ! '>=0.10.9.0'
all-versions:
- '0.1.0.1'
latest: '0.1.0.1'
description-type: markdown
description: ! "# jsonsql\n\nInterpolates JSON data into SQL strings from the command
  line. For generating\nSQL statements to pass to DB client programs like `psql`,
  `mysql`, and\n`sqlite3` via Unix pipelines or shell scripts. A faster, lighter-weight\nalternative
  to writing ad-hoc, monolithic programs with database and ORM\nlibraries. \n\nA template
  file with this interpolation syntax:\n\n    INSERT into titles (title, year, rating,
  created) \n    VALUES (:title, :year, :ratings.imdb, DEFAULT);\n\ncombined with
  this JSON stream on STDIN\n\n```json\n{\n  \"title\": \"Terminator 2: 'Judgment
  Day'\",\n  \"year\": 1991,\n  \"stars\": [\n    {\"name\": \"Arnold Schwarzenegger\"},\n
  \   {\"name\": \"Linda Hamilton\"}\n  ],\n  \"ratings\": {\n    \"imdb\": 8.5\n
  \ },\n  \"created\": \"2014-12-04T10:10:10Z\"\n  \n}\n{\n  \"title\": \"Interstellar\",\n
  \ \"year\": 2014,\n  \"stars\": [\n    {\"name\":\"Matthew McConaughey\"},\n    {\"name\":\"Anne
  Hathaway\"}\n  ],\n  \"ratings\": {\n    \"imdb\": 8.9\n  }\n}\n```\n\ngenerates
  this output:\n\n    INSERT into titles (title, year, rating, created)\n    VALUES
  ('Terminator 2: ''Judgment Day''', 1991, 8.5, DEFAULT);\n    INSERT into titles
  (title, year, rating, created)\n    VALUES ('Interstellar', 2014, 8.9, DEFAULT);\n\n##
  Usage\n\n\n```\njsonsql\n\nUsage: jsonsql (TEMPLATE | -f FILE)\n  Inject JSON into
  SQL template strings\n\nAvailable options:\n  -h,--help                Show this
  help text\n  -f FILE                  Template file\n```\n\n## Array joining\n\nIf
  a key path evaluates to an array of values, the values are converted\ninto strings,
  joined by a delimiter, and then output as a string. The\ndefault delimiter is a
  comma:\n\n```\nINSERT into titles (title, year, rating, stars, created) \nVALUES
  (:title, :year, :ratings.imdb, :stars.name, DEFAULT);\n```\n\n```\nINSERT into titles
  (title, year, rating, stars, created)\nVALUES ('Terminator 2: ''Judgment Day''',
  1991, 8.5, 'Arnold Schwarzenegger,Linda Hamilton', DEFAULT);\nINSERT into titles
  (title, year, rating, stars, created)\nVALUES ('Interstellar', 2014, 8.9, 'Matthew
  McConaughey,Anne Hathaway', DEFAULT);\n```\n\nA key path that terminates in an array
  can be followed by an array formatting expression:\n\n```\n{delimiter-string!prefix-sring!postfix-string}\n```\n\n\ntemplate:\n```\nINSERT
  into titles (title, year, rating, stars, created) \nVALUES (:title, :year, :ratings.imdb,
  :stars.name{;!$!$}, DEFAULT);\n```\n\noutput:\n```\nINSERT into titles (title, year,
  rating, stars, created)\nVALUES ('Terminator 2: ''Judgment Day''', 1991, 8.5, '$Arnold
  Schwarzenegger$;$Linda Hamilton$', DEFAULT);\nINSERT into titles (title, year, rating,
  stars, created)\nVALUES ('Interstellar', 2014, 8.9, '$Matthew McConaughey$;$Anne
  Hathaway$', DEFAULT);\n```\n\nAdding a prefix and postfix may be useful if you want
  to mark strings\nfor downstream pipeline processing with tools like `sed` before
  reaching\nthe database.\n\nThe usefulness of this feature may be obscure. But the
  author needed it to\nchange an array of strings like `[\"apple\",\"banana\",\"pear\"]`
  into a string field\ncontaining a series of integer IDs like `'1,2,3'`. This type
  of field was then \nindexed by the Sphinx search engine in a multi-valued attribute.\n\n##
  Author\n\n* Daniel Choi <dhchoi@gmail.com>\n"
