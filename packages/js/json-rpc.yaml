homepage: https://github.com/xenog/json-rpc
changelog-type: ''
hash: 6036fab9f7dbf575a837a9a1e68a9db34761960c54f110c4a7112e84f7eb1a99
test-bench-deps:
  bytestring: ! '>=0.10 && <0.11'
  test-framework: ! '>=0.8 && <0.9'
  stm: ! '>=2.4 && <2.5'
  base: ! '>=4.6 && <5'
  unordered-containers: ! '>=0.2 && <0.3'
  text: ! '>=0.11 && <1.3'
  test-framework-quickcheck2: ! '>=0.3 && <0.4'
  conduit: ! '>=1.2 && <1.3'
  stm-conduit: ! '>=2.5 && <2.7'
  json-rpc: -any
  mtl: ! '>=2.1 && <2.3'
  lifted-async: ! '>=0.7 && <0.8'
  monad-logger: ! '>=0.3 && <0.4'
  QuickCheck: ! '>=2.6 && <2.9'
  aeson: ! '>=0.7 && <0.10'
maintainer: root@haskoin.com
synopsis: Fully-featured JSON-RPC 2.0 library
changelog: ''
basic-deps:
  bytestring: ! '>=0.10 && <0.11'
  stm: ! '>=2.4 && <2.5'
  base: ! '>=4.6 && <5'
  unordered-containers: ! '>=0.2 && <0.3'
  text: ! '>=0.11 && <1.3'
  monad-control: ! '>=0.3 && <1.1'
  conduit: ! '>=1.2 && <1.3'
  stm-conduit: ! '>=2.5 && <2.7'
  conduit-extra: ! '>=1.1 && <1.2'
  mtl: ! '>=2.1 && <2.3'
  lifted-async: ! '>=0.7 && <0.8'
  hashable: ! '>=1.1 && <1.3'
  monad-logger: ! '>=0.3 && <0.4'
  attoparsec: ! '>=0.11'
  transformers: ! '>=0.3'
  deepseq: ! '>=1.3 && <1.5'
  QuickCheck: ! '>=2.6 && <2.9'
  aeson: ! '>=0.7 && <0.10'
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.1.0.2'
- '0.1.0.3'
- '0.1.0.4'
- '0.1.0.5'
- '0.2.0.0'
- '0.2.0.1'
- '0.2.0.2'
- '0.2.1.0'
- '0.2.1.1'
- '0.2.1.2'
- '0.2.1.4'
- '0.2.1.5'
- '0.2.1.6'
- '0.3.0.0'
- '0.3.0.1'
- '0.3.0.2'
- '0.4.0.0'
- '0.5.0.0'
author: Jean-Pierre Rupp
latest: '0.5.0.0'
description-type: markdown
description: ! "json-rpc\n========\n\nFully-featured JSON-RPC 2.0 library for Haskell
  programs.\n\nThis JSON-RPC library is fully-compatible with JSON-RPC 2.0 and 1.0.
  It\nprovides an interface that combines a JSON-RPC client and server. It can\nset
  and keep track of request ids to parse responses.  There is support\nfor sending
  and receiving notifications. You may use any underlying\ntransport.  Basic TCP client
  and server provided.\n\nA JSON-RPC application using this interface is considered
  to be\npeer-to-peer, as it can send and receive all types of JSON-RPC message\nindependent
  of whether it originated the connection.\n\n[Hackage documentation](http://hackage.haskell.org/package/json-rpc)\n\n\nServer
  Example\n--------------\n\nThis JSON-RPC server returns the current time.\n\n```
  haskell\n{-# LANGUAGE OverloadedStrings #-}\nimport Control.Applicative\nimport
  Control.Monad.Trans\nimport Control.Monad.Logger\nimport Data.Aeson.Types hiding
  (Error)\nimport Data.Conduit.Network\nimport Data.Time.Clock\nimport Data.Time.Format\nimport
  Network.JsonRpc\nimport System.Locale\n\ndata TimeReq = TimeReq\ndata TimeRes =
  TimeRes { timeRes :: UTCTime }\n\ninstance FromRequest TimeReq where\n    parseParams
  \"time\" = Just $ const $ return TimeReq \n    parseParams _ = Nothing\n\ninstance
  ToJSON TimeRes where\n    toJSON (TimeRes t) = toJSON $ formatTime defaultTimeLocale
  \"%c\" t\n\nrespond :: (Functor m, MonadLoggerIO m) => Respond TimeReq m TimeRes\nrespond
  TimeReq = Right . TimeRes <$> liftIO getCurrentTime\n\nmain :: IO ()\nmain = runStderrLoggingT
  $\n    jsonRpcTcpServer V2 (serverSettings 31337 \"::1\") respond dummySrv\n```\n\nClient
  Example\n--------------\n\nCorresponding TCP client to get time from server.\n\n```
  haskell\n{-# LANGUAGE OverloadedStrings #-}\nimport Control.Concurrent\nimport Control.Monad\nimport
  Control.Monad.Trans\nimport Control.Monad.Logger\nimport Data.Aeson\nimport Data.Aeson.Types
  hiding (Error)\nimport Data.Conduit.Network\nimport qualified Data.Text as T\nimport
  Data.Time.Clock\nimport Data.Time.Format\nimport Network.JsonRpc\nimport System.Locale\n\ndata
  TimeReq = TimeReq\ndata TimeRes = TimeRes { timeRes :: UTCTime }\n\ninstance ToRequest
  TimeReq where\n    requestMethod TimeReq = \"time\"\n\ninstance ToJSON TimeReq where\n
  \   toJSON TimeReq = emptyArray\n\ninstance FromResponse TimeRes where\n    parseResult
  \"time\" = Just $ withText \"time\" $ \\t -> case f t of\n        Just t' -> return
  $ TimeRes t'\n        Nothing -> mzero\n      where\n        f t = parseTime defaultTimeLocale
  \"%c\" (T.unpack t)\n    parseResult _ = Nothing\n\nreq :: MonadLoggerIO m => JsonRpcT
  m UTCTime\nreq = sendRequest TimeReq >>= \\ts -> case ts of\n    Left e -> error
  $ fromError e\n    Right (Just (TimeRes r)) -> return r\n    _ -> error \"Could
  not parse response\"\n\nmain :: IO ()\nmain = runStderrLoggingT $\n    jsonRpcTcpClient
  V2 (clientSettings 31337 \"::1\") dummyRespond .\n        replicateM_ 4 $ req >>=
  liftIO . print >> liftIO (threadDelay 1000000)\n```\n"
license-name: PublicDomain
