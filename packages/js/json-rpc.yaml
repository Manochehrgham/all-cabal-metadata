homepage: https://github.com/xenog/json-rpc
changelog-type: ''
hash: b7ba258c0c591911badba17b45678236b38834aedd6bd3eda92523e7dca22cc5
test-bench-deps:
  bytestring: ! '>=0.10 && <0.11'
  test-framework: ! '>=0.8 && <0.9'
  stm: ! '>=2.4 && <2.5'
  base: ! '>=4.6 && <5'
  unordered-containers: ! '>=0.2 && <0.3'
  text: ! '>=0.11 && <1.3'
  test-framework-quickcheck2: ! '>=0.3 && <0.4'
  async: ! '>=2.0 && <2.1'
  conduit: ! '>=1.2 && <1.3'
  stm-conduit: ! '>=2.5 && <2.6'
  conduit-extra: ! '>=1.1 && <1.2'
  json-rpc: ! '>=0.2 && <0.3'
  mtl: ! '>=2.1 && <2.3'
  hashable: ! '>=1.1 && <1.3'
  deepseq: ! '>=1.3 && <1.4'
  QuickCheck: ! '>=2.6 && <2.8'
  aeson: ! '>=0.7 && <0.9'
maintainer: root@haskoin.com
synopsis: Fully-featured JSON-RPC 2.0 library
changelog: ''
basic-deps:
  bytestring: ! '>=0.10 && <0.11'
  stm: ! '>=2.4 && <2.5'
  base: ! '>=4.6 && <5'
  unordered-containers: ! '>=0.2 && <0.3'
  text: ! '>=0.11 && <1.3'
  async: ! '>=2.0 && <2.1'
  conduit: ! '>=1.2 && <1.3'
  stm-conduit: ! '>=2.5 && <2.6'
  conduit-extra: ! '>=1.1 && <1.2'
  mtl: ! '>=2.1 && <2.3'
  hashable: ! '>=1.1 && <1.3'
  attoparsec: ! '>=0.11'
  transformers: ! '>=0.3'
  deepseq: ! '>=1.3 && <1.4'
  aeson: ! '>=0.7 && <0.9'
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.1.0.2'
- '0.1.0.3'
- '0.1.0.4'
- '0.1.0.5'
- '0.2.0.0'
- '0.2.0.1'
- '0.2.0.2'
- '0.2.1.0'
- '0.2.1.1'
- '0.2.1.2'
- '0.2.1.4'
- '0.2.1.5'
- '0.2.1.6'
author: Jean-Pierre Rupp
latest: '0.2.1.6'
description-type: markdown
description: ! "json-rpc\n========\n\nFully-featured JSON-RPC 2.0 library for Haskell
  programs.\n\nThis JSON-RPC library is fully-compatible with JSON-RPC 2.0 and\npartially-compatible
  with JSON-RPC 1.0. It provides an interface that combines\na JSON-RPC client and
  server. It can set and keep track of request ids to parse\nresponses. There is support
  for sending and receiving notifications. You may\nuse any underlying transport.
  Basic TCP client and server provided.\n\nThe recommended interface to this library
  is provided as conduits that encode\noutgoing messages, and decode incoming messages.
  Incoming messages are\ndelivered as an IncomingMsg data structure, while outgoing
  messages are sent in\na Message data structure. The former packs responses and errors
  with their\ncorresponding request, and has a separate constructor for decoding errors.\n\nA
  JSON-RPC application using this interface is considered to be peer-to-peer,\nas
  it can send and receive all types of JSON-RPC message independent of whether\nit
  originated the connection.\n\nType classes ToRequest, ToNotif are for data that
  can be converted into\nJSON-RPC requests and notifications respectively. An instance
  of aeson's ToJSON\nclass is also required to serialize these data structures. Make
  sure that they\nserialize as a structured JSON value (array or object) that can
  go into the\nparams field of the JSON-RPC object. Type classes FromRequest, FromNotif
  and\nFromResult are for deserializing JSON-RPC messages.\n\nErrors are deserialized
  to the ErrorObj data type. Only a string is supported\nas contents inside a JSON-RPC
  1.0 error. JSON-RPC 2.0 errors also have a code,\nand possibly additional data as
  an aeson Value. \n\n\nServer Example\n--------------\n\nThis server returns the
  current time.\n\n``` haskell\n{-# LANGUAGE OverloadedStrings #-}\nimport Data.Aeson.Types\nimport
  Data.Conduit\nimport qualified Data.Conduit.List as CL\nimport Data.Conduit.Network\nimport
  Data.Time.Clock\nimport Data.Time.Format\nimport Network.JsonRpc\nimport System.Locale\n\ndata
  TimeReq = TimeReq\ndata TimeRes = TimeRes UTCTime\n\ninstance FromRequest TimeReq
  where\n    paramsParser \"time\" = Just $ const $ return TimeReq \n    paramsParser
  _ = Nothing\n\ninstance ToJSON TimeRes where\n    toJSON (TimeRes t) = toJSON $
  formatTime defaultTimeLocale \"%c\" t\n\nsrv :: AppConduits () () TimeRes TimeReq
  () () IO -> IO ()\nsrv (src, snk) = src $= CL.mapM respond $$ snk\n\nrespond ::
  IncomingMsg () TimeReq () ()\n        -> IO (Message () () TimeRes)\nrespond (IncomingMsg
  (MsgRequest (Request ver _ TimeReq i)) Nothing) = do    \n    t <- getCurrentTime\n
  \   return $ MsgResponse (Response ver (TimeRes t) i)\n\nrespond (IncomingError
  e) = return $ MsgError e\nrespond (IncomingMsg (MsgError e) _) = return $ MsgError
  $ e\nrespond _ = undefined\n\nmain :: IO ()\nmain = tcpServer V2 (serverSettings
  31337 \"127.0.0.1\") srv\n```\n\nClient Example\n--------------\n\nCorresponding
  TCP client to get time from server.\n\n``` haskell\n{-# LANGUAGE OverloadedStrings
  #-}\nimport Data.Aeson.Types hiding (Error)\nimport Data.Conduit\nimport qualified
  Data.Conduit.List as CL\nimport Data.Conduit.Network\nimport qualified Data.Text
  as T\nimport Data.Time.Clock\nimport Data.Time.Format\nimport Network.JsonRpc\nimport
  System.Locale\n\ndata TimeReq = TimeReq\ndata TimeRes = TimeRes UTCTime\n\ninstance
  ToRequest TimeReq where\n    requestMethod TimeReq = \"time\"\n\ninstance ToJSON
  TimeReq where\n    toJSON TimeReq = emptyArray\n\ninstance FromResponse TimeRes
  where\n    parseResult \"time\" = withText \"time\" $ \\t -> case f t of\n        Nothing
  -> fail \"Could not parse time\"\n        Just t' -> return $ TimeRes t'\n      where\n
  \       f t = parseTime defaultTimeLocale \"%c\" (T.unpack t)\n\ncli :: AppConduits
  TimeReq () () () () TimeRes IO\n    -> IO UTCTime\ncli (src, snk) = do\n    CL.sourceList
  [MsgRequest $ buildRequest V2 TimeReq] $$ snk\n    ts <- src $$ CL.consume\n    case
  ts of\n        [] -> error \"No response received\"\n        [IncomingError (ErrorObj
  _ m _ _ _)] -> error $ \"Unknown: \" ++ m\n        [IncomingMsg (MsgError (ErrorObj
  _ m _ _ _)) _] -> error m\n        [IncomingMsg (MsgResponse (Response _ (TimeRes
  t) _)) _] -> return t\n        _ -> undefined\n\nmain :: IO ()\nmain = tcpClient
  V2 True (clientSettings 31337 \"127.0.0.1\") cli >>= print\n```\n"
license-name: PublicDomain
