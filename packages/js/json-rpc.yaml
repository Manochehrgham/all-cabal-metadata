homepage: https://github.com/xenog/json-rpc
changelog-type: ''
hash: fc48c71291613eeb5954ed7e53123e7f1afb117f6a5547fb9853cca0b8cdd25a
test-bench-deps:
  bytestring: ! '>=0.10 && <0.11'
  test-framework: ! '>=0.8 && <0.9'
  stm: ! '>=2.4 && <2.5'
  base: ! '>=4.6 && <5'
  unordered-containers: ! '>=0.2 && <0.3'
  text: ! '>=0.11 && <1.3'
  test-framework-quickcheck2: ! '>=0.3 && <0.4'
  conduit: ! '>=1.2 && <1.3'
  stm-conduit: ! '>=2.5 && <2.7'
  json-rpc: -any
  mtl: ! '>=2.1 && <2.3'
  lifted-async: ! '>=0.7 && <0.8'
  monad-logger: ! '>=0.3 && <0.4'
  transformers: ! '>=0.3'
  QuickCheck: ! '>=2.6 && <2.9'
  aeson: ! '>=0.7 && <0.10'
maintainer: root@haskoin.com
synopsis: Fully-featured JSON-RPC 2.0 library
changelog: ''
basic-deps:
  bytestring: ! '>=0.10 && <0.11'
  stm: ! '>=2.4 && <2.5'
  base: ! '>=4.6 && <5'
  unordered-containers: ! '>=0.2 && <0.3'
  text: ! '>=0.11 && <1.3'
  monad-control: ! '>=0.3 && <1.1'
  conduit: ! '>=1.2 && <1.3'
  stm-conduit: ! '>=2.5 && <2.7'
  conduit-extra: ! '>=1.1 && <1.2'
  mtl: ! '>=2.1 && <2.3'
  lifted-async: ! '>=0.7 && <0.8'
  hashable: ! '>=1.1 && <1.3'
  monad-logger: ! '>=0.3 && <0.4'
  attoparsec: ! '>=0.11'
  transformers: ! '>=0.3'
  deepseq: ! '>=1.3 && <1.5'
  QuickCheck: ! '>=2.6 && <2.9'
  aeson: ! '>=0.7 && <0.10'
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.1.0.2'
- '0.1.0.3'
- '0.1.0.4'
- '0.1.0.5'
- '0.2.0.0'
- '0.2.0.1'
- '0.2.0.2'
- '0.2.1.0'
- '0.2.1.1'
- '0.2.1.2'
- '0.2.1.4'
- '0.2.1.5'
- '0.2.1.6'
- '0.3.0.0'
- '0.3.0.1'
- '0.3.0.2'
- '0.4.0.0'
- '0.5.0.0'
- '0.6.0.0'
- '0.6.1.0'
- '0.6.2.0'
- '0.6.2.1'
author: Jean-Pierre Rupp
latest: '0.6.2.1'
description-type: markdown
description: ! "json-rpc\n========\n\nFully-featured JSON-RPC 2.0 library for Haskell
  programs.\n\nThis JSON-RPC library is fully-compatible with JSON-RPC 2.0 and 1.0.
  It\nprovides an interface that combines a JSON-RPC client and server. It can\nset
  and keep track of request ids to parse responses.  There is support\nfor sending
  and receiving notifications. You may use any underlying\ntransport.  Basic TCP client
  and server provided.\n\nA JSON-RPC application using this interface is considered
  to be\npeer-to-peer, as it can send and receive all types of JSON-RPC message\nindependent
  of whether it originated the connection.\n\n[Hackage documentation](http://hackage.haskell.org/package/json-rpc)\n\n\nServer
  Example\n--------------\n\nThis JSON-RPC server returns the current time.\n\n```
  haskell\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\nimport
  Control.Monad.Trans\nimport Control.Monad.Logger\nimport Data.Aeson.Types hiding
  (Error)\nimport Data.Conduit.Network\nimport Data.Time.Clock\nimport Data.Time.Format\nimport
  Network.JsonRpc\nimport System.Locale\n\ndata TimeReq = TimeReq\ndata TimeRes =
  TimeRes { timeRes :: UTCTime }\n\ninstance FromRequest TimeReq where\n    parseParams
  \"time\" = Just $ const $ return TimeReq \n    parseParams _      = Nothing\n\ninstance
  ToJSON TimeRes where\n    toJSON (TimeRes t) = toJSON $ formatTime defaultTimeLocale
  \"%c\" t\n\nrespond :: MonadLoggerIO m => Respond TimeReq m TimeRes\nrespond TimeReq
  = do\n    t <- liftIO getCurrentTime\n    return . Right $ TimeRes t\n\nmain ::
  IO ()\nmain = runStderrLoggingT $ do\n    let ss = serverSettings 31337 \"::1\"\n
  \   jsonRpcTcpServer V2 False ss srv\n\nsrv :: MonadLoggerIO m => JsonRpcT m ()\nsrv
  = do\n    $(logDebug) \"listening for new request\"\n    qM <- receiveRequest\n
  \   case qM of\n        Nothing -> do\n            $(logDebug) \"closed request
  channel, exting\"\n            return ()\n        Just q -> do\n            $(logDebug)
  \"got request\"\n            rM <- buildResponse respond q\n            case rM
  of\n                Nothing -> do\n                    $(logDebug) \"no response
  for this request\"\n                    srv\n                Just r -> do\n                    $(logDebug)
  \"sending response\"\n                    sendResponse r >> srv\n```\n\nClient Example\n--------------\n\nCorresponding
  TCP client to get time from server.\n\n``` haskell\n{-# LANGUAGE TemplateHaskell
  #-}\n{-# LANGUAGE OverloadedStrings #-}\nimport Control.Concurrent\nimport Control.Monad\nimport
  Control.Monad.Trans\nimport Control.Monad.Logger\nimport Data.Aeson\nimport Data.Aeson.Types
  hiding (Error)\nimport Data.Conduit.Network\nimport qualified Data.Text as T\nimport
  Data.Time.Clock\nimport Data.Time.Format\nimport Network.JsonRpc\nimport System.Locale\n\ndata
  TimeReq = TimeReq\ndata TimeRes = TimeRes { timeRes :: UTCTime } deriving Show\n\ninstance
  ToRequest TimeReq where\n    requestMethod TimeReq = \"time\"\n    requestIsNotif
  = const False\n\ninstance ToJSON TimeReq where\n    toJSON TimeReq = emptyArray\n\ninstance
  FromResponse TimeRes where\n    parseResult \"time\" = Just $ withText \"time\"
  $ \\t -> case f t of\n        Just t' -> return $ TimeRes t'\n        Nothing ->
  mzero\n      where\n        f t = parseTime defaultTimeLocale \"%c\" (T.unpack t)\n
  \   parseResult _ = Nothing\n\nreq :: MonadLoggerIO m => JsonRpcT m (Either String
  UTCTime)\nreq = do\n    $(logDebug) \"sending time request\"\n    ts <- sendRequest
  TimeReq\n    $(logDebug) \"received response\"\n    case ts of\n        Nothing
  -> return $ Left \"could not parse response\"\n        Just (Left e) -> return .
  Left $ fromError e\n        Just (Right (TimeRes r)) -> return $ Right r\n\nmain
  :: IO ()\nmain = runStderrLoggingT $\n    jsonRpcTcpClient V2 True (clientSettings
  31337 \"::1\") $ do\n        $(logDebug) \"sending four time requests one second
  apart\"\n        replicateM_ 4 $ do\n            req >>= liftIO . print\n            liftIO
  (threadDelay 1000000)\n```\n"
license-name: PublicDomain
