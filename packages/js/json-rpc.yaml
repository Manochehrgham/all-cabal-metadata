homepage: https://github.com/xenog/json-rpc
changelog-type: ''
hash: b3a1e72c0ba2b4d09848db646816d9431117eaec628f6ee71a50533cc297d5fe
test-bench-deps:
  bytestring: ! '>=0.10 && <0.11'
  test-framework: ! '>=0.8 && <0.9'
  stm: ! '>=2.4 && <2.5'
  base: ! '>=4.6 && <5'
  unordered-containers: ! '>=0.2 && <0.3'
  text: ! '>=0.11 && <1.3'
  test-framework-quickcheck2: ! '>=0.3 && <0.4'
  conduit: ! '>=1.2 && <1.3'
  stm-conduit: ! '>=2.5 && <2.7'
  json-rpc: -any
  mtl: ! '>=2.1 && <2.3'
  lifted-async: ! '>=0.7 && <0.8'
  monad-logger: ! '>=0.3 && <0.4'
  transformers: ! '>=0.3'
  QuickCheck: ! '>=2.6 && <2.9'
  aeson: ! '>=0.7 && <0.10'
maintainer: root@haskoin.com
synopsis: Fully-featured JSON-RPC 2.0 library
changelog: ''
basic-deps:
  bytestring: ! '>=0.10 && <0.11'
  stm: ! '>=2.4 && <2.5'
  base: ! '>=4.6 && <5'
  unordered-containers: ! '>=0.2 && <0.3'
  text: ! '>=0.11 && <1.3'
  monad-control: ! '>=0.3 && <1.1'
  conduit: ! '>=1.2 && <1.3'
  stm-conduit: ! '>=2.5 && <2.7'
  conduit-extra: ! '>=1.1 && <1.2'
  mtl: ! '>=2.1 && <2.3'
  lifted-async: ! '>=0.7 && <0.8'
  hashable: ! '>=1.1 && <1.3'
  monad-logger: ! '>=0.3 && <0.4'
  attoparsec: ! '>=0.11'
  transformers: ! '>=0.3'
  deepseq: ! '>=1.3 && <1.5'
  QuickCheck: ! '>=2.6 && <2.9'
  aeson: ! '>=0.7 && <0.10'
  vector: ! '>=0.10 && <0.11'
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.1.0.2'
- '0.1.0.3'
- '0.1.0.4'
- '0.1.0.5'
- '0.2.0.0'
- '0.2.0.1'
- '0.2.0.2'
- '0.2.1.0'
- '0.2.1.1'
- '0.2.1.2'
- '0.2.1.4'
- '0.2.1.5'
- '0.2.1.6'
- '0.3.0.0'
- '0.3.0.1'
- '0.3.0.2'
- '0.4.0.0'
- '0.5.0.0'
- '0.6.0.0'
- '0.6.1.0'
- '0.6.2.0'
- '0.6.2.1'
- '0.7.0.0'
- '0.7.0.1'
- '0.7.0.2'
author: Jean-Pierre Rupp
latest: '0.7.0.2'
description-type: markdown
description: ! "json-rpc\n========\n\nFully-featured JSON-RPC 2.0 library for Haskell
  programs.\n\nThis JSON-RPC library is fully-compatible with JSON-RPC 2.0 and 1.0.
  It\nprovides an interface that combines a JSON-RPC client and server. It can\nset
  and keep track of request ids to parse responses.  There is support\nfor sending
  and receiving notifications. You may use any underlying\ntransport.  Basic TCP client
  and server provided.\n\nA JSON-RPC application using this interface is considered
  to be\npeer-to-peer, as it can send and receive all types of JSON-RPC message\nindependent
  of whether it originated the connection.\n\n[Documentation](http://hackage.haskell.org/package/json-rpc)\n\n[Examples](https://github.com/xenog/json-rpc/tree/master/examples)\n\n\nTime
  Server Example\n===================\n\n```haskell\n{-# LANGUAGE OverloadedStrings
  #-}\n{-# LANGUAGE TemplateHaskell #-}\nimport Control.Monad\nimport Control.Monad.Trans\nimport
  Control.Monad.Logger\nimport Data.Aeson.Types\nimport Data.Conduit.Network\nimport
  qualified Data.Foldable as F\nimport Data.Maybe\nimport qualified Data.Text as T\nimport
  Data.Time.Clock\nimport Data.Time.Format\nimport Network.JsonRpc\nimport System.Locale\n\ndata
  Req = TimeReq | Ping deriving (Show, Eq)\n\ninstance FromRequest Req where\n    parseParams
  \"time\" = Just $ const $ return TimeReq\n    parseParams \"ping\" = Just $ const
  $ return Ping\n    parseParams _      = Nothing\n\ninstance ToRequest Req where\n
  \   requestMethod TimeReq = \"time\"\n    requestMethod Ping    = \"ping\"\n    requestIsNotif
  \       = const False\n\ninstance ToJSON Req where\n    toJSON = const emptyArray\n\ndata
  Res = Time { getTime :: UTCTime } | Pong deriving (Show, Eq)\n\ninstance FromResponse
  Res where\n    parseResult \"time\" = Just $ withText \"time\" $ \\t ->\n        case
  parseTime defaultTimeLocale \"%c\" $ T.unpack t of\n            Just t' -> return
  $ Time t'\n            Nothing -> mzero\n    parseResult \"ping\" = Just $ const
  $ return Pong\n    parseResult _ = Nothing\n\ninstance ToJSON Res where\n    toJSON
  (Time t) = toJSON $ formatTime defaultTimeLocale \"%c\" t\n    toJSON Pong     =
  emptyArray\n\nrespond :: MonadLoggerIO m => Respond Req m Res\nrespond TimeReq =
  liftM (Right . Time) $ liftIO getCurrentTime\nrespond Ping    = return $ Right Pong\n\nmain
  :: IO ()\nmain = runStderrLoggingT $ do\n    let ss = serverSettings 31337 \"::1\"\n
  \   jsonRpcTcpServer V2 False ss srv\n\nsrv :: MonadLoggerIO m => JsonRpcT m ()\nsrv
  = do\n    $(logDebug) \"listening for new request\"\n    qM <- receiveBatchRequest\n
  \   case qM of\n        Nothing -> do\n            $(logDebug) \"closed request
  channel, exting\"\n            return ()\n        Just (SingleRequest q) -> do\n
  \           $(logDebug) \"got request\"\n            rM <- buildResponse respond
  q\n            F.forM_ rM sendResponse\n            srv\n        Just (BatchRequest
  qs) -> do\n            $(logDebug) \"got request batch\"\n            rs <- catMaybes
  `liftM` forM qs (buildResponse respond)\n            sendBatchResponse $ BatchResponse
  rs\n            srv\n```\n\n\nTime Client Example\n===================\n\n```haskell\n{-#
  LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE OverloadedStrings #-}\nimport Control.Concurrent\nimport
  Control.Monad\nimport Control.Monad.Trans\nimport Control.Monad.Logger\nimport Data.Aeson\nimport
  Data.Aeson.Types hiding (Error)\nimport Data.Conduit.Network\nimport qualified Data.Text
  as T\nimport Data.Time.Clock\nimport Data.Time.Format\nimport Network.JsonRpc\nimport
  System.Locale\n\ndata Req = TimeReq | Ping deriving (Show, Eq)\n\ninstance FromRequest
  Req where\n    parseParams \"time\" = Just $ const $ return TimeReq\n    parseParams
  \"ping\" = Just $ const $ return Ping\n    parseParams _      = Nothing\n\ninstance
  ToRequest Req where\n    requestMethod TimeReq = \"time\"\n    requestMethod Ping
  \   = \"ping\"\n    requestIsNotif        = const False\n\ninstance ToJSON Req where\n
  \   toJSON = const emptyArray\n\ndata Res = Time { getTime :: UTCTime } | Pong deriving
  (Show, Eq)\n\ninstance FromResponse Res where\n    parseResult \"time\" = Just $
  withText \"time\" $ \\t ->\n        case parseTime defaultTimeLocale \"%c\" $ T.unpack
  t of\n            Just t' -> return $ Time t'\n            Nothing -> mzero\n    parseResult
  \"ping\" = Just $ const $ return Pong\n    parseResult _ = Nothing\n\ninstance ToJSON
  Res where\n    toJSON (Time t) = toJSON $ formatTime defaultTimeLocale \"%c\" t\n
  \   toJSON Pong     = emptyArray\n\nhandleResponse :: Maybe (Either ErrorObj Res)
  -> Res\nhandleResponse t =\n    case t of\n        Nothing -> error \"could not
  receive or parse response\"\n        Just (Left e) -> error $ fromError e\n        Just
  (Right r) -> r\n\nreq :: MonadLoggerIO m => JsonRpcT m Res\nreq = do\n    tEM <-
  sendRequest TimeReq\n    $(logDebug) \"sending time request\"\n    return $ handleResponse
  tEM\n\nreqBatch :: MonadLoggerIO m => JsonRpcT m [Res]\nreqBatch = do\n    $(logDebug)
  \"sending pings\"\n    tEMs <- sendBatchRequest $ replicate 2 Ping\n    return $
  map handleResponse tEMs\n\nmain :: IO ()\nmain = runStderrLoggingT $\n    jsonRpcTcpClient
  V2 True (clientSettings 31337 \"::1\") $ do\n        $(logDebug) \"sending two time
  requests one second apart\"\n        replicateM_ 2 $ do\n            req >>= $(logDebug)
  . T.pack . (\"response: \"++) . show\n            liftIO (threadDelay 1000000)\n
  \       $(logDebug) \"sending two pings in a batch\"\n        reqBatch >>= $(logDebug)
  . T.pack . (\"response: \"++) . show\n```\n"
license-name: PublicDomain
