changelog-type: ''
hash: f67895c66c65c8d0a75fa19a30ebb7ff429622b7e95c2d27210949016217157e
synopsis: The category of monads
changelog: ''
all-versions:
- '0.1.0.0'
- '0.2.0.0'
- '0.3.0.0'
latest: '0.3.0.0'
description-type: haddock
description: ! 'MHask is the category where


  * The objects are Haskell types of kind @(* → *)@ that have an instance of `Prelude.Monad''


  * An arrow from object m to object n is a Haskell function of the form @(forall
  x. m x → n x)@


  * Arrow composition is merely a specialization of Haskell function composition


  * The identity arrow for the object m is the `Prelude.id'' function in Haskell,

  specialized to @(forall x. m x → m x)@


  It is assumed that any instances of the classes provided here also have an instance

  for Monad of the form @instance (Monad m) ⇒ Monad (t m)@, thus guaranteeing that
  @(t m)@

  (or @(t i j m)@ for the indexed types) is always a Monad. If it were valid Haskell,
  I''d write:


  > class (forall m. Monad m ⇒ Monad (t m)) ⇒ Functor t


  ''MHask.Functor.Functor'' should actually be called Endofunctor, because if m is
  an object in MHask,

  then an instance t of `Functor'' can map object m to object (t m), and arrows from

  m to n get mapped to arrows from (t m) to (t n).'
