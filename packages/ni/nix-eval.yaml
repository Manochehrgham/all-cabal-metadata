homepage: http://chriswarbo.net/git/nix-eval
changelog-type: ''
hash: 78e45fa02f54cf3d50a44ad41bd5c887107f5a1e7669d86f43945612e0d0e56c
test-bench-deps:
  nix-eval: -any
  base: ! '>=4.7'
  tasty-quickcheck: -any
  tasty: ! '>=0.7'
  QuickCheck: -any
maintainer: chriswarbo@gmail.com
synopsis: Evaluate Haskell expressions using Nix to get packages
changelog: ''
basic-deps:
  base: ! '>=4.8 && <4.9'
  process: -any
all-versions:
- '0.1.0.0'
- '0.1.0.1'
author: Chris Warburton
latest: '0.1.0.1'
description-type: markdown
description: ! "# Dependency-Injecting Eval for Haskell\n\nThis Haskell package is
  a crude implementation of `eval`, as found in dynamic\nlanguages like Lisp, Python,
  Javascript, etc. It lets us construct Haskell\ncode programatically (either at run
  time, or in Template Haskell), and attempt\nto evaluate it.\n\nWhat sets this package
  apart from other `eval` implementations, is the ability\nto control which packages
  and modules are available during evaluation. This is\nachieved by calling out to
  the [Nix package manager](http://nix.nixos.org).\n\n# Implementation Details\n\n`Expr`
  is the type of expressions, which contains a list of package names, a\nlist of modules
  to import and a `String` of Haskell code. All of these are just\n`String`s internally,
  but the wrappers prevent accidentally using package as\nmodules, etc. A few combinators
  are provided for common manipulations, and the\n`OverloadedStrings` extension allows
  packages, modules and expressions to be\nwritten as literals. Note that literal
  expressions are given an empty context;\nyou will have to specify any required modules
  or packages separately.\n\nWhen evaluated, the Haskell code is prefixed by an import
  of each module and\nwrapped in `main = putStr (..)`, then piped into `runhaskell`.
  That process is\ninvoked via the `nix-shell` command, using Nix's standard\n`haskellPackages.ghcWithPackages`
  function to ensure the GHC instance has all of\nthe given packages available.\n\nIf
  the process exits successfully, its stdout will be returned wrapped in\n`Just`;
  otherwise `Nothing` is returned.\n\nThis implementation is a little rough; for example,
  you may prefer to use `Text`\nrather than `String`; use a better representation
  like the syntax trees from\nTemplateHaskell or `haskell-src-exts` instead; or accumulate
  packages and\nmodules monadically.\n\nThe intention of this library is to provide
  a simple, minimal base to support\nsuch design choices, and `String` is the lowest
  common denominator. You're\nwelcome, and encouraged, to build more sophisticated
  APIs; as long as you can\npretty-print to a `String`, they should work out of the
  box.\n\nThis is also why we return the contents of stdout, rather than trying to
  parse\nit into a more appropriate type: it's not our place to choose how the result\nshould
  be parsed, so we avoid the problem; by that point, our job is done.\n\n# Limitations\n\n
  - Since evaluation takes place in a separate GHC process, there can be no\n   sharing
  of data (unless you provide a separate mechanism like a FIFO)\n - Expressions are
  wrapped in `putStr`, so the expression must be a `String`.\n   You may need to marshall
  your data into a form which is more amenable to\n   serialising/deserialising via
  `String`.\n - Evaluation is **SLOW**! More specifically, `eval` has a very high
  latency, so\n   it's *much* more efficient to `eval` one big collection of values
  than it is\n   to `eval` each individually.\n - Evaluation time is highly variable,
  since the required packages may need to\n   be compiled. Nix caches build products,
  so subsequent calls using the same\n   packages will be quicker; however, my machine
  still takes about 2 seconds to\n   instantiate a cached environment.\n - Output
  is captured from stdout, so if your expression triggers side-effects\n   they'll
  appear in your result (this may be desirable, but keep it in mind).\n - Evaluation
  doesn't always compose, ie. just because `x` and `y` evaluate\n   successfully doesn't
  mean that some combination of them will. Obviously an\n   ill-typed combination
  will fail, but other reasons include:\n    - Combining both import lists can make
  names ambiguous. For this reason you\n      should always try to qualify your expressions.\n
  \   - Global properties may conflict between modules, like overlapping typeclass\n
  \     instances.\n    - Combining both package lists can make modules ambiguous.\n
  \   - If the dependencies of two packages conflict, evaluation will fail.\n - Language
  extensions aren't handled yet. I'll add them as and when the need\n   arises.\n
  - As with any kind of `eval`, there is absolutely no security. Do not pass\n   potentially-malicious
  user input to this library.\n"
license-name: GPL
