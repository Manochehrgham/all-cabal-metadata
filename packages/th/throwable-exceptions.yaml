homepage: https://github.com/aiya000/throwable-exceptions#README.md
changelog-type: ''
hash: e452c11b428c6c7fa6e775cb049cf36836487fc92a57ddcdf2e41eac0885b07f
test-bench-deps:
  either: -any
  base: -any
  throwable-exceptions: -any
  tasty-discover: -any
  text: -any
  safe-exceptions: -any
  tasty-hunit: -any
  tasty: -any
maintainer: aiya000.develop@gmail.com
synopsis: throwable-exceptions gives the exception's value constructors
changelog: ''
basic-deps:
  base: ! '>=4.7 && <5'
  safe-exceptions: -any
all-versions:
- '0.1.0.0'
author: aiya000
latest: '0.1.0.0'
description-type: markdown
description: ! "# :diamonds: throwable-exceptions :diamonds:\nthrowable-exceptions
  gives the exception's value constructors for your haskell project :dog:\n\n\n# :muscle:
  Why we should use this ? :muscle:\nThe situation that we want to throw the specific
  exception is happened frequently,\nbut many general exceptions are not given by
  base.\n\nFor example, [IOException](https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception.html#t:IOException)'s
  value constructor is not given.\n\n```haskell\nimport Control.Exception.Safe (MonadThrow,
  throwM, IOException(..), try, Exception, SomeException)\nimport Control.Monad.IO.Class
  (MonadIO, liftIO)\nimport Control.Monad.Trans.Either (runEitherT)\n\nreadFileOrError
  :: (MonadThrow m, MonadIO m) => FilePath -> m String\nreadFileOrError path = do\n
  \ xOrErr <- liftIO . try $ readFile path\n  case xOrErr of\n    Left e -> throwM
  . IOException $ show (e :: SomeException)\n    Right a -> return a\n\nmain :: IO
  ()\nmain = do\n  xOrErr <- runEitherT $ readFileOrError \"Main.hs\"\n  case xOrErr
  of\n    Left e -> putStrLn $ \"oops: \" ++ show (e :: SomeException)\n    Right
  a -> putStrLn a\n\n-- Result output vv\n-- Data constructor not in scope: IOException
  :: [Char] -> e1\n```\n\nBut you have not to define a specific exception yourself\nif
  you use this :muscle:\n"
license-name: MIT
