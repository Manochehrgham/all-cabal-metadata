homepage: https://github.com/pepeiborra/threepenny-editors
changelog-type: markdown
hash: bf83b535f68fad0e0dac93758ba7061e766972b927acc8249a7814b4070f3b9c
test-bench-deps: {}
maintainer: pepeiborra@gmail.com
synopsis: Composable algebraic editors
changelog: ! "# 0.2.0.13 (2017-06-22)\n    * Added `liftEditor` to expose the underlying
  `Element` of an editor.\n      This enables setting attributes in the element, including
  class and id.\n# 0.2.0.12 (2017-06-21)\n    * Export `EditorDef` and `EditorFactory`
  constructors to allow for\n      wrapping of custom controls\n# 0.2.0.11 (2017-06-10)\n
  \   * Documentation only release.\n# 0.2.0.10 (2017-05-23)\n    * Nested grids.
  All layouts are now grid based.\n# 0.2.0.9 (2017-05-23)\n    * Detect grid layouts
  and render them accordingly \n# 0.2.0.8 (2017-05-21)\n    * Bug fixes\n# 0.2.0.7
  (2017-05-20)\n    * Added `editorSelection`.\n# 0.2.0.6 (2017-05-15)\n    * Fix
  the `Editable` instance for `Identity` and remove reexports.\n# 0.2.0.5 (2017-05-14)\n\n\t*
  Add `editorGeneric` and `editorGenericSimple` for types with generics-sop instances.\n\tThe
  latter is only for record and newtypes, whereas the former supports also\n\tUnion
  types, but comes with additional type class constraints.\n\t* Give `Editable` default
  implementations for generic types.\n"
basic-deps:
  base: ! '>=4.7 && <5'
  data-default: -any
  threepenny-gui: ! '>0.7'
  generics-sop: -any
  profunctors: -any
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.2.0.0'
- '0.2.0.1'
- '0.2.0.2'
- '0.2.0.3'
- '0.2.0.4'
- '0.2.0.5'
- '0.2.0.6'
- '0.2.0.7'
- '0.2.0.8'
- '0.2.0.9'
- '0.2.0.10'
- '0.2.0.11'
- '0.2.0.12'
- '0.2.0.13'
author: Jose Iborra
latest: '0.2.0.13'
description-type: markdown
description: ! "[![Travis Build Status](https://travis-ci.org/pepeiborra/threepenny-editors.svg)](https://travis-ci.org/pepeiborra/threepenny-editors)\n[![Hackage](https://img.shields.io/hackage/v/threepenny-editors.svg)](https://hackage.haskell.org/package/threepenny-editors)\n[![Stackage
  Nightly](http://stackage.org/package/threepenny-editors/badge/nightly)](http://stackage.org/nightly/package/threepenny-editors)\n\n#
  threepenny-editors \n\n## Introduction\nA library allowing to easily create threepenny-gui
  widgets for editing algebraic datatypes. \nThe library provides a set of editors
  for primitive and base types, a set of editor\nconstructors for building editors
  for type constructors, and a set of combinators for\ncomposing editors - the `EditorFactory`
  type has an `Applicative`-like structure, with two\ncombinators for horizontal and
  vertical composition, as well as\na `Profunctor` instance. Don't worry if you are
  not familiar with these concepts as they are\nnot required to perform simple tasks
  with this library.\n```\nnewtype EditorFactory a b\ninstance Profunctor EditorFactory\n\n(|*|)
  :: EditorFactory s (b->a) -> EditorFactory s b -> EditorFactory s a\n(-*-) :: EditorFactory
  s (b->a) -> EditorFactory s b -> EditorFactory s a\n```\n\nThe library also provides
  an `Editable` type class to associate a default `EditorFactoy` with\na type:\n```\nclass
  Editable a where\n  editor :: EditorFactory a a\n```\n\n## Example\n\nLet's start
  with something simple, obtaining an `EditorFactory` for a newtype:\n```\nnewtype
  Brexiteer = Brexiteer {unBrexiteer::Bool} deriving (Bounded, Enum, Eq, Read, Show,
  Ord, Generic)\n```\n\nSince we already have an `Editable` instance for `Bool` that
  displays a checkbox, \nwe can obtain an `Editable` instance for `Brexiteer` for
  free:\n```\nderiving instance Editable Brexiteer\n```\n\nWe can also wrap the existing
  `Bool` editor manually if we want to using `dimap`:\n```\neditorBrexiteer = dimap
  unBrexiteer Brexiteer (editor :: Editor Bool Bool)\n```\nThe type annotation above
  is only for illustrative purposes.\n\nPerhaps we are not happy with the default
  checkbox editor and want to have a different UI?\nThe code below shows how to use
  a textbox instead:\n```\neditorBrexiteerText :: EditorFactory Brexiteer Brexiteer\neditorBrexiteerText
  = editorReadShow\n```\nOr a combo box:\n```\neditorBrexiteerChoice :: EditorFactoy
  Brexiteer Brexiteer\neditorBrexiteerChoice = editorEnumBounded\n```\nLet's move
  on to a union type now:\n```\ndata Education\n  = Basic\n  | Intermediate\n  | Other_
  String\n  deriving (Eq, Read, Show)\n```\nWe could define an editor for `Education`
  with `editorReadShow`, but maybe we want a more user\nfriendly UI that displays
  a choice of education type, and only in the `Other` case a free form\ntext input.
  The `editorSum` combinator takes a list of choices and an editor for each choice:\n```\neditorEducation
  :: EditorFactory Education Education\neditorEducation = do\n    let selector x =
  case x of\n            Other _ -> \"Other\"\n            _       -> show x\n    editorSum\n
  \     [ (\"Basic\", const Basic <$> editorUnit)\n      , (\"Intermediate\", const
  Intermediate <$> editorUnit)\n      , (\"Other\", dimap (fromMaybe \"\" . getOther)
  Other editor)\n      ]\n      selector\n\ngetOther :: Education -> Maybe String\ngetOther
  (Other s) = Just s\ngetOther _         = Nothing\n```\n\nOr more simply, we could
  just use `editorGeneric` to achieve the same effect, provided that\n`Education`
  has got SOP.Generic and SOP.HasDatatypeInfo instances\n```\nimport           GHC.Generics\nimport
  qualified Generics.SOP as SOP\n\nderiving instance Generic Education\ninstance SOP.HasDatatypeInfo
  Education\ninstance SOP.Generic Education\n\n-- Derive an Editable instance that
  uses editorGeneric\ninstance Editable Education\n\n-- Explicitly call editorGeneric\neditorEducation
  :: EditorFactory Education Education\neditorEducation = editorGeneric\n```\nMoving
  on to a record type, let's look at how to compose multiple editors together:\n```\ndata
  Person = Person\n  { education           :: Education\n  , firstName, lastName ::
  String\n  , age                 :: Maybe Int\n  , brexiteer           :: Brexiteer\n
  \ , status              :: LegalStatus\n  }\n  deriving (Generic, Show)\n```\nThe
  `field` combinator encapsulates the common pattern of pairing a label and a base
  editor\nto build the editor for a record field:\n```\nfield :: String -> (out ->
  inn) -> EditorFactory inn a -> EditorFactory out a\nfield name f e = string name
  *| lmap f e\n```\nWhere `*|` prepends a UI Element to an Editor horizontally: \n```\n(*|)
  :: UI Element -> EditorFactory s a -> EditorFactory s a\n```\nArmed with `field`
  and applicative composition (vertical '-*-' and horizontal '|*|'),\nwe define the
  editor for `Person` almost mechanically:\n```\neditorPerson :: EditorFactory Person
  Person\neditorPerson =\n    (\\fn ln a e ls b -> Person e fn ln a b ls)\n      <$>
  field \"First:\"     firstName editor\n      -*- field \"Last:\"      lastName editor\n
  \     -*- field \"Age:\"       age editor\n      -*- field \"Education:\" education
  editorEducation\n      -*- field \"Status\"     status (editorJust $ editorSelection
  (pure [minBound..]) (pure (string.show)))\n      -*- field \"Brexiter\"   brexiteer
  editor\n```\nThe only bit of ingenuity in the code above is the deliberate reordering
  of the fields.\n\nIt is also possible to generically derive the editor for person
  in the same way as before, in which\ncase the labels are taken from the field names,
  and the order from the declaration order.\n"
license-name: BSD3
