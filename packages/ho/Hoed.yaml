homepage: http://maartenfaddegon.nl
changelog-type: text
hash: 33e3502095d47a5ddbb8b1a7aab65bf6c6e473b7e962819f5a0d82003ceec62e
test-bench-deps: {}
maintainer: hoed@maartenfaddegon.nl
synopsis: Lightweight algorithmic debugging.
changelog: ! "0.2.2 Maarten Faddegon 14  2015\n\n  * Use a preprocessor to make the
  library work with GHC 7.10, but also for older versions of GHC. This is related
  to the \"The Applicative Monad Proposal\" and the changes to Template Haskell in
  GHC 7.10 that are not backward compatibility with earlier versions of GHC.\n\n0.2.1
  Maarten Faddegon 1 May 2015\n\n  * Small changes to make Hoed work with GHC 7.10\n\n0.2.0
  Maarten Faddegon 12 Feb 2015\n\n  * A threepenny-gui algorithmic debugger.\n  *
  Construction of computation trees with just local annotations. Existing algorithmic
  debuggers for Haskell require a transformation of all modules in a program, even
  libraries that the user does not want to debug and which may use language features
  not supported by the debugger. This is a pity, because a promising approach to debugging
  is therefore not applicable to many real-world programs. We use the cost centre
  stack from the Glasgow Haskell Compiler profiling environment together with runtime
  value observations to collect enough information for algorithmic debugging.\n\n\n0.1.0.1
  Maarten Faddegon 24 May 2014\n\n  * A tracer library based on Andy Gills HOOD v0.2.
  Allows to observe intermediate values. How values are observed can be derived with
  the Generic Deriving Mechanism, or generated with Template Haskell. \n"
basic-deps:
  base: ! '>=4 && <5'
  FPretty: -any
  libgraph: ==1.7
  filepath: -any
  process: -any
  RBTree: ==0.0.5
  array: -any
  containers: -any
  threepenny-gui: ==0.6.*
  regex-posix: -any
  mtl: -any
  template-haskell: -any
  directory: -any
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.2.0'
- '0.2.1'
- '0.2.2'
- '0.3.0'
- '0.3.1'
author: Maarten Faddegon
latest: '0.3.1'
description-type: markdown
description: ! "# Hoed - A Lightweight Haskell Tracer and Debugger [![Build Status](https://travis-ci.org/MaartenFaddegon/Hoed.svg?branch=master)](https://travis-ci.org/MaartenFaddegon/Hoed)\n\nHoed
  is a tracer and debugger for the programming language Haskell.\n\n## Using Hoed\n\nTo
  locate a defect with Hoed you annotate suspected functions and compile as usual.
  Then you run your program, information about the annotated functions is collected.
  Finally you connect to a debugging session using a webbrowser.\n\nLet us consider
  the following program, a defective implementation of a parity function with a test
  property.\n\n    isOdd :: Int -> Bool\n    isOdd n = isEven (plusOne n)\n    \n
  \   isEven :: Int -> Bool\n    isEven n = mod2 n == 0\n    \n    plusOne :: Int
  -> Int\n    plusOne n = n + 1\n    \n    mod2 :: Int -> Int\n    mod2 n = div n
  2\n    \n    prop_isOdd :: Int -> Bool\n    prop_isOdd x = isOdd (2*x+1)\n    \n
  \   main :: IO ()\n    main = printO (prop_isOdd 1)\n    \n    main :: IO ()\n    main
  = quickcheck prop_isOdd\n\nUsing the property-based test tool QuickCheck we find
  the counter example `1` for our property.\n\n    ./MyProgram\n    *** Failed! Falsifiable
  (after 1 test): 1\n\nHoed can help us determine which function is defective. We
  annotate the functions `isOdd`, `isEven`, `plusOne` and `mod2` as follows:\n\n    import
  Debug.Hoed.Pure\n    \n    isOdd :: Int -> Bool\n    isOdd = observe \"isOdd\" isOdd'\n
  \   isOdd' n = isEven (plusOne n)\n    \n    isEven :: Int -> Bool\n    isEven =
  observe \"isEven\" isEven'\n    isEven' n = mod2 n == 0\n    \n    plusOne :: Int
  -> Int\n    plusOne = observe \"plusOne\" plusOne'\n    plusOne' n = n + 1\n    \n
  \   mod2 :: Int -> Int\n    mod2 = observe \"mod2\" mod2'\n    mod2' n = div n 2\n
  \   \n    prop_isOdd :: Int -> Bool\n    prop_isOdd x = isOdd (2*x+1)\n    \n    main
  :: IO ()\n    main = printO (prop_isOdd 1)\n\nAfter running the program a computation
  tree is constructed and displayed in a web browser.\n\n    ./MyProgram\n    False\n
  \   Listening on http://127.0.0.1:10000/\n\nYou can freely browse this tree to get
  a better understanding of your program. If your program misbehaves, you can judge
  the computation statements in the tree as 'right' or 'wrong' according to your intention.
  When enough statements are judged the debugger tells you the location of the fault
  in your code.\n\n![Screenshot of Hoed][1]\n\n## Installation\n\nHoed is available
  from Hackage and can be installed with Cabal.\n\n    cabal install Hoed\n\n## Other
  Tracers\n\nMany of the ideas for Hoed come from the Hat project. Hoed is the Dutch
  word for a hat. Compared to Hoed, Hat can give more detailed traces. However, Hat
  requires all modules to be transformed and is therefore not practical for many real-world
  Haskell programs.\n\nThe idea to observe values with local annotations comes from
  the HOOD project. Unlike Hoed, HOOD does not give relations between observed values.
  HOOD also requires the programmer to write a class-instance for the type of the
  value they want to observe. With Hoed these instates can be derived automatically.\n\n
  \ [1]: http://www.cs.kent.ac.uk/people/rpg/mf357/hoedv2.0.0.png\n"
license-name: BSD3
