homepage: http://github.com/akc/hops
changelog-type: ''
hash: c83520c51acb34ae06145f646e22aa36eff07578fc2ed46cb20859cd9a7d1990
test-bench-deps:
  bytestring: ! '>=0.10'
  base: ! '>=4 && <5'
  text: ! '>=0.11'
  containers: ! '>=0.5'
  attoparsec: ! '>=0.11'
  deepseq: ! '>=1.3'
  QuickCheck: ! '>=2.7'
  aeson: ! '>=0.8'
  vector: ! '>=0.10'
maintainer: anders.claesson@gmail.com
synopsis: Hackable Operations on Power Series
changelog: ''
basic-deps:
  bytestring: ! '>=0.10'
  base: ! '>=4 && <5'
  text: ! '>=0.11'
  filepath: ! '>=1.3'
  conduit: ! '>=1'
  conduit-extra: ! '>=1'
  containers: ! '>=0.5'
  ansi-terminal: ! '>=0.6'
  attoparsec: ! '>=0.11'
  transformers: ! '>=0.3'
  optparse-applicative: ! '>=0.10'
  parallel: ! '>=3.2'
  deepseq: ! '>=1.3'
  http-conduit: ! '>=2'
  http-types: ! '>=0.8'
  aeson: ! '>=0.8'
  vector: ! '>=0.10'
  directory: ! '>=1.2'
all-versions:
- '0.0.1'
- '0.0.2'
- '0.1.0'
author: Anders Claesson
latest: '0.1.0'
description-type: markdown
description: ! "# ![HOPS](https://github.com/akc/akc.github.io/raw/master/hops/images/hops.png)
  HOPS [![Build Status](https://travis-ci.org/akc/hops.svg)](https://travis-ci.org/akc/hops)\n\nHackable
  Operations on Power Series.\n\n## Install\n\nThe easiest way to get started is to
  download a prebuilt binary. Such\nbinaries can be found on the\n[releases page](https://github.com/akc/hops/releases).\nThe
  binaries are statically linked and should work on any Linux system.\n\nAlternative
  ways of installing `hops` include\nusing the [nix](https://nixos.org/nix/) package
  manager:\n\n```\n$ nix-env -f \"<nixpkgs>\" -iA haskellPackages.hops\n```\n\nOr
  [cabal](https://www.haskell.org/cabal/):\n\n```\n$ cabal install hops\n```\n\n##
  Usage examples\n\n### Fibonacci numbers\n\nThe generating function, *f*, for the
  Fibonacci numbers satisfies\n*f=1+(x+x<sup>2</sup>)f*, and using `hops` we can get
  the\ncoefficient of *f* directly from this equation:\n\n```\n$ hops 'f=1+(x+x^2)*f'\nf=1+(x+x^2)*f
  => {1,1,2,3,5,8,13,21,34,55,89,144,233,377,610}\n```\n\nAlternatively, we could
  first solve for *f* in *f=1+(x+x<sup>2</sup>)f*\nand let `hops` expand that expression:\n\n```\n$
  hops 'f=1/(1-x-x^2)'\nf=1/(1-x-x^2) => {1,1,2,3,5,8,13,21,34,55,89,144,233,377,610}\n```\n\n###
  Catalan numbers\n\nIt could hardly be easier:\n\n```\n$ hops C=1+x*C^2\nC=1+x*C^2
  => {1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440}\n```\n\n###
  Bell numbers\n\nThe exponential generating function for the Bell numbers is\n*e<sup>e<sup>x</sup>-1</sup>*
  and we can give that expression to\n`hops`:\n\n```\n$ hops --prec=10 'exp(exp(x)-1)'\nexp(exp(x)-1)
  => {1,1,1,5/6,5/8,13/30,203/720,877/5040,23/224,1007/17280}\n```\n\nTo get the Bell
  numbers we, however, also need to multiply the\ncoefficient of *x<sup>n</sup>* in
  that series by *n!*; this is what\nthe laplace transform does:\n\n```\n$ hops --prec=10
  'f=exp(exp(x)-1);laplace(f)'\nf=exp(exp(x)-1);laplace(f) => {1,1,2,5,15,52,203,877,4140,21147}\n```\n\n###
  Euler numbers\n\nPower series defined by trigonometric functions are fine too:\n\n```\n$
  hops --prec=12 'f=sec(x)+tan(x);laplace(f)'\nf=sec(x)+tan(x);laplace(f) => {1,1,1,2,5,16,61,272,1385,7936,50521,353792}\n```\n\n###
  Number of ballots (ordered set partitions)\n\nThis sequence most simply defined
  by its exponential generating function\n*y=1/(2-e<sup>x</sup>)*:\n\n```\n$ hops
  --prec 10 'y=1/(2-exp(x)); laplace(y)'\ny=1/(2-exp(x));laplace(y) => {1,1,3,13,75,541,4683,47293,545835,7087261}\n```\n\nAlternatively,
  one can exploit that *y'=2y<sup>2</sup>-y*:\n\n```\n$ hops --prec 10 'y = 1 + integral(2*y^2
  - y); laplace(y)'\ny=1+integral(2*y^2-y);laplace(y) => {1,1,3,13,75,541,4683,47293,545835,7087261}\n```\n\n###
  Composing programs\n\nUsing the special variable `stdin` we can compose programs:\n\n```\n$
  hops 'f=1+(x+x^2)*f' | hops 'stdin/(1-x)'\nf=1+(x+x^2)*f;f/(1-x) => {1,2,4,7,12,20,33,54,88,143,232,376,609,986,1596}\n```\n\nAs
  a side note, one can show that our programs form a monoid under this\ntype of composition.\n\nBe
  aware that `hops` may have to rename variables when composing programs:\n\n```\n$
  hops --prec=10 'f=1+(x+x^2)*f' | hops 'f=1/(1-2*x);f/(1-x*stdin)'\nf=1+(x+x^2)*f;g=1+2*x*g;g/(1-x*f)
  => {1,3,8,21,54,137,344,857,2122,5229,12836}\n```\n\n### Misc transformations\n\nHOPS
  knows about many of the transformations used by OEIS\n<https://oeis.org/transforms.html>.\n\nAs
  an example, the sequences `A067145` claims to shift left under\nreversion:\n\n```\nS
  A067145 1,1,-1,3,-13,69,-419,2809,-20353,157199,-1281993,10963825,-97828031,\nN
  A067145 Shifts left under reversion.\n```\n\nLet's test that claim:\n\n```\n$ hops
  'REVERT(A067145)-LEFT(A067145)'\nREVERT(A067145)-LEFT(A067145) => {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}\n```\n\n###
  HOPS program files\n\nSometimes it is useful be able to apply many transformations
  to the same\ninput. One way to achieve that is to write a little program with the\ntransformations
  we are interested in. E.g. if we create a file\n`transforms.hops` containing\n\n```\nBINOMIAL(stdin)\nEULER(stdin)\nREVEGF(stdin)\nSTIRLING(stdin)\n```\nthen
  we can apply all of these transforms to `1/(1-x)` as follows:\n\n```\n$ hops '1/(1-x)'
  | hops --prec=9 -f transforms.hops\nf=1/(1-x);BINOMIAL(f) => {1,2,4,8,16,32,64,128,256}\nf=1/(1-x);EULER(f)
  => {1,2,3,5,7,11,15,22,30}\nf=1/(1-x);REVEGF(f) => {1,-2,9,-64,625,-7776,117649,-2097152,43046721}\nf=1/(1-x);STIRLING(f)
  => {1,2,5,15,52,203,877,4140,21147}\n```\n\nN.B: As in this example, the preferred
  file extension for HOPS\nprogram files is `.hops`.\n\n### Binary operations\n\nOperation
  | Meaning\n----------|-------------------------------------------------\n`f + g`
  \  | sum of *f* and *g*\n`f - g`   | difference of *f* and *g*\n`f ^ g`   | *f*
  to the power *g*\n`f @ g`   | *f* composed with *g*\n`f * g`   | product of *f*
  and *g*\n`f / g`   | quotient of *f* and *g*\n`f .* g`  | coefficient-wise/Hadamard
  product of *f* and *g*\n`f ./ g`  | coefficient-wise quotient of *f* and *g*\n\n###
  Derivative and integral\n\nOperation   | Meaning\n------------|--------------------------------------------\nD(f)
  \       | derivative of *f*\nintegral(f) | integral of *f*\n\n### Functions\n\nFunction
  \      | Meaning\n---------------|----------------------------------------\n`sqrt(f)`
  \     | `f^(1/2)`\n`abs(f)`       | coefficient-wise absolute value\n`log(f)`       |
  logarithmic function\n`exp(f)`       | exponential function\n`sin(f)`       | sine
  function\n`cos(f)`       | cosine function\n`tan(f)`       | tangent function\n`sec(f)`
  \      | `1/cos(f)`\n`arcsin(f)`    | arcsine function\n`arccos(f)`    | arccosine
  function\n`arctan(f)`    | arctangent function\n`sinh(f)`      | hyperbolic sine
  function\n`cosh(f)`      | hyperbolic cosine function\n`tanh(f)`      | hyperbolic
  tangent function\n`arsinh(f)`    | area hyperbolic sine function\n`arcosh(f)`    |
  area hyperbolic cosine function\n`artanh(f)`    | area hyperbolic tangent function\n`laplace(f)`
  \  | `f .* {n!}`\n`laplacei(f)`  | `f ./ {n!}`\n`revert(f)`    | compositional inverse\n\n###
  Transforms\n\nTransform      | Meaning\n---------------|----------------------------------------\n`AERATE1(f)`
  \  | `f(x^2)`\n`AERATE2(f)`   | `f(x^3)`\n`BARRY1(f)`    | `1/(1-x-x^2*f)`\n`BARRY2(f)`
  \   | `1/(1+x+x^2*f)`\n`BINOMIAL(f)`  | `g=exp(x)*laplacei(f);laplace(g)`\n`BINOMIALi(f)`
  | `g=exp(-x)*laplacei(f);laplace(g)`\n`BIN1(f)`      | `g={(-1)^n/n!}*((laplacei(x*f))@(-x));LEFT(laplace(-g))`\n`BISECT0(f)`
  \  | if `f={a0,a1,a2,a3,a4,...}` then `BISECT0(f)={a0,a2,a4,...}`\n`BISECT1(f)`
  \  | if `f={a0,a1,a2,a3,a4,...}` then `BISECT1(f)={a1,a3,a5,...}`\n`BOUS2(f)`     |
  See [[1](https://oeis.org/transforms.txt)]\n`BOUS2i(f)`    | See [[1](https://oeis.org/transforms.txt)]\n`BOUS(f)`
  \     | See [[1](https://oeis.org/transforms.txt)]\n`CONV(f)`      | `f^2`\n`CONVi(f)`
  \    | `sqrt(f)`\n`DIFF(f)`      | `LEFT(f)-f`\n`EULER(f)`     | [Euler transform](http://mathworld.wolfram.com/EulerTransform.html)\n`EULERi(f)`
  \   | inverse [Euler transform](http://mathworld.wolfram.com/EulerTransform.html)\n`EXPCONV(f)`
  \  | `g=laplacei(f);laplace(g*g)`\n`EXP(f)`       | `g={1/n!}@(laplacei(x*f));laplace(g-1)/x`\n`HANKEL(f)`
  \   | [Hankel transform](https://cs.uwaterloo.ca/journals/JIS/VOL4/LAYMAN/hankel.html)\n`LAH(f)`
  \      | `g=(laplacei(f))@(x/(1-x));laplace(g)`\n`LAHi(f)`      | `g=(laplacei(f))@(x/(1+x));laplace(g)`\n`LEFT(f)`
  \     | if `f={a0,a1,a2,a3,a4,...}` then `LEFT(f)={a1,a2,a3,...}`\n`LOG(f)`       |
  `g=log(1+laplacei(x*f));LEFT(laplace(g))`\n`M2(f)`        | `2*f-f(0)`\n`M2i(f)`
  \      | `(f + f(0))/2`\n`MOBIUS(f)`    | See [[1](https://oeis.org/transforms.txt)]\n`MOBIUSi(f)`
  \  | See [[1](https://oeis.org/transforms.txt)]\n`NEGATE(f)`    | `(1-x/(1-x)).*f`\n`PARTITION(f)`
  | See [[1](https://oeis.org/transforms.txt)]\n`POINT(f)`     | `laplace(x*D(laplacei(f)))`\n`PRODS(f)`
  \    | if `f = {a0,a1,a2,...}` then `PRODS(f)={a0,a0*a1,a0*a1*a2,...}`\n`PSUM(f)`
  \     | `f/(1-x)`\n`PSUMSIGN(f)`  | `f/(1+x)`\n`REVERT(f)`    | `LEFT(revert(x*f))`\n`REVEGF(f)`
  \   | `LEFT(laplace(revert((x*f)./(1+x*laplace(1/(1-x))))))`\n`RIGHT(f)`     | `1+x*f`\n`STIRLING(f)`
  \ | `g=laplacei(x*f);laplace(g@({0,1/n!}))/x`\n`STIRLINGi(f)` | `g=laplacei(x*f);laplace(g@({0,(-1)^(n+1)/n!}))/x`\n`T019(f)`
  \     | if `f={a[n]}` then `{a[n+2]-2*a[n+1]+a[n]}`\n`TRISECT0(f)`  | if `f={a0,a1,a2,a3,a4,...}`
  then `TRISECT0(f)={a0,a3,a6,...}`\n`TRISECT1(f)`  | if `f={a0,a1,a2,a3,a4,...}`
  then `TRISECT0(f)={a1,a4,a7,...}`\n`TRISECT2(f)`  | if `f={a0,a1,a2,a3,a4,...}`
  then `TRISECT0(f)={a2,a5,a8,...}`\n`WEIGHT(f)`    | if `f={a0,a1,a2,...}` then `WEIGHT(f)=(1+x^n)^a0*(1+x^n)^a1*...`\n\n[1]
  <https://oeis.org/transforms.txt>\n\n### Tagging sequences\n\n```\n$ printf \"1,1,2,5,17,33\\n1,1,2,5,19,34\\n\"
  | hops --tag 1\nTAG000001 => {1,1,2,5,17,33}\nTAG000002 => {1,1,2,5,19,34}\n```\n\n##
  The man page\n\nFor further information regarding command line options to `hops`
  see the\n[man page](https://github.com/akc/hops/blob/master/hops.md).\n\n## A grammar
  for HOPS programs\n\n```\nhops ::= prg { \"\\n\" prg }\n\nprg ::= cmd { \";\" cmd
  }\n\ncmd ::= expr0 | name \"=\" expr0\n\nexpr0 ::= expr0 (\"+\" | \"-\") expr0 |
  expr1\n\nexpr1 ::= expr1 (\"*\" | \"/\" | \".*\" | \"./\") expr1 | expr2\n\nexpr2
  ::= expr3 \"^\" expr2 | expr3\n\nexpr3 ::= (\"-\" | \"+\") expr3 | expr4 \"!\" |
  name \"(\" expr4 \")\"\n          | expr4 \"@\" expr4\n          | expr4\n\nexpr4
  ::= \"x\" | anum | tag | name | literal | \"{\" { terms } \"}\"\n          | expr0\n\nliteral
  ::= int\n\nint ::= digit { digit }\n\ndigit ::= \"0\" | \"1\" | ... | \"9\"\n\nalpha
  ::= \"A\" | \"B\" | ... | \"Z\" | \"a\" | \"b\" | ... | \"z\"\n\nalphanum ::= alpha
  | digit\n\nname ::= alphanum { alphanum | \"_\" }\n\nterms ::= cexpr0 { \",\" expr0
  } (\"...\" | cexpr0 | fun)\n\nfun ::= the same as cexpr0 except literal = linear\n\nlinear
  ::= int | int \"*n\"\n\ncexpr0 ::= cexpr0 (\"+\" | \"-\") cexpr0 | cexpr1\n\ncexpr1
  ::= cexpr1 (\"*\" | \"/\") cexpr1 | cexpr2\n\ncexpr2 ::= cexpr3 \"^\" cexpr2 | cexpr3\n\ncexpr3
  ::= (\"+\" | \"-\") cexpr3 | cexpr4 \"!\" | cexpr4\n\ncexpr4 ::= literal | cexpr0\n```\n\n##
  Issues\n\nHave you found a bug? Want to contribute to `hops`? Please open an issue\nat
  <https://github.com/akc/hops/issues>.\n\n## How to cite\n\n```\n@misc{hops,\n  author
  = \"Anders Claesson\",\n  title  = \"HOPS: Hackable Operations on Power Series\",\n
  \ year   =  2015,\n  howpublished = \"\\url{http://akc.is/hops}\"\n}\n```\n\n##
  License\n\nBSD-3: see the\n[LICENSE](https://github.com/akc/hops/blob/master/LICENSE)
  file.\n"
license-name: BSD3
