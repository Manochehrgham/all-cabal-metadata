changelog-type: ''
hash: 2ae80059ecf148926a0a10d953efcfee4425e9bfbc81ba8d4c2d1e0242e4d910
synopsis: Minimum fuss normally distributed random values.
changelog: ''
all-versions:
- '1.0'
- '1.1'
- '1.1.0.1'
- '1.1.0.2'
- '1.1.0.3'
latest: '1.1.0.3'
description-type: haddock
description: ! 'This purpose of this library is to have a simple API and no

  dependencies beyond Haskell 98 in order to let you produce

  normally distributed random values with a minimum of fuss. This

  library does /not/ attempt to be blazingly fast nor to pass

  stringent tests of randomness. It attempts to be very easy to

  install and use while being \"good enough\" for many applications

  (simulations, games, etc.). The API builds upon and is largely

  analogous to that of the Haskell 98 @Random@ module (more

  recently @System.Random@).


  Pure:


  > (sample,g) = normal  myRandomGen  -- using a Random.RandomGen

  > samples    = normals myRandomGen  -- infinite list

  > samples2   = mkNormals 10831452   -- infinite list using a seed


  In the IO monad:


  > sample    <- normalIO

  > samples   <- normalsIO  -- infinite list


  With custom mean and standard deviation:


  > (sample,g) = normal''    (mean,sigma) myRandomGen

  > samples    = normals''   (mean,sigma) myRandomGen

  > samples2   = mkNormals'' (mean,sigma) 10831452


  > sample    <- normalIO''  (mean,sigma)

  > samples   <- normalsIO'' (mean,sigma)


  Internally the library uses the Box-Muller method to generate

  normally distributed values from uniformly distributed random values.

  If more than one sample is needed taking samples off an infinite

  list (created by e.g. ''normals'') will be roughly twice as efficient

  as repeatedly generating individual samples with e.g. ''normal''.'
