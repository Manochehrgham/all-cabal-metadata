homepage: https://github.com/schell/varying
changelog-type: markdown
hash: 5cadcb10a9d18df5753b7deb92fdc568c9b9cbff8ba8cc1e906b074d70c9be66
test-bench-deps: {}
maintainer: schell.scivally@synapsegroup.com
synopsis: FRP through varying values and monadic splines.
changelog: ! 'change log

  ==========


  0.1.5.0 - added Control.Varying.Spline

'
basic-deps:
  base: ! '>=4.7 && <4.9'
  time: ==1.5.*
  transformers: ==0.4.*
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.1.0.2'
- '0.1.0.3'
- '0.1.1.0'
- '0.1.1.1'
- '0.1.1.2'
- '0.1.2.0'
- '0.1.3.0'
- '0.1.4.0'
- '0.1.5.0'
author: Schell Scivally
latest: '0.1.5.0'
description-type: markdown
description: ! "# varying\n[![Hackage](https://img.shields.io/hackage/v/varying.svg)](http://hackage.haskell.org/package/varying)\n[![Build
  Status](https://travis-ci.org/schell/varying.svg)](https://travis-ci.org/schell/varying)\n\nThis
  library provides automaton based varying values useful for both functional\nreactive
  programming (FRP) and locally stateful programming (LSP). It is \ninfluenced by
  the [netwire](http://hackage.haskell.org/package/netwire) and \n[auto](http://hackage.haskell.org/package/auto)
  packages. Unlike netwire the \nconcepts of inhibition and time are explicit (through
  `Control.Varying.Event` \nand `Control.Varying.Time`) and the library aims at being
  minimal and well \ndocumented with a small API.\n\nDepending on your types and values
  varying can provide discrete or continuous\ntime semantics.\n\n## Getting started\n\n```haskell\nmodule
  Main where\n\nimport Control.Varying\nimport Control.Varying.Time as Time -- time
  is not auto-exported\nimport Text.Printf\n\n-- | A simple 2d point type.\ndata Point
  = Point { x :: Float\n                   , y :: Float\n                   } deriving
  (Show, Eq)\n\n-- | Our Point value that varies over time continuously in x and y.\nbackAndForth
  :: Var IO a Point\nbackAndForth =\n    -- Here we use Applicative to construct a
  varying Point that takes time\n    -- as an input.\n    (Point <$> tweenx <*> tweeny)\n
  \       -- Here we feed the varying Point a time signal using the 'plug left'\n
  \       -- function. We could similarly use the 'plug right' (~>) function\n        --
  and put the time signal before the Point. This is needed because the\n        --
  tweens take time as an input.\n        <~ time\n\n-- An exponential tween back and
  forth from 0 to 100 over 2 seconds.\ntweenx :: Monad m => Var m Float Float\ntweenx
  =\n    -- Tweens only happen for a certain duration and so their sample\n    --
  values have the type (Ord t, Fractional t => Event t). After construction\n    --
  a tween's full type will be\n    -- (Ord t, Fractional t, Monad m) => Var m t (Event
  t).\n     tween easeOutExpo 0 100 1\n         -- We can chain another tween back
  to the starting position using\n         -- `andThenE`, which will sample the first
  tween until it ends and then\n         -- switch to sampling the next tween.\n         `andThenE`\n
  \            -- Tween back to the starting position.\n             tween easeOutExpo
  100 0 1\n                 -- At this point our resulting sample values will still
  have the\n                 -- type (Event Float). The tween as a whole will be an
  event\n                 -- stream. The tween also only runs back and forth once.
  We'd\n                 -- like the tween to loop forever so that our point cycles
  back\n                 -- and forth between 0 and 100 indefinitely.\n                 --
  We can accomplish this with recursion and the `andThen`\n                 -- combinator,
  which samples an event stream until it\n                 -- inhibits and then switches
  to a normal value stream (a\n                 -- varying value). Put succinctly,
  it disolves our events into\n                 -- values.\n                 `andThen`
  tweenx\n\n-- A quadratic tween back and forth from 0 to 100 over 2 seconds.\ntweeny
  :: Monad m => Var m Float Float\ntweeny =\n    tween easeOutQuad 0 100 1 `andThenE`
  tween easeOutQuad 100 0 1 `andThen` tweeny\n\n-- Our time signal.\ntime :: Var IO
  a Float\ntime = deltaUTC\n\nmain :: IO ()\nmain = do\n    putStrLn \"Varying Values\"\n
  \   loop backAndForth\n        where loop :: Var IO () Point -> IO ()\n              loop
  v = do (point, vNext) <- runVar v ()\n                          printf \"\\nPoint
  %03.1f %03.1f\" (x point) (y point)\n                          loop vNext\n```\n"
license-name: MIT
