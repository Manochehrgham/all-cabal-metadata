homepage: https://github.com/schell/varying
changelog-type: ''
hash: 15a3da47670296360ef1deac630c7e8115a7ec56b19cb08f34b8079e83bdccf2
test-bench-deps: {}
maintainer: schell.scivally@synapsegroup.com
synopsis: Automaton based varying values, event streams and tweening.
changelog: ''
basic-deps:
  base: ==4.8.*
  time: ==1.5.*
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.1.0.2'
- '0.1.0.3'
author: Schell Scivally
latest: '0.1.0.3'
description-type: markdown
description: ! "# varying\nThis library provides automaton based varying values useful
  for both functional\nreactive programming (FRP) and locally stateful programming
  (LSP). It is \ninfluenced by the [netwire](http://hackage.haskell.org/package/netwire)
  and \n[auto](http://hackage.haskell.org/package/auto) packages. Unlike netwire the
  \nconcepts of inhibition and time are explicit (through `Control.Varying.Event`
  \nand `Control.Varying.Time`) and the library aims at being minimal and well \ndocumented
  with a small API.\n\nDepending on your types and values varying can provide discrete
  or continuous\ntime semantics.\n\n## Getting started\n\n```haskell\nmodule Main
  where\n\nimport Control.Varying\nimport Control.Varying.Time as Time -- time is
  not auto-exported\nimport Text.Printf\n\n-- | A simple 2d point type.\ndata Point
  = Point { x :: Float\n                   , y :: Float\n                   } deriving
  (Show, Eq)\n\n-- | Our Point value that varies over time continuously in x and y.\nbackAndForth
  :: Var IO a Point\nbackAndForth =\n    -- Here we use Applicative to construct a
  varying Point that takes time\n    -- as an input.\n    (Point <$> tweenx <*> tweeny)\n
  \       -- Here we feed the varying Point a time signal using the 'plug left'\n
  \       -- function. We could similarly use the 'plug right' (~>) function\n        --
  and put the time signal before the Point. This is needed because the\n        --
  tweens take time as an input.\n        <~ time\n\n-- An exponential tween back and
  forth from 0 to 100 over 2 seconds.\ntweenx :: Monad m => Var m Float Float\ntweenx
  =\n    -- Tweens only happen for a certain duration and so their sample\n    --
  values have the type (Ord t, Fractional t => Event t). After construction\n    --
  a tween's full type will be\n    -- (Ord t, Fractional t, Monad m) => Var m t (Event
  t).\n     tween easeOutExpo 0 100 1\n         -- We can chain another tween back
  to the starting position using\n         -- `andThenE`, which will sample the first
  tween until it ends and then\n         -- switch to sampling the next tween.\n         `andThenE`\n
  \            -- Tween back to the starting position.\n             tween easeOutExpo
  100 0 1\n                 -- At this point our resulting sample values will still
  have the\n                 -- type (Event Float). The tween as a whole will be an
  event\n                 -- stream. The tween also only runs back and forth once.
  We'd\n                 -- like the tween to loop forever so that our point cycles
  back\n                 -- and forth between 0 and 100 indefinitely.\n                 --
  We can accomplish this with recursion and the `andThen`\n                 -- combinator,
  which samples an event stream until it\n                 -- inhibits and then switches
  to a normal value stream (a\n                 -- varying value). Put succinctly,
  it disolves our events into\n                 -- values.\n                 `andThen`
  tweenx\n\n-- A quadratic tween back and forth from 0 to 100 over 2 seconds.\ntweeny
  :: Monad m => Var m Float Float\ntweeny =\n    tween easeOutQuad 0 100 1 `andThenE`
  tween easeOutQuad 100 0 1 `andThen` tweeny\n\n-- Our time signal.\ntime :: Var IO
  a Float\ntime = deltaUTC\n\nmain :: IO ()\nmain = do\n    putStrLn \"Varying Values\"\n
  \   loop backAndForth\n        where loop :: Var IO () Point -> IO ()\n              loop
  v = do (point, vNext) <- runVar v ()\n                          printf \"\\nPoint
  %03.1f %03.1f\" (x point) (y point)\n                          loop vNext\n```\n"
license-name: MIT
