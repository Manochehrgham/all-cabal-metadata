homepage: https://github.com/schell/varying
changelog-type: markdown
hash: bf24fba90229e8d985dc92dd1e360d12786191d0f4e63f4a239de399ada8e042
test-bench-deps: {}
maintainer: schell.scivally@synapsegroup.com
synopsis: FRP through value streams and monadic splines.
changelog: ! "change log\n==========\n\n0.1.5.0 - added Control.Varying.Spline\n0.2.0.0
  - reordered spline type variables for MonadTrans\n0.3.0.0 - updated the type of
  mapOutput to a more friendly, usable signature\n          bug fixes\n\n"
basic-deps:
  base: ! '>=4.7 && <4.9'
  time: ==1.5.*
  transformers: ==0.4.*
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.1.0.2'
- '0.1.0.3'
- '0.1.1.0'
- '0.1.1.1'
- '0.1.1.2'
- '0.1.2.0'
- '0.1.3.0'
- '0.1.4.0'
- '0.1.5.0'
- '0.2.0.0'
- '0.3.0.0'
- '0.3.0.1'
author: Schell Scivally
latest: '0.3.0.1'
description-type: markdown
description: ! "# varying\n[![Hackage](https://img.shields.io/hackage/v/varying.svg)](http://hackage.haskell.org/package/varying)\n[![Build
  Status](https://travis-ci.org/schell/varying.svg)](https://travis-ci.org/schell/varying)\n\nThis
  library provides automaton based value streams useful for both functional\nreactive
  programming (FRP) and locally stateful programming (LSP). It is \ninfluenced by
  the [netwire](http://hackage.haskell.org/package/netwire) and \n[auto](http://hackage.haskell.org/package/auto)
  packages. Unlike netwire the \nconcepts of inhibition and time are explicit (through
  `Control.Varying.Event` \nand `Control.Varying.Time`). The library aims at being
  minimal and well \ndocumented with a small API.\n\n## Getting started\n\n```haskell\nmodule
  Main where\n\nimport Control.Varying\nimport Control.Applicative\nimport Text.Printf\n\n--
  | A simple 2d point type.\ndata Point = Point { px :: Float\n                   ,
  py :: Float\n                   } deriving (Show, Eq)\n\n-- An exponential tween
  back and forth from 0 to 100 over 2 seconds that\n-- loops forever. This spline
  takes float values of delta time as input,\n-- outputs the current x value at every
  step and would result in () if it\n-- terminated.\ntweenx :: (Applicative m, Monad
  m) => Spline Float Float m ()\ntweenx = do\n    -- Tween from 0 to 100 over 1 second\n
  \   x <- tween easeOutExpo 0 100 1\n    -- Chain another tween back to the starting
  position\n    _ <- tween easeOutExpo x 0 1\n    -- Loop forever\n    tweenx\n\n--
  A quadratic tween back and forth from 0 to 100 over 2 seconds that never\n-- ends.\ntweeny
  :: (Applicative m, Monad m) => Spline Float Float m ()\ntweeny = do\n    y <- tween
  easeOutQuad 0 100 1\n    _ <- tween easeOutQuad y 0 1\n    tweeny\n\n-- Our time
  signal that provides delta time samples.\ntime :: Var IO a Float\ntime = deltaUTC\n\n--
  | Our Point value that varies over time continuously in x and y.\nbackAndForth ::
  Var IO a Point\nbackAndForth =\n    -- Turn our splines back into continuous value
  streams. We must provide\n    -- a starting value since splines are not guaranteed
  to be defined at\n    -- their edges.\n    let x = execSpline 0 tweenx\n        y
  = execSpline 0 tweeny\n    in\n    -- Construct a varying Point that takes time
  as an input.\n    (Point <$> x <*> y)\n        -- Stream in a time signal using
  the 'plug left' combinator.\n        -- We could similarly use the 'plug right'
  (~>) function\n        -- and put the time signal before the construction above.
  This is needed\n        -- because the tween streams take time as an input.\n        <~
  time\n\nmain :: IO ()\nmain = do\n    putStrLn \"Varying Example\"\n    loop backAndForth\n
  \       where loop :: Var IO () Point -> IO ()\n              loop v = do (point,
  vNext) <- runVar v ()\n                          printf \"\\nPoint %03.1f %03.1f\"
  (px point) (py point)\n                          loop vNext\n```\n"
license-name: MIT
