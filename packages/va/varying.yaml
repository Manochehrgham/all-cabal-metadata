homepage: https://github.com/schell/varying
changelog-type: markdown
hash: 938ce86489f40d1a10a7bc93377c4c5d504ce10577ff76f27fd2ab10cac086f3
test-bench-deps:
  varying: -any
  base: ! '>=4.7 && <4.9'
  time: ! '>=1.5 && <1.6'
  hspec: -any
  transformers: -any
  QuickCheck: -any
maintainer: schell.scivally@synapsegroup.com
synopsis: FRP through value streams and monadic splines.
changelog: ! "change log\n==========\n\n0.1.5.0 - added Control.Varying.Spline\n\n0.2.0.0
  - reordered spline type variables for MonadTrans\n\n0.3.0.0 - updated the type of
  mapOutput to a more friendly, usable signature\n          bug fixes\n\n0.3.1.0 -
  added stepMany, eitherE\n\n0.4.0.0 - Var and Spline are now parameterized with Identity,
  removed mix, changed\n          the behavior of race, added untilEvent variants,
  added tests.\n"
basic-deps:
  varying: -any
  base: ! '>=4.7 && <4.9'
  time: ==1.5.*
  transformers: ==0.4.*
all-versions:
- '0.1.1.2'
- '0.1.2.0'
- '0.1.3.0'
- '0.1.4.0'
- '0.1.5.0'
- '0.2.0.0'
- '0.3.0.0'
- '0.3.0.1'
- '0.4.0.0'
author: Schell Scivally
latest: '0.4.0.0'
description-type: markdown
description: ! "# varying\n[![Hackage](https://img.shields.io/hackage/v/varying.svg)](http://hackage.haskell.org/package/varying)\n[![Build
  Status](https://travis-ci.org/schell/varying.svg)](https://travis-ci.org/schell/varying)\n\nThis
  library provides automaton based value streams useful for both functional\nreactive
  programming (FRP) and locally stateful programming (LSP). It is \ninfluenced by
  the [netwire](http://hackage.haskell.org/package/netwire) and \n[auto](http://hackage.haskell.org/package/auto)
  packages. Unlike netwire the \nconcepts of inhibition and time are explicit (through
  `Control.Varying.Event` \nand `Control.Varying.Time`). The library aims at being
  minimal and well \ndocumented with a small API.\n\n## Getting started\n\n```haskell\nmodule
  Main where\n\nimport Control.Varying\nimport Control.Applicative\nimport Text.Printf\nimport
  Data.Functor.Identity\n\n-- | A simple 2d point type.\ndata Point = Point { px ::
  Float\n                   , py :: Float\n                   } deriving (Show, Eq)\n\n--
  An exponential tween back and forth from 0 to 100 over 2 seconds that\n-- loops
  forever. This spline takes float values of delta time as input,\n-- outputs the
  current x value at every step and would result in () if it\n-- terminated.\ntweenx
  :: (Applicative m, Monad m) => SplineT Float Float m ()\ntweenx = do\n    -- Tween
  from 0 to 100 over 1 second\n    x <- tween easeOutExpo 0 100 1\n    -- Chain another
  tween back to the starting position\n    _ <- tween easeOutExpo x 0 1\n    -- Loop
  forever\n    tweenx\n\n-- A quadratic tween back and forth from 0 to 100 over 2
  seconds that never\n-- ends.\ntweeny :: (Applicative m, Monad m) => SplineT Float
  Float m ()\ntweeny = do\n    y <- tween easeOutQuad 0 100 1\n    _ <- tween easeOutQuad
  y 0 1\n    tweeny\n\n-- Our time signal that provides delta time samples.\ntime
  :: VarT IO a Float\ntime = deltaUTC\n\n-- | Our Point value that varies over time
  continuously in x and y.\nbackAndForth :: VarT IO a Point\nbackAndForth =\n    --
  Turn our splines into continuous output streams. We must provide\n    -- a starting
  value since splines are not guaranteed to be defined at\n    -- their edges.\n    let
  x = outputStream 0 tweenx\n        y = outputStream 0 tweeny\n    in\n    -- Construct
  a varying Point that takes time as an input.\n    (Point <$> x <*> y)\n        --
  Stream in a time signal using the 'plug left' combinator.\n        -- We could similarly
  use the 'plug right' (~>) function\n        -- and put the time signal before the
  construction above. This is needed\n        -- because the tween streams take time
  as an input.\n        <~ time\n\nmain :: IO ()\nmain = do\n    putStrLn \"An example
  of value streams using the varying library.\"\n    putStrLn \"Enter a newline to
  continue, quit with ctrl+c\"\n    _ <- getLine\n\n    loop backAndForth\n        where
  loop :: VarT IO () Point -> IO ()\n              loop v = do (point, vNext) <- runVarT
  v ()\n                          printf \"\\nPoint %03.1f %03.1f\" (px point) (py
  point)\n                          loop vNext\n\n```\n"
license-name: MIT
