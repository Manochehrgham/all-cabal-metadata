changelog-type: ''
hash: a530c1f4352d95ffece7d6aa34973a74ec82d3eada623d54a1a9d03eaef90218
synopsis: A declarative make-like interpreter.
changelog: ''
all-versions:
- '1.0'
- '1.1'
- '1.1.0.1'
- '1.1.0.2'
- '1.1.0.3'
latest: '1.1.0.3'
description-type: haddock
description: ! 'Grow is a well-defined replacement for Makefiles and the like to build
  complex

  hierarchies of files with minimal effort.


  Like many Makefile-like tools, Grow depends on the notion of

  timestamps to determine whether a file should be recompiled or

  not. Grow is much simpler than those, though, and I might argue way

  easier to use as well.


  On startup, Grow will look for a file named "Seed" in the current

  directory, and evaluate the grow expressions contained within.


  For example, here is a simple Seed file to compile a single C file

  into an executable.


  > tee $$arg:in

  >   all = ($main:seq "All done !"):in $execs

  >   execs = hook ld [main] [main.o] :in $objects

  >   objects = hook cc [main.o] [main.c]


  Notice the `hook` function ? It is the Grow primitive that calls an

  external program to perform actual tasks.


  In Grow, hooks are expected to only accept files as their arguments,

  so we have to write the wrapper scripts `cc` and `ld` that accept

  arguments in the form "<destination>... <source>...". They are pretty

  trivial to write since they only involve renaming variables and

  swapping arguments.


  Here are sample `cc` and `ld` scripts to show you there is nothing

  magical about them :


  > #!/bin/bash

  > obj="$1" ; shift ; src="$1"

  > gcc -c "$src" -o "$obj"


  > #!/bin/bash

  > bin="$1" ; shift ; obj="$1"

  > gcc "$obj" -o "$bin"


  In grow, instead of writing recipes in the configuration, we just declare

  hooks and then write the appropriate wrapper scripts to call compilers with

  the correct flags and arguments.'
