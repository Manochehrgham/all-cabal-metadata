homepage: https://github.com/myfreeweb/pcre-heavy
changelog-type: ''
hash: b5568ac99be206dd013db575e61730e3c07b6bc308216f4fdbeacdd4addfee64
test-bench-deps:
  base: ! '>=4.0.0.0 && <5'
  doctest: ==0.*
  Glob: ==0.*
maintainer: greg@unrelenting.technology
synopsis: A regexp library on top of pcre-light you can actually use.
changelog: ''
basic-deps:
  pcre-light: -any
  bytestring: -any
  base: ! '>=4.0.0.0 && <5'
  stringable: -any
  template-haskell: -any
all-versions:
- '0.1.0'
- '0.2.0'
- '0.2.1'
- '0.2.2'
author: Greg V
latest: '0.2.2'
description-type: markdown
description: ! "# pcre-heavy [![Hackage](https://img.shields.io/hackage/v/pcre-heavy.svg?style=flat)](https://hackage.haskell.org/package/pcre-heavy)
  [![ISC License](https://img.shields.io/badge/license-ISC-red.svg?style=flat)](https://tldrlegal.com/license/-isc-license)\n\n*Finally!*
  A Haskell regular expressions library that does not suck.\n\n- based on [pcre-light],
  none of that regex-compat-pluggable-backend stuff\n- takes and returns [Stringables]
  everywhere, use ANY STRING TYPE (String, ByteString, LByteString, Text, LText, FilePath)
  -- but you need a bit more type annotations than usual\n- a QuasiQuoter for regexps
  that does compile time checking (BTW, [vim2hs] has correct syntax highlighting for
  that!)\n- **SEARCHES FOR MULTIPLE MATCHES! DOES REPLACEMENT!**\n\n[pcre-light]:
  https://hackage.haskell.org/package/pcre-light\n[Stringables]: https://hackage.haskell.org/package/stringable\n[vim2hs]:
  https://github.com/dag/vim2hs#quasi-quoting\n\n## Usage\n\n```haskell\n{-# LANGUAGE
  QuasiQuotes #-}\nimport           Text.Regex.PCRE.Heavy\n```\n\n### Checking\n\n```haskell\n>>>
  \"https://unrelenting.technology\" =~ [re|^http.*|]\nTrue\n```\n\nFor `UnicodeSyntax`
  fans, it's also available as ≈ (U+2248 ALMOST EQUAL TO):\n\n```haskell\n>>> \"https://unrelenting.technology\"
  ≈ [re|^http.*|]\nTrue\n```\n\n### Matching (Searching)\n\n(You can use any string
  type, not just String!)\n\n`scan` returns all matches as pairs like `(fullmatch,
  [group, group...])`.\n\n```haskell\n>>> scan [re|\\s*entry (\\d+) (\\w+)\\s*&?|]
  \" entry 1 hello  &entry 2 hi\" :: [(String, [String])]\n[\n  (\" entry 1 hello
  \ &\", [\"1\", \"hello\"])\n, (\"entry 2 hi\",        [\"2\", \"hi\"])\n]\n```\n\nIt
  is lazy!\nIf you only need the first match, use `head` (or, much better, `headMay`
  from [safe]) -- no extra work will be performed!\n\n```haskell\n>>> headMay $ scan
  [re|\\s*entry (\\d+) (\\w+)\\s*&?|] \" entry 1 hello  &entry 2 hi\"\nJust (\" entry
  1 hello  &\", [\"1\", \"hello\"])\n```\n\n[safe]: https://hackage.haskell.org/package/safe\n\n###
  Replacement\n\n`sub` replaces the first match, `gsub` replaces all matches.\n\n```haskell\n--
  You can use a Stringable type as the replacement...\n>>> gsub [re|\\d+|] \"!!!NUMBER!!!\"
  \"Copyright (c) 2015 The 000 Group\"\n\"Copyright (c) !!!NUMBER!!! The !!!NUMBER!!!
  Group\"\n\n-- or a (Stringable a => [a] -> a) function -- that will get the groups...\n>>>
  gsub [re|%(\\d+)(\\w+)|] (\\(d:w:_) -> \"{\" ++ d ++ \" of \" ++ w ++ \"}\" :: String)
  \"Hello, %20thing\"\n\"Hello, {20 of thing}\"\n\n-- or a (Stringable a => a -> a)
  function -- that will get the full match...\n>>> gsub [re|-\\w+|] (\\x -> \"+\"
  ++ (reverse $ drop 1 x) :: String) \"hello -world\"\n\"hello +dlrow\"\n\n-- or a
  (Stringable a => a -> [a] -> a) function.\n-- That will get both the full match
  and the groups.\n-- I have no idea why you would want to use that, but that's there
  :-)\n```\n\n### Splitting\n\n`split`, well, splits.\n\n```haskell\n>>> split [re|%(begin|next|end)%|]
  \"%begin%hello%next%world%end%\"\n[\"\",\"hello\",\"world\",\"\"]\n```\n\n### Options\n\nYou
  can pass `pcre-light` options by using the `somethingO` variants of functions (and
  `mkRegexQQ` for compile time options):\n\n```haskell\n>>> let myRe = mkRegexQQ [multiline,
  utf8, ungreedy]\n>>> scanO [myRe|\\s*entry (\\d+) (\\w+)\\s*&?|] [exec_no_utf8_check]
  \" entry 1 hello  &entry 2 hi\" :: [[String]]\n>>> gsubO [myRe|\\d+|] [exec_notempty]
  \"!!!NUMBER!!!\" \"Copyright (c) 2015 The 000 Group\"\n```\n\n`utf8` is passed by
  default in the `re` QuasiQuoter.\n\n## License\n\nCopyright 2015 Greg V <greg@unrelenting.technology>
  \ \nAvailable under the ISC license, see the `COPYING` file\n"
license-name: OtherLicense
