changelog-type: ''
hash: ebec5c0ee4c8da5c1ae8cbddadda4bc83914f6285f34f6ec11d5538be431d00e
synopsis: Applicative-based numeric instances
changelog: ''
all-versions:
- '0.0.0'
- '0.0.2'
- '0.0.3'
- '0.0.4'
- '0.0.5'
- '0.0.6'
- '0.0.7'
- '0.0.8'
- '0.0.9'
- '0.1.2'
- '0.1.3'
latest: '0.1.3'
description-type: haddock
description: ! 'Any applicative functor can be given numeric instances in a boilerplate
  way.

  The /applicative-numbers/ package provides an include file that makes it a

  snap to define these instances.

  See "Data.Numeric.Function" for an example.


  Project wiki page: <http://haskell.org/haskellwiki/applicative-numbers>


  Copyright 2009-2013 Conal Elliott; BSD3 license.



  Instances of @Num@ classes for applicative functors.  To be @#include@''d after

  defining @APPLICATIVE@ as the applicative functor name and @CONSTRAINTS@ as a

  list of constraints, which must carry its own trailing comma if non-empty.

  The @APPLICATIVE@ symbol gets @#undef@''d at the end of the include file, so

  that multiple includes are convenient.


  For instance,


  @

  #define INSTANCE_Ord

  #define INSTANCE_Enum


  #define APPLICATIVE Vec2

  #include \"ApplicativeNumeric-inc.hs\"


  #define APPLICATIVE Vec3

  #include \"ApplicativeNumeric-inc.hs\"


  #define APPLICATIVE Vec4

  #include \"ApplicativeNumeric-inc.hs\"

  @


  You''ll also have to import ''pure'' and ''liftA2'' from "Control.Applicative"

  and specify @the FlexibleContexts@ language extension (due to an implementation
  hack).


  Some instances are generated only if a corresponding CPP symbol is

  defined: @INSTANCE_Eq@, @INSTANCE_Ord@, @INSTANCE_Show@, @INSTANCE_Enum@'
