changelog-type: ''
hash: cce7933713cd81c6ce361c88197eb95ecba502bc1c6cdfa7759ce24842e1507b
test-bench-deps: {}
synopsis: Discrete constraint satisfaction problem (CSP) solvers.
changelog: ''
basic-deps:
  base: ! '>=3 && <5'
  nondeterminism: -any
  containers: -any
  mtl: ! '>=2'
all-versions:
- '1.0'
latest: '1.0'
description-type: markdown
description: ! "# CSP\n\nA simple example which solves Sudoku puzzles, project Euler
  problem 96.\n\n    solveSudoku :: (Enum a, Eq a, Num a) => [[a]] -> [[a]]\n    solveSudoku
  puzzle = oneCSPSolution $ do\n      dvs <- mapM (mapM (\\a -> mkDV $ if a == 0 then
  [1 .. 9] else [a])) puzzle\n      mapM_ assertRowConstraints dvs\n      mapM_ assertRowConstraints
  $ transpose dvs\n      sequence_ [assertSquareConstraints dvs x y | x <- [0,3,6],
  y <- [0,3,6]]\n      return dvs\n          where assertRowConstraints =  mapAllPairsM_
  (constraint2 (/=))\n                assertSquareConstraints dvs i j = \n                    mapAllPairsM_
  (constraint2 (/=)) [(dvs !! x) !! y | x <- [i..i+2], y <- [j..j+2]]\n\n    sudoku3
  = [[0,0,0,0,0,0,9,0,7],\n               [0,0,0,4,2,0,1,8,0],\n               [0,0,0,7,0,5,0,2,6],\n
  \              [1,0,0,9,0,4,0,0,0],\n               [0,5,0,0,0,0,0,4,0],\n               [0,0,0,5,0,7,0,0,9],\n
  \              [9,2,0,1,0,8,0,0,0],\n               [0,3,4,0,5,9,0,0,0],\n               [5,0,7,0,0,0,0,0,0]]\n\n
  \   mapAllPairsM_ :: Monad m => (a -> a -> m b) -> [a] -> m ()\n    mapAllPairsM_
  f []     = return ()\n    mapAllPairsM_ f (_:[]) = return ()\n    mapAllPairsM_
  f (a:l) = mapM_ (f a) l >> mapAllPairsM_ f l\n\n    solveSudoku sudoku3\n\n## Future\n\n
  - Docs!\n - Allow a randomized execution order for CSPs\n - CSPs don't need use
  IO internally. ST is enough.\n - Constraint synthesis. Already facilitated by the
  fact that\n   constraints are internally nondeterministic\n - Other constraint types
  for CSPs, right now only AC is implemented\n - n-ary heterogeneous constraints \n"
