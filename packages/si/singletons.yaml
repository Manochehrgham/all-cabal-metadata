homepage: http://www.cis.upenn.edu/~eir/packages/singletons
changelog-type: markdown
hash: 17dcfb5df91737c09d0d117ebc94f128952702744c9ec29e2c746b4897778fdb
test-bench-deps:
  Cabal: ! '>=1.16'
  base: ! '>=4.6 && <5'
  tasty-golden: ! '>=2.2'
  filepath: ! '>=1.3'
  process: ! '>=1.1'
  constraints: -any
  tasty: ! '>=0.6'
maintainer: Richard Eisenberg <eir@cis.upenn.edu>, Jan Stolarek <jan.stolarek@p.lodz.pl>
synopsis: A framework for generating singleton types
changelog: ! 'Changelog for singletons project

  ================================


  1.1.2.1

  -------


  Fix bug #116, thus allowing locally-declared symbols to be used in GHC 7.10.



  1.1.2

  -----


  Fix warnings and Haddock failure with GHC 7.10.1.


  1.1.1

  -----


  Update testsuite to work with th-desugar-1.5.2. No functional changes.


  1.1

  ---


  This is a maintenance release to support building (but *not* testing, due to

  GHC bug #10058) with 7.10. This release also targets th-desugar-1.5. Some

  types changed (using th-desugar''s new `DsMonad` instead of `Quasi`), but

  clients generally won''t need to make any changes, unless they, too, generalize

  over `Quasi`.


  1.0

  ---


  This is a complete rewrite of the package.


  * A much wider array of surface syntax is now accepted for promotion

  and singletonization, including `let`, `case`, partially-applied functions,

  and anonymous functions, `where`, sections, among others.


  * Classes and instances can be promoted (but not singletonized).


  * Derivation of promoted instances for `Ord` and `Bounded`.


  This release can be seen as a "technology preview". More features are coming

  soon.


  This version drops GHC 7.6 support.


  0.10.0

  ------


  Template Haskell names are now more hygienic. In other words, `singletons`

  won''t try to gobble up something happened to be named `Sing` in your project.

  (Note that the Template Haskell names are not *completely* hygienic; names

  generated during singleton generation can still cause conflicts.)


  If a function to be promoted or singletonized is missing a type signature,

  that is now an *error*, not a warning.


  Added a new external module Data.Singletons.TypeLits, which contain the

  singletons for GHC.TypeLits. Some convenience functions are also provided.


  The extension `EmptyCase` is no longer needed. This caused pain when trying

  to support both GHC 7.6.3 and 7.8.


  0.9.3

  -----


  Fix export list of Data.Singletons.TH, again again.


  Add `SEq` instances for `Nat` and `Symbol`.


  0.9.2

  -----


  Fix export list of Data.Singletons.TH, again.


  0.9.1

  -----


  Fix export list of Data.Singletons.TH.


  0.9.0

  -----


  Make compatible with GHC HEAD, but HEAD reports core lint errors sometimes.


  Change module structure significantly. If you want to derive your own

  singletons, you should import `Data.Singletons.TH`. The module

  `Data.Singletons` now exports functions only for the *use* of singletons.


  New modules `Data.Singletons.Bool`, `...Maybe`, `...Either`, and `...List`

  are just like their equivalents from `Data.`, except for `List`, which is

  quite lacking in features.


  For singleton equality, use `Data.Singletons.Eq`.


  For propositional singleton equality, use `Data.Singletons.Decide`.


  New module `Data.Singletons.Prelude` is meant to mirror the Haskell Prelude,

  but with singleton definitions.


  Streamline representation of singletons, resulting in *exponential* speedup

  at execution. (This has not been rigorously measured, but the data structures

  are now *exponentially* smaller.)


  Add internal support for TypeLits, because the TypeLits module no longer

  exports singleton definitions.


  Add support for existential singletons, through the `toSing` method of

  `SingKind`.


  Remove the `SingE` class, bundling its functionality into `SingKind`.

  Thus, the `SingRep` synonym has also been removed.


  Name change: `KindIs` becomes `KProxy`.


  Add support for singletonizing calls to `error`.


  Add support for singletonizing empty data definitions.


  0.8.6

  -----


  Make compatible with GHC HEAD, but HEAD reports core lint errors sometimes.


  0.8.5

  -----


  Bug fix to make singletons compatible with GHC 7.6.1.


  Added git info to cabal file.


  0.8.4

  -----


  Update to work with latest version of GHC (7.7.20130114).


  Now use branched type family instances to allow for promotion of functions

  with overlapping patterns.


  Permit promotion of functions with constraints by omitting constraints.


  0.8.3

  -----


  Update to work with latest version of GHC (7.7.20121031).


  Removed use of Any to simulate kind classes; now using KindOf and OfKind

  from GHC.TypeLits.


  Made compatible with GHC.TypeLits.


  0.8.2

  -----


  Added this changelog


  Update to work with latest version of GHC (7.6.1). (There was a change to

  Template Haskell).


  Moved library into Data.Singletons.


  0.8.1

  -----


  Update to work with latest version of GHC. (There was a change to

  Template Haskell).


  Updated dependencies in cabal to include the newer version of TH.


  0.8

  ---


  Initial public release

'
basic-deps:
  base: ! '>=4.7 && <5'
  containers: ! '>=0.5'
  th-desugar: ! '>=1.5.2 && <1.6'
  mtl: ! '>=2.1.1'
  template-haskell: -any
all-versions:
- '0.8'
- '0.8.1'
- '0.8.2'
- '0.8.3'
- '0.8.4'
- '0.8.5'
- '0.8.6'
- '0.9.0'
- '0.9.1'
- '0.9.2'
- '0.9.3'
- '0.10.0'
- '1.0'
- '1.1'
- '1.1.1'
- '1.1.2'
- '1.1.2.1'
author: Richard Eisenberg <eir@cis.upenn.edu>, Jan Stolarek <jan.stolarek@p.lodz.pl>
latest: '1.1.2.1'
description-type: markdown
description: ! "singletons 1.0\n==============\n\n[![Build Status](https://travis-ci.org/goldfirere/singletons.svg?branch=master)](https://travis-ci.org/goldfirere/singletons)\n\nThis
  is the README file for the singletons library. This file contains all the\ndocumentation
  for the definitions and functions in the library.\n\nThe singletons library was
  written by Richard Eisenberg, eir@cis.upenn.edu, and\nwith significant contributions
  by Jan Stolarek, jan.stolarek@p.lodz.pl.  There\nare two papers that describe the
  library. Original one, _Dependently typed\nprogramming with singletons_, is available\n[here](http://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf)
  and will\nbe referenced in this documentation as the \"singletons paper\". A follow-up\npaper,
  _Promoting Functions to Type Families in Haskell_, will be available\nonline Real
  Soon Now and will be referenced in this documentation as the\n\"promotion paper\".\n\nPurpose
  of the singletons library\n---------------------------------\n\nThe library contains
  a definition of _singleton types_, which allow programmers\nto use dependently typed
  techniques to enforce rich constraints among the types\nin their programs. See the
  singletons paper for a more thorough introduction.\n\nThe package also allows _promotion_
  of term-level functions to type-level\nequivalents. Accordingly, it exports a Prelude
  of promoted and singletonized\nfunctions, mirroring functions and datatypes found
  in Prelude, `Data.Bool`,\n`Data.Maybe`, `Data.Either`, `Data.Tuple` and `Data.List`.
  See the promotion\npaper for a more thorough introduction.\n\nCompatibility\n-------------\n\nThe
  singletons library requires GHC 7.8.2 or greater. We plan to restore GHC\n7.6.3
  support, but no promises as to when will this happen. Any code that uses\nthe singleton
  generation primitives needs to enable a long list of GHC\nextensions. This list
  includes, but is not necessarily limited to, the\nfollowing:\n\n* `ScopedTypeVariables`\n*
  `TemplateHaskell`\n* `TypeFamilies`\n* `GADTs`\n* `KindSignatures`\n* `DataKinds`\n*
  `PolyKinds`\n* `TypeOperators`\n* `FlexibleContexts`\n* `RankNTypes`\n* `UndecidableInstances`\n*
  `FlexibleInstances`\n\nModules for singleton types\n---------------------------\n\n`Data.Singletons`
  exports all the basic singletons definitions. Import this\nmodule if you are not
  using Template Haskell and wish only to define your\nown singletons.\n\n`Data.Singletons.TH`
  exports all the definitions needed to use the Template\nHaskell code to generate
  new singletons.\n\n`Data.Singletons.Prelude` re-exports `Data.Singletons` along
  with singleton\ndefinitions for various Prelude types. This module provides a singletonized\nequivalent
  of the real `Prelude`. Note that not all functions from original\n`Prelude` could
  be turned into singletons.\n\n`Data.Singletons.Prelude.*` modules provide singletonized
  equivalents of\ndefinitions found in the following `base` library modules: `Data.Bool`,\n`Data.Maybe`,
  `Data.Either`, `Data.List`, `Data.Tuple` and `GHC.Base`. We also\nprovide singletonized
  `Eq` and `Ord` typeclasses\n\n`Data.Singletons.Decide` exports type classes for
  propositional equality.\n\n`Data.Singletons.TypeLits` exports definitions for working
  with `GHC.TypeLits`.\nIn GHC 7.6.3, `Data.Singletons.TypeLits` defines and exports
  `KnownNat` and\n`KnownSymbol`, which are part of `GHC.TypeLits` in GHC 7.8. This
  makes\ncross-version support a little easier.\n\n`Data.Singletons.Void` exports
  a `Void` type, shamelessly copied from\nEdward Kmett's `void` package, but without
  the great many package dependencies\nin `void`.\n\n`Data.Singletons.Types` exports
  a few type-level definitions that are in\n`base` for GHC 7.8, but not in GHC 7.6.3.
  By importing this package, users\nof both GHC versions can access these definitions.\n\nModules
  for function promotion\n------------------------------\n\nModules in `Data.Promotion`
  namespace provide functionality required for\nfunction promotion. They mostly re-export
  a subset of definitions from\nrespective `Data.Singletons` modules.\n\n`Data.Promotion.TH`
  exports all the definitions needed to use the Template\nHaskell code to generate
  promoted definitions.\n\n`Data.Promotion.Prelude` and `Data.Promotion.Prelude.*`
  modules re-export all\npromoted definitions from respective `Data.Singletons.Prelude`\nmodules.
  `Data.Promotion.Prelude.List` adds a significant amount of functions\nthat couldn't
  be singletonized but can be promoted. Some functions still don't\npromote - these
  are documented in the source code of the module. There is also\n`Data.Promotion.Prelude.Bounded`
  module that provides promoted `PBounded`\ntypeclass.\n\nFunctions to generate singletons\n--------------------------------\n\nThe
  top-level functions used to generate singletons are documented in the\n`Data.Singletons.TH`
  module. The most common case is just calling `singletons`,\nwhich I'll describe
  here:\n\n    singletons :: Q [Dec] -> Q [Dec]\n\nGenerates singletons from the definitions
  given. Because singleton generation\nrequires promotion, this also promotes all
  of the definitions given to the\ntype level.\n\nUsage example:\n\n```haskell\n$(singletons
  [d|\n  data Nat = Zero | Succ Nat\n  pred :: Nat -> Nat\n  pred Zero = Zero\n  pred
  (Succ n) = n\n  |])\n```\n\nDefinitions used to support singletons\n--------------------------------------\n\nPlease
  refer to the singletons paper for a more in-depth explanation of these\ndefinitions.
  Many of the definitions were developed in tandem with Iavor Diatchki.\n\n    data
  family Sing (a :: k)\n\nThe data family of singleton types. A new instance of this
  data family is\ngenerated for every new singleton type.\n\n    class SingI (a ::
  k) where\n      sing :: Sing a\n\nA class used to pass singleton values implicitly.
  The `sing` method produces\nan explicit singleton value.\n\n    data SomeSing (kproxy
  :: KProxy k) where\n      SomeSing :: Sing (a :: k) -> SomeSing ('KProxy :: KProxy
  k)\n\nThe `SomeSing` type wraps up an _existentially-quantified_ singleton. Note
  that\nthe type parameter `a` does not appear in the `SomeSing` type. Thus, this
  type\ncan be used when you have a singleton, but you don't know at compile time
  what\nit will be. `SomeSing ('KProxy :: KProxy Thing)` is isomorphic to `Thing`.\n\n
  \   class (kparam ~ 'KProxy) => SingKind (kparam :: KProxy k) where\n      type
  DemoteRep kparam :: *\n      fromSing :: Sing (a :: k) -> DemoteRep kparam\n      toSing
  \  :: DemoteRep kparam -> SomeSing kparam\n\nThis class is used to convert a singleton
  value back to a value in the\noriginal, unrefined ADT. The `fromSing` method converts,
  say, a\nsingleton `Nat` back to an ordinary `Nat`. The `toSing` method produces\nan
  existentially-quantified singleton, wrapped up in a `SomeSing`.\nThe `DemoteRep`
  associated\nkind-indexed type family maps a proxy of the kind `Nat`\nback to the
  type `Nat`.\n\n    data SingInstance (a :: k) where\n      SingInstance :: SingI
  a => SingInstance a\n    singInstance :: Sing a -> SingInstance a\n\nSometimes you
  have an explicit singleton (a `Sing`) where you need an implicit\none (a dictionary
  for `SingI`). The `SingInstance` type simply wraps a `SingI`\ndictionary, and the
  `singInstance` function produces this dictionary from an\nexplicit singleton. The
  `singInstance` function runs in constant time, using\na little magic.\n\n\nEquality
  classes\n----------------\n\nThere are two different notions of equality applicable
  to singletons: Boolean\nequality and propositional equality.\n\n* Boolean equality
  is implemented in the type family `(:==)` (which is actually\na synonym for the
  type family `(==)` from `Data.Type.Equality`) and the class\n`SEq`. See the `Data.Singletons.Prelude.Eq`
  module for more information.\n\n* Propositional equality is implemented through
  the constraint `(~)`, the type\n`(:~:)`, and the class `SDecide`. See modules `Data.Type.Equality`
  and\n`Data.Singletons.Decide` for more information.\n\nWhich one do you need? That
  depends on your application. Boolean equality has\nthe advantage that your program
  can take action when two types do _not_ equal,\nwhile propositional equality has
  the advantage that GHC can use the equality\nof types during type inference.\n\nInstances
  of both `SEq` and `SDecide` are generated when `singletons` is called\non a datatype
  that has `deriving Eq`. You can also generate these instances\ndirectly through
  functions exported from `Data.Singletons.TH`.\n\n\nPre-defined singletons\n----------------------\n\nThe
  singletons library defines a number of singleton types and functions\nby default:\n\n*
  `Bool`\n* `Maybe`\n* `Either`\n* `Ordering`\n* `()`\n* tuples up to length 7\n*
  lists\n\nThese are all available through `Data.Singletons.Prelude`. Functions that\noperate
  on these singletons are available from modules such as `Data.Singletons.Bool`\nand
  `Data.Singletons.Maybe`.\n\nPromoting functions\n-------------------\n\nFunction
  promotion allows to generate type-level equivalents of term-level\ndefinitions.
  Almost all Haskell source constructs are supported -- see last\nsection of this
  README for a full list.\n\nPromoted definitions are usually generated by calling
  `promote` function:\n\n```haskell\n$(promote [d|\n  data Nat = Zero | Succ Nat\n
  \ pred :: Nat -> Nat\n  pred Zero = Zero\n  pred (Succ n) = n\n  |])\n```\n\nEvery
  promoted function and data constructor definition comes with a set of\nso-called
  \"symbols\". These are required to represent partial application at the\ntype level.
  Each function gets N+1 symbols, where N is the arity. Symbols\nrepresent application
  of between 0 to N arguments. When calling any of the\npromoted definitions it is
  important refer to it using their symbol\nname. Moreover, there is new function
  application at the type level represented\nby `Apply` type family. Symbol representing
  arity X can have X arguments passed\nin using normal function application. All other
  parameters must be passed by\ncalling `Apply`.\n\nUsers also have access to `Data.Promotion.Prelude`
  and its submodules (`Base`,\n`Bool`, `Either`, `List`, `Maybe` and `Tuple`). These
  provide promoted versions\nof function found in GHC's base library.\n\nRefer to
  the promotion paper for more details on function promotion.\n\nOn names\n--------\n\nThe
  singletons library has to produce new names for the new constructs it\ngenerates.
  Here are some examples showing how this is done:\n\n1. original datatype: `Nat`\n\n
  \  promoted kind: `Nat`\n\n   singleton type: `SNat` (which is really a synonym
  for `Sing`)\n\n\n2. original datatype: `:/\\:`\n\n   promoted kind: `:/\\:`\n\n
  \  singleton type: `:%/\\:`\n\n\n\n3. original constructor: `Succ`\n\n   promoted
  type: `'Succ` (you can use `Succ` when unambiguous)\n\n   singleton constructor:
  `SSucc`\n\n   symbols: `SuccSym0`, `SuccSym1`\n\n\n4. original constructor: `:+:`\n\n
  \  promoted type: `':+:`\n\n   singleton constructor: `:%+:`\n\n   symbols: `:+:$`,
  `:+:$$`, `:+:$$$`\n\n\n5. original value: `pred`\n\n   promoted type: `Pred`\n\n
  \  singleton value: `sPred`\n\n   symbols: `PredSym0`, `PredSym1`\n\n\n6. original
  value: `+`\n\n   promoted type: `:+`\n\n   singleton value: `%:+`\n\n   symbols:
  `:+$`, `:+$$`, `:+$$$`\n\n\nSpecial names\n-------------\n\nThere are some special
  cases:\n\n1. original datatype: `[]`\n\n   singleton type: `SList`\n\n\n2.  original
  constructor: `[]`\n\n    promoted type: `'[]`\n\n    singleton constructor: `SNil`\n\n
  \   symbols: `NilSym0`\n\n\n3. original constructor: `:`\n\n   promoted type: `':`\n\n
  \  singleton constructr: `SCons`\n\n   symbols: `ConsSym0`, `ConsSym1`\n\n\n4. original
  datatype: `(,)`\n\n   singleton type: `STuple2`\n\n\n5. original constructor: `(,)`\n\n
  \  promoted type: `'(,)`\n\n   singleton constructor: `STuple2`\n\n   symbols: `Tuple2Sym0`,
  `Tuple2Sym1`, `Tuple2Sym2`\n\n   All tuples (including the 0-tuple, unit) are treated
  similarly.\n\n6. original value: `undefined`\n\n   promoted type: `Any`\n\n   singleton
  value: `undefined`\n\n\nSupported Haskell constructs\n----------------------------\n\nThe
  following constructs are fully supported:\n\n* variables\n* tuples\n* constructors\n*
  if statements\n* infix expressions\n* `_` patterns\n* aliased patterns\n* lists\n*
  sections\n* undefined\n* error\n* deriving Eq\n* class constraints (though these
  sometimes fail with `let`, `lambda`, and `case`)\n* literals (for `Nat` and `Symbol`)\n*
  unboxed tuples (which are treated as normal tuples)\n* records\n* pattern guards\n*
  case\n* let\n* lambda expressions\n\nThe following constructs are supported for
  promotion but not singleton generation:\n\n* `!` and `~` patterns (silently but
  successfully ignored during promotion)\n* class and instance declarations\n* deriving
  of promoted `Eq`, `Ord` and `Bounded` instances\n* scoped type variables\n* overlapping
  patterns (GHC 7.8.2+ only). Note that overlapping patterns are\n  sometime not obvious.
  For example `filter` function does not singletonize due\n  to overlapping patterns:\n```haskell\nfilter
  :: (a -> Bool) -> [a] -> [a]\nfilter _pred []    = []\nfilter pred (x:xs)\n  | pred
  x         = x : filter pred xs\n  | otherwise      = filter pred xs\n```\nOverlap
  is caused by `otherwise` catch-all guard, that is always true and this\noverlaps
  with `pred x` guard.\n\nThe following constructs are not supported:\n\n* list comprehensions\n*
  do\n* arithmetic sequences\n* datatypes that store arrows\n* literals\n\nWhy are
  these out of reach? First two depend on monads, which mention a\nhigher-kinded type
  variable. GHC does not support higher-sorted kind variables,\nwhich would be necessary
  to promote/singletonize monads. There are other tricks\npossible, too, but none
  are likely to work. See the bug report\n[here](https://github.com/goldfirere/singletons/issues/37)
  for more info.\nArithmetic sequences are defined using `Enum` typeclass, which uses
  infinite\nlists.\n\nAs described in the promotion paper, promotion of datatypes
  that store arrows is\ncurrently impossible. So if you have a declaration such as\n\n
  \   data Foo = Bar (Bool -> Maybe Bool)\n\nyou will quickly run into errors.\n\nLiterals
  are problematic because we rely on GHC's built-in support, which\ncurrently is limited.
  Functions that operate on strings will not work because\ntype level strings are
  no longer considered lists of characters. Function\nworking on integer literals
  can be promoted by rewriting them to use\n`Nat`. Since `Nat` does not exist at the
  term level it will only be possible to\nuse the promoted definition, but not the
  original, term-level one.\n\nSupport for `*`\n---------------\n\nThe built-in Haskell
  promotion mechanism does not yet have a full story around\nthe kind `*` (the kind
  of types that have values). Ideally, promoting some form\nof `TypeRep` would yield
  `*`, but the implementation of TypeRep would have to be\nupdated for this to really
  work out. In the meantime, users who wish to\nexperiment with this feature have
  two options:\n\n1) The module `Data.Singletons.TypeRepStar` has all the definitions
  possible for\nmaking `*` the promoted version of `TypeRep`, as `TypeRep` is currently
  implemented.\nThe singleton associated with `TypeRep` has one constructor:\n\n    data
  instance Sing (a :: *) where\n      STypeRep :: Typeable a => Sing a\n\nThus, an
  implicit `TypeRep` is stored in the singleton constructor. However,\nany datatypes
  that store `TypeRep`s will not generally work as expected; the\nbuilt-in promotion
  mechanism will not promote `TypeRep` to `*`.\n\n2) The module `Data.Singletons.CustomStar`
  allows the programmer to define a subset\nof types with which to work. See the Haddock
  documentation for the function\n`singletonStar` for more info.\n\nKnown bugs\n----------\n\n*
  Due to GHC bug #9081 deriving of hand-written instances of `Ord`, `Eq` and\n  `Bounded`
  is not supported. Your only option here is to have these instances\n  derived automatically.\n*
  Fixity declarations don't promote due to GHC bug #9066.\n* Instances with overlapping
  patterns don't promote. This will be fixed Real\n  Soon Now.\n* Top-level eta-reduced
  patterns don't singletonize\n* Record updates don't singletonize\n\nChanges from
  earlier versions\n-----------------------------\n\nsingletons 1.0 provides promotion
  mechanism that supports case expressions, let\nstatements, anonymous functions,
  higher order functions and many other\nfeatures. This version of the library was
  published together with the promotion\npaper.\n\nsingletons 0.9 contains a bit of
  an API change from previous versions. Here is\na summary:\n\n* There are no more
  \"smart\" constructors. Those were necessary because each\nsingleton used to carry
  both explicit and implicit versions of any children\nnodes. However, this leads
  to exponential overhead! Now, the magic (i.e., a\nuse of `unsafeCoerce`) in `singInstance`
  gets rid of the need for storing\nimplicit singletons. The smart constructors did
  some of the work of managing\nthe stored implicits, so they are no longer needed.\n\n*
  `SingE` and `SingRep` are gone. If you need to carry an implicit singleton,\nuse
  `SingI`. Otherwise, you probably want `SingKind`.\n\n* The Template Haskell functions
  are now exported from `Data.Singletons.TH`.\n\n* The Prelude singletons are now
  exported from `Data.Singletons.Prelude`.\n"
license-name: BSD3
