changelog-type: ''
hash: fcf876d88e5c5df5e0cc26a90c61ae46ad159e00a161d6dc616927adf8b648b1
synopsis: haskell binding to ipopt and nlopt including automatic differentiation
changelog: ''
all-versions:
- '0.0.0.0'
- '0.2.0.0'
- '0.3.0.0'
- '0.4.0.0'
- '0.4.0.1'
- '0.4.2.0'
- '0.5.0.0'
latest: '0.5.0.0'
description-type: haddock
description: ! 'a haskell binding to the nonlinear programming solver

  <http://projects.coin-or.org/Ipopt Ipopt>. Bindings to

  <http://ab-initio.mit.edu/wiki/index.php/NLopt NLopt> are

  also included.


  [@installation@]

  needs the c library ipopt installed. Also by default a binding to

  nlopt is included. Nlopt by default does not include shared libraries,

  which seems to be needed to run things from ghci (ie. you need to

  @./configure --enable-shared@ when building nlopt).


  A embedded language, similar to the one provided by glpk-hs, is

  defined in "Ipopt.NLP". The goal is to define problems at a level

  similar to other "algebraic modeling languages", but retain some

  of the safety and flexibility available in haskell. There is some

  overhead <http://code.haskell.org/~aavogt/ipopt-hs/examples/bench.html>

  but perhaps it is negligible for your uses.


  Current limitations include:


  * copying in every iteration happens between between

  "Data.Vector.Storable" and "Data.Vector" might be avoidable

  somehow.  Currently it is done because AD needs a Traversable

  structure, but Storable vectors are not traversable. Note that

  there is a "Numeric.AD.Mode.Forward.Double" but as yet none

  for Vectors of Double


  * sparseness of derivatives isn''t used


  * no binding to sensitivity parts as-implemented in ipopt'
