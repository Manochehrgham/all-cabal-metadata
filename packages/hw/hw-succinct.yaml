homepage: http://github.com/haskell-works/hw-succinct#readme
changelog-type: ''
hash: 50b456d0c2f02c8d2f09f959c28a84cd0de788e0b5fbc13de8b1222c495a0a68
test-bench-deps:
  hw-succinct: -any
  bytestring: -any
  base: ==4.*
  hspec: -any
  criterion: -any
  parsec: -any
  conduit: -any
  mmap: -any
  hw-prim: -any
  hw-rankselect: -any
  hw-conduit: -any
  attoparsec: -any
  transformers: -any
  QuickCheck: -any
  resourcet: -any
  hw-bits: -any
  vector: -any
maintainer: newhoggy@gmail.com
synopsis: Conduits for tokenizing streams.
changelog: ''
basic-deps:
  hw-succinct: -any
  bytestring: -any
  base: ! '>=4.7 && <5'
  text: -any
  criterion: -any
  word8: -any
  conduit: -any
  hw-diagnostics: -any
  mmap: -any
  hw-prim: -any
  containers: -any
  hw-rankselect: -any
  hw-conduit: -any
  hw-parser: -any
  attoparsec: -any
  resourcet: -any
  hw-bits: -any
  mono-traversable: -any
  vector: -any
all-versions:
- '0.0.0.1'
- '0.0.0.2'
- '0.0.0.3'
- '0.0.0.4'
- '0.0.0.5'
- '0.0.0.7'
- '0.0.0.8'
- '0.0.0.9'
- '0.0.0.10'
- '0.0.0.11'
- '0.0.0.12'
- '0.0.0.13'
author: John Ky
latest: '0.0.0.13'
description-type: markdown
description: ! "# hw-succinct\n[![v0.0-branch](https://circleci.com/gh/haskell-works/hw-succinct/tree/v0.0-branch.svg?style=svg)](https://circleci.com/gh/haskell-works/hw-succinct/tree/v0.0-branch)\n\nConduits
  for tokenizing streams.\n\n`hw-succinct` is a succinct JSON parsing library.  It
  uses succinct data-structures to allow traversal of\nlarge JSON strings with minimal
  memory overhead.\n\nIt is currently considered experimental.\n\nFor an example,
  see [`app/Main.hs`](../master/app/Main.hs)\n\n## Prerequisites\n* Install `haskell-stack`.\n*
  Install `hlint` (eg. `stack install hlint`)\n\n## Building\n\nRun the following
  in the shell:\n\n    git clone git@github.com:haskell-works/hw-succinct.git\n    cd
  hw-succinct\n    stack setup\n    stack build\n    stack test\n    stack ghci --ghc-options
  -XOverloadedStrings \\\n      --main-is hw-succinct:exe:hw-succinct-example\n\n##
  Memory benchmark\n\n### Parsing large Json files in Scala with Argonaut\n\n          S0U
  \      EU           OU       MU     CCSU CMD\n    --------- --------- -----------
  -------- -------- ---------------------------------------------------------------\n
  \         0.0  80,526.3    76,163.6 72,338.6 13,058.6 sbt console\n          0.0
  536,660.4    76,163.6 72,338.6 13,058.6 import java.io._, argonaut._, Argonaut._\n
  \         0.0 552,389.1    76,163.6 72,338.6 13,058.6 val file = new File(\"/Users/jky/Downloads/78mbs.json\"\n
  \         0.0 634,066.5    76,163.6 72,338.6 13,058.6 val array = new Array[Byte](file.length.asInstanceOf[Int])\n
  \         0.0 644,552.3    76,163.6 72,338.6 13,058.6 val is = new FileInputStream(\"/Users/jky/Downloads/78mbs.json\")\n
  \         0.0 655,038.1    76,163.6 72,338.6 13,058.6 is.read(array)\n    294,976.0
  160,159.7 1,100,365.0 79,310.8 13,748.1 val json = new String(array)\n    285,182.9
  146,392.6 1,956,264.5 82,679.8 14,099.6 val data = Parse.parse(json)\n                        ***********\n\n###
  Parsing large Json files in Haskell with Aeson\n\n    Mem (MB) CMD\n    --------
  ---------------------------------------------------------\n         302 import Data.Aeson\n
  \        302 import qualified  Data.ByteString.Lazy as BSL\n         302 json78m
  <- BSL.readFile \"/Users/jky/Downloads/78mbs.json\"\n        1400 let !x = decode
  json78m :: Maybe Value\n\n### Parsing large Json files in Haskell with hw-succinct\n\n
  \   Mem (MB) CMD\n    -------- ---------------------------------------------------------\n
  \        274 import Foreign\n         274 import qualified Data.Vector.Storable
  as DVS\n         274 import qualified Data.ByteString as BS\n         274 import
  System.IO.MMap\n         274 import Data.Word\n         274 (fptr :: ForeignPtr
  Word8, offset, size) <- mmapFileForeignPtr \"/Users/jky/Downloads/78mbs.json\" ReadOnly
  Nothing\n         601 cursor <- measure (fromForeignRegion (fptr, offset, size)
  :: JsonCursor BS.ByteString (BitShown (DVS.Vector Word64)) (SimpleBalancedParens
  (DVS.Vector Word64)))\n\n## Examples\n\n### Performance example\n\n    import Foreign\n
  \   import qualified Data.Vector.Storable as DVS\n    import qualified Data.ByteString
  as BS\n    import qualified Data.ByteString.Internal as BSI\n    import System.IO.MMap\n
  \   import Data.Word\n    import System.CPUTime\n    (fptr :: ForeignPtr Word8,
  offset, size) <- mmapFileForeignPtr \"/Users/jky/Downloads/78mbs.json\" ReadOnly
  Nothing\n    cursor <- measure (fromForeignRegion (fptr, offset, size) :: JsonCursor
  BS.ByteString (BitShown (DVS.Vector Word64)) (SimpleBalancedParens (DVS.Vector Word64)))\n
  \   let !bs = BSI.fromForeignPtr (castForeignPtr fptr) offset size\n    x <- measure
  $ jsonBsToInterestBs bs\n    let !y = runListConduit [bs] (unescape' \"\")\n\n    import
  Foreign\n    import qualified Data.Vector.Storable as DVS\n    import qualified
  Data.ByteString as BS\n    import qualified Data.ByteString.Internal as BSI\n    import
  System.IO.MMap\n    import Data.Word\n    import System.CPUTime\n    (fptr :: ForeignPtr
  Word8, offset, size) <- mmapFileForeignPtr \"/Users/jky/Downloads/part40.json\"
  ReadOnly Nothing\n    let !bs = BSI.fromForeignPtr (castForeignPtr fptr) offset
  size\n    x <- measure $ BS.concat $ runListConduit [bs] (blankJson =$= blankedJsonToInterestBits)\n
  \   x <- measure $ jsonBsToInterestBs bs\n\n    jsonTokenAt $ J.nextSibling $ J.firstChild
  $ J.nextSibling $ J.firstChild $ J.firstChild  cursor\n\n### Navigation example\n\n
  \   $  cabal repl --ghc-option='-package mmap'\n    λ> :set -XNoMonomorphismRestriction\n
  \   λ> import qualified Data.ByteString                                            as
  BS\n    λ> import           Data.String\n    λ> import qualified Data.Vector.Storable
  \                                      as DVS\n    λ> import           Data.Word\n
  \   λ> import           HaskellWorks.Data.Bits.BitShow\n    λ> import           HaskellWorks.Data.Bits.BitShown\n
  \   λ> import           HaskellWorks.Data.FromForeignRegion\n    λ> import           HaskellWorks.Data.Json.Succinct.Cursor
  \                    as C\n    λ> import           HaskellWorks.Data.Json.Token\n
  \   λ> import           HaskellWorks.Data.Succinct.BalancedParens.Internal\n    λ>
  import           HaskellWorks.Data.Succinct.BalancedParens.Simple\n    λ> import
  \          HaskellWorks.Data.Succinct.RankSelect.Binary.Basic.Rank0\n    λ> import
  \          HaskellWorks.Data.Succinct.RankSelect.Binary.Basic.Rank1\n    λ> import
  \          HaskellWorks.Data.Succinct.RankSelect.Binary.Basic.Select1\n    λ> import
  \          HaskellWorks.Data.Succinct.RankSelect.Binary.Poppy512\n    λ> import
  qualified HaskellWorks.Data.TreeCursor as TC\n    λ> import           System.IO.MMap\n
  \   λ> let fc = TC.firstChild\n    λ> let ns = TC.nextSibling\n    λ> let pn = TC.parent\n
  \   λ> let cd = TC.depth\n    λ> let ss = TC.subtreeSize\n    λ> let cursor = \"[null,
  {\\\"field\\\": 1}]\" :: JsonCursor BS.ByteString (BitShown (DVS.Vector Word64))
  (SimpleBalancedParens (DVS.Vector Word64))\n    λ> cursor\n\n## References\n* [Succinct
  Data Structures talk by Edward Kmett](https://www.youtube.com/watch?v=uA0Z7_4J7u8)\n*
  [Typed Tagless Final Interpreters](http://okmij.org/ftp/tagless-final/course/lecture.pdf)\n*
  [Conduit Overview](https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview)\n\n\n##
  Special mentions\n* [Sydney Paper Club](http://www.meetup.com/Sydney-Paper-Club/)\n"
license-name: BSD3
