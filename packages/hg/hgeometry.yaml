homepage: https://fstaals.net/software/hgeometry
changelog-type: ''
hash: 01f9dd12d72b3ab5c2cb72d9f3457062bf7032f2410b1bd5a048d3237d61e2d4
test-bench-deps:
  data-clist: -any
  bytestring: -any
  hgeometry: -any
  base: -any
  hspec: ! '>=2.1'
  doctest: ! '>=0.8'
  Frames: -any
  semigroups: -any
  array: ! '>=0.5'
  containers: -any
  vinyl: -any
  lens: -any
  linear: -any
  random: -any
  vector: -any
maintainer: frank@fstaals.net
synopsis: Geometric Algorithms, Data structures, and Data types.
changelog: ''
basic-deps:
  semigroupoids: ! '>=5'
  data-clist: ! '>=0.0.7.2'
  bytestring: ! '>=0.10'
  base: ! '>=4.7 && <5'
  time: -any
  text: ! '>=1.1.1.0'
  parsec: ! '>=3'
  Frames: ! '>=0.1.0.0'
  semigroups: ! '>=0.15'
  containers: ! '>=0.5.5'
  singletons: ! '>=1.0 && <2.0'
  vinyl: ! '>=0.5 && <0.6'
  lens: ! '>=4.2'
  bifunctors: ! '>=5'
  fixed-vector: ! '>=0.6.4.0'
  linear: ! '>=1.10'
  mtl: -any
  hexpat: ! '>=0.20.9'
  optparse-applicative: -any
  random: -any
  template-haskell: -any
  vector: ! '>=0.10'
  directory: -any
all-versions:
- '0.1.0.0'
- '0.1.1.0'
- '0.1.1.1'
- '0.4.0.0'
- '0.5.0.0'
author: Frank Staals
latest: '0.5.0.0'
description-type: markdown
description: ! "HGeometry\n=========\n\n[![Build Status](https://travis-ci.org/noinia/hgeometry.svg?branch=master)](https://travis-ci.org/noinia/hgeometry)\n[![Hackage](https://img.shields.io/hackage/v/hgeometry.svg)](https://hackage.haskell.org/package/hgeometry)\n\nHGeometry
  provides some basic geometry types, and geometric algorithms and data\nstructures
  for them. The main two focusses are: (1) Strong type safety, and (2)\nimplementations
  of geometric algorithms and data structures with good\nasymptotic running time guarantees.
  Design choices showing these aspects are\nfor example:\n\n- we provide a data type
  `Point d r` parameterized by a\ntype-level natural number `d`, representing d-dimensional
  points (in all cases\nour type parameter `r` represents the (numeric) type for the
  (real)-numbers):\n\n```haskell\nnewtype Point (d :: Nat) (r :: *) = Point { toVec
  :: Vector d r }\n```\n- the vertices of a `PolyLine d p r` are stored in a `Data.Seq2`
  which enforces\nthat a polyline is a proper polyline, and thus has at least two
  vertices.\n\nPlease note that aspect (2), implementing good algorithms, is much
  work in\nprogress. HGeometry currently has only very basic types, and implements
  only\na few algorithms:\n\n* two (optimal) $O(n \\log n)$ time algorithms for convex
  hull in\n  $\\mathbb{R}^2$: the typical Graham scan, and a divide and conqueror
  algorithm,\n* an $O(n)$ expected time algorithm for smallest enclosing disk in $\\mathbb{R}^$2,\n*
  the well-known Douglas Peucker polyline line simplification algorithm,\n* an $O(n
  \\log n)$ time algorithm for computing the Delaunay triangulation\n(using divide
  and conqueror).\n* an $O(n \\log n)$ time algorithm for computing the Euclidean
  Minimum Spanning\nTree (EMST), based on computing the Delaunay Triangulation.\n\n\nA
  Note on the Ext (:+) data type\n---------------------------------\n\nIn many applications
  we do not just have geometric data, e.g. `Point d r`s or\n`Polygon r`s, but instead,
  these types have some additional properties, like a\ncolor, size, thickness, elevation,
  or whatever. Hence, we would like that our\nlibrary provides functions that also
  allow us to work with `ColoredPolygon r`s\netc. The typical Haskell approach would
  be to construct type-classes such as\n`PolygonLike` and define functions that work
  with any type that is\n`PolygonLike`. However, geometric algorithms are often hard
  enough by\nthemselves, and thus we would like all the help that the type-system/compiler\ncan
  give us. Hence, we choose to work with concrete types.\n\nTo still allow for some
  extensibility our types will use the Ext (:+) type. For\nexample, our `Polygon`
  data type, has an extra type parameter `p` that allows\nthe vertices of the polygon
  to cary some extra information of type `p` (for\nexample a color, a size, or whatever).\n\n```haskell\ndata
  Polygon (t :: PolygonType) p r where\n  SimplePolygon :: C.CList (Point 2 r :+ p)
  \                        -> Polygon Simple p r\n  MultiPolygon  :: C.CList (Point
  2 r :+ p) -> [Polygon Simple p r] -> Polygon Multi  p r\n  ```\n\nIn all places
  this extra data is accessable by the (:+) type in Data.Ext, which\nis essentially
  just a pair.\n\nReading and Writing Ipe files\n-----------------------------\n\nApart
  from geometric types, HGeometry provides some interface for reading and\nwriting
  Ipe (http://ipe.otfried.org). However, this is all very work in\nprogress. Hence,
  the API is experimental and may change at any time!\n"
license-name: BSD3
