homepage: https://github.com/zalora/getopt-generics#readme
changelog-type: ''
hash: a263ba35764bb006bd10ae0782fef63627c2ab172a766cd9865fdd19b06b288c
test-bench-deps:
  base: ==4.*
  hspec: ! '>=2.1.8'
  markdown-unlit: -any
  base-orphans: -any
  tagged: -any
  silently: -any
  base-compat: ! '>=0.8'
  generics-sop: -any
  QuickCheck: -any
  hspec-expectations: -any
maintainer: linh.nguyen@zalora.com, soenke.hahn@zalora.com
synopsis: Simple command line argument parsing
changelog: ''
basic-deps:
  base: ==4.*
  base-orphans: -any
  tagged: -any
  base-compat: ! '>=0.8'
  generics-sop: -any
all-versions:
- '0.1'
- '0.1.1'
- '0.2'
- '0.3'
- '0.4'
- '0.4.1'
- '0.5'
- '0.6'
- '0.6.1'
- '0.6.2'
- '0.6.3'
- '0.7'
- '0.7.1'
- '0.7.1.1'
- '0.8'
- '0.9'
author: Linh Nguyen, SÃ¶nke Hahn
latest: '0.9'
description-type: markdown
description: ! "# getopt-generics\n\n## Status\n\nThis library is experimental.\n\n##
  Usage\n\n`getopt-generics` tries to make it very simple to create executables that
  parse\ncommand line options. All you have to do is to define a type and derive some\ninstances:\n\n~~~
  {.haskell}\n{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE DeriveGeneric #-}\n\nmodule
  Readme where\n\nimport Data.Typeable\nimport GHC.Generics\nimport System.Console.GetOpt.Generics\nimport
  System.Environment\n\ndata Options\n  = Options {\n    port :: Int,\n    daemonize
  :: Bool,\n    config :: Maybe FilePath\n  }\n  deriving (Show, GHC.Generics.Generic)\n\ninstance
  System.Console.GetOpt.Generics.Generic Options\ninstance HasDatatypeInfo Options\n~~~\n\nThen
  you can use `getArguments` to create a command-line argument parser:\n\n~~~ {.haskell}\nmain
  :: IO ()\nmain = do\n  options <- getArguments\n  print (options :: Options)\n~~~\n\nThis
  program has\n\n- a non-optional `--port` flag with an integer argument,\n- a boolean
  flag `--daemonize`,\n- an optional flag `--config` expecting a file argument and\n-
  a generic `--help` option.\n\nHere's in example of the program above in bash:\n```
  bash\n$ program --port 8080 --config some/path\nOptions {port = 8080, daemonize
  = False, config = Just \"some/path\"}\n$ program  --port 8080 --daemonize\nOptions
  {port = 8080, daemonize = True, config = Nothing}\n$ program --port foo\nnot an
  integer: foo\n$ program\nmissing option: --port=int\n$ program --help\nprogram\n
  \   --port=integer\n    --daemonize\n    --config=string (optional)\n```\n\n## Constraints\n\nThere
  are some constraints that the defined datatype has to fulfill:\n\n  * It has to
  have only one constructor,\n  * that constructor has to have field selectors (i.e.
  use record syntax) and\n  * all fields have to be of a type that has an instance
  for `Option`.\n\n(Types declared with `newtype` are allowed with the same constraints.)\n\n##
  Using Custom Field Types\n\nIt is possible to use custom field types by providing
  an instance for `Option`.\nHere's an example:\n\n~~~ {.haskell}\ndata File = File
  FilePath\n  deriving (Show, Typeable)\n\ninstance Option File where\n  argumentType
  Proxy = \"file\"\n  parseArgument f = Just (File f)\n\ndata FileOptions\n  = FileOptions
  {\n    file :: File\n  }\n  deriving (Show, GHC.Generics.Generic)\n\ninstance System.Console.GetOpt.Generics.Generic
  FileOptions\ninstance HasDatatypeInfo FileOptions\n\n-- Returns: FileOptions {file
  = File \"some/file\"}\ngetFileOptions :: IO FileOptions\ngetFileOptions = withArgs
  (words \"--file some/file\") getArguments\n~~~\n"
license-name: BSD3
