homepage: https://github.com/cpeikert/Lol
changelog-type: markdown
hash: 81e59060fd30a753104b56db7b83271e9a9507a825739ad4682edfdf93ac4054
test-bench-deps:
  lol: -any
  test-framework: ! '>=0.8 && <0.9'
  MonadRandom: -any
  base: -any
  test-framework-quickcheck2: ! '>=0.3 && <0.4'
  criterion: -any
  constraints: -any
  containers: -any
  singletons: -any
  ansi-terminal: -any
  arithmoi: -any
  mtl: -any
  statistics: -any
  transformers: -any
  random: -any
  deepseq: -any
  DRBG: -any
  QuickCheck: ! '>=2.8 && <2.9'
  repa: -any
  vector: -any
maintainer: Eric Crockett <ecrockett0@gmail.com>
synopsis: A library for lattice cryptography.
changelog: ! "Changelog for lol project\n================================\n\n0.4.0.0\n----\n
  * Added support for GHC 8.0, also compatible with 7.10.3\n * Converted documentation
  to MathJax\n * Renamed Tensor.Matrix -> Tensor.Kron\n * Added Crypto.Lol.Types interface
  file\n\n0.3.0.0\n-----\n * Support for protocol-buffers\n * Support for reifying
  Factored types\n * Support for reals (RR) mod q\n * Replaced C backend with C++
  backend\n * Renamed LatticePrelude -> Prelude\n * Added monad argument to CRTrans\n\n0.2.0.0\n-----\n
  * Added benchmarks\n * Better performance for C backend with RNS base ring\n * UCyc
  exposes bases as type for safety\n * Other safety improvements throughout\n * Easier
  index representation with TemplateHaskell\n * Split SymmSHE into new package lol-apps.\n\n0.1.0.0\n-----\n
  * Fixed bug in Box-Muller sampling routine.\n * Changed how we lift linear functions
  for better noise control.\n * Split entailment functions in Tensor.\n * Increased
  performance in FastCyc by better handling Sub constructors."
basic-deps:
  bytestring: -any
  reflection: ! '>=1.5.1 && <2.2'
  MonadRandom: ! '>=0.2 && <0.5'
  base: ! '>=4.8 && <5'
  protocol-buffers: -any
  crypto-api: -any
  constraints: -any
  data-default: ! '>=0.3.0 && <0.8'
  protocol-buffers-descriptor: -any
  containers: ! '>=0.5.6.2 && <0.6'
  singletons: ! '>=1.1.2.1 && <2.2'
  binary: -any
  tagged-transformer: ! '>=0.7 && <0.9'
  th-desugar: ! '>=1.5.4 && <1.7'
  arithmoi: ! '>=0.4.1.3 && <0.5'
  mtl: ! '>=2.2.1 && <2.3'
  transformers: ! '>=0.4.2.0 && <0.6'
  random: ! '>=1.1 && <1.2'
  deepseq: ! '>=1.4.1.1 && <1.5'
  vector-th-unbox: ! '>=0.2.1.0 && <0.3'
  QuickCheck: ! '>=2.8 && <2.9'
  repa: ==3.4.*
  template-haskell: ! '>=2.2.0.0'
  vector: ==0.11.*
  numeric-prelude: ! '>=0.4.2 && <0.5'
  monadcryptorandom: -any
all-versions:
- '0.1.0.0'
- '0.2.0.0'
- '0.2.0.1'
- '0.3.0.0'
- '0.4.0.0'
- '0.5.0.0'
author: Eric Crockett <ecrockett0@gmail.com>, Chris Peikert <cpeikert@alum.mit.edu>
latest: '0.5.0.0'
description-type: text
description: ! "\nMost of the functionality in Lol is exported by two modules:\n\n*
  'Crypto.Lol' exports the primary *interfaces* of Lol\n\n* 'Crypto.Lol.Types' exports
  concrete types that would be used by most\n  instantiations including tensors, base
  rings, and cryptographic\n\nFor a brief introduction to relevant mathematical notation,
  see 'Crypto.Lol'.\n\nOverview of key modules, roughly from highest- to lowest-level:\n\nCyclotomic
  layer:\n* 'Crypto.Lol.Cyclotomic.Cyc', which defines an interface for using cyclotomic\n
  \ fields, rings \\( R \\), and quotient rings \\( R_q=R/qR \\); as well as many\n
  \ other commonly used operations, e.g., converting\n  between rings, decoding and
  decomposing elements, modulus\n  reduction/rounding, etc. 'Cyc' is a safe wrapper
  around the\n  'UCyc' type, which exposes some representation-dependent operations.\n
  \ 'UCyc' (and hence 'Cyc') is implemented using a generic 'Tensor'\n  (described
  below).\n\n\nTensor layer:\n* 'Crypto.Lol.Cyclotomic.Tensor', which defines a class
  that encapsulates all\n  the necessary linear transformations for operating on representations
  of\n  \\( R \\)- and \\( R_q \\)-elements, e.g., the CRT transform, converting between\n
  \ the powerful and decoding bases, generating error terms, etc.\n\n* 'Crypto.Lol.Cyclotomic.Tensor.RepaTensor',
  which gives an\n  implementation of the 'Tensor' class based on the \"repa\"\n  package,
  a highly optimized and parallelizable array library.\n\n* 'Crypto.Lol.Cyclotomic.Tensor.CTensor',
  which gives an\n  implementation of the 'Tensor' class using a C++ backend via Haskell's
  FFI.\n\n\nBase ring layer:\n* 'Crypto.Lol.Types.FiniteField', which gives an unoptimized
  implementation of\n  finite field arithmetic. To use this module, you will need
  an instance of\n  'IrreduciblePoly'. These instances provide irreducible polynomials\n
  \ for various degrees and base fields.  One (orphan) instance is provided for\n
  \ characteristic 2 fields of size up to 2^128 in\n  'Crypto.Lol.Types.IrreducibleChar2',
  and is exported by 'Crypto.Lol.Types'.\n  If you need to use an unsupported finite
  field,  define your own\n  instance of 'IrreduciblePoly' and do **not** import 'IrreducibleChar2'.\n\n*
  'Crypto.Lol.Types.ZqBasic', which is a basic implementation of\n  \\( \\Z_q=\\Z/q\\Z
  \\) arithmetic.\n\n* 'Crypto.Lol.Factored', which contains type-level support code
  for\n  factored integers. It also supports \"reifying\" 'Int's at runtime as static\n
  \ types and \"reflecting\" those types as integers back to the code..\n  'Factored'
  types are mainly used to represent cyclotomic indices.\n"
license-name: GPL-2
