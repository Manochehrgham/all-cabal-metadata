homepage: https://github.com/glguy/config-schema
changelog-type: markdown
hash: c548623a68e18463121ea9a9bcb40113e210d1f2bb45d7eaf5a8fe1d6bce925c
test-bench-deps: {}
maintainer: emertens@gmail.com
synopsis: Schema definitions for the config-value package
changelog: ! '# Revision history for config-schema


  ## 0.1.0.0  -- YYYY-mm-dd


  * First version. Released on an unsuspecting world.

'
basic-deps:
  semigroupoids: ! '>=5.2 && <5.3'
  free: ! '>=4.12 && <4.13'
  base: ! '>=4.9 && <4.11'
  text: ! '>=1.2 && <1.3'
  kan-extensions: ! '>=5.0 && <5.1'
  containers: ! '>=0.5 && <0.6'
  config-value: ! '>=0.5 && <0.6'
  transformers: ! '>=0.5 && <0.6'
all-versions:
- '0.1.0.0'
author: Eric Mertens
latest: '0.1.0.0'
description-type: markdown
description: ! "config-schema\n=============\n\n[![Hackage](https://img.shields.io/hackage/v/config-schema.svg)](https://hackage.haskell.org/package/config-schema)
  [![Build Status](https://secure.travis-ci.org/glguy/config-schema.png?branch=master)](http://travis-ci.org/glguy/config-schema)\n\nThis
  package allows the user to define configuration schemas suitable for\nmatching against
  configuration files written in the\n[config-value](https://hackage.haskell.org/package/config-value)
  format.\nThese schemas allow the user to extract an arbitrary Haskell value from\nan
  interpretation of a configuration file. It also allows the user to\nprogramatically
  generate documentation for the configuration files\naccepted by the loader.\n\n```haskell\n{-#
  Language OverloadedStrings, ApplicativeDo #-}\n\nmodule Example where\n\nimport
  qualified Data.Text as Text\nimport qualified Data.Text.IO as Text\nimport           Data.Text
  (Text)\nimport           Data.Monoid ((<>))\nimport           Data.Functor.Alt ((<!>))\n\nimport
  \          Config\nimport           Config.Schema\n\nexampleFile :: Text\nexampleFile
  =\n  \" name: \\\"Johny Appleseed\\\" \\n\\\n  \\ age : 99                  \\n\\\n
  \ \\ happy: yes                \\n\\\n  \\ kids:                     \\n\\\n  \\
  \  * name: \\\"Bob\\\"         \\n\\\n  \\   * name: \\\"Tom\\\"         \\n\"\n\nexampleValue
  :: Value\nRight exampleValue = parse exampleFile\n\nexampleSpec :: ValueSpecs Text\nexampleSpec
  = sectionsSpec \"\" $\n  do name  <- reqSection  \"name\" \"Full name\"\n     age
  \  <- reqSection  \"age\"  \"Age of user\"\n     happy <- optSection' \"happy\"
  \"Current happiness status\" yesOrNo\n     kids  <- reqSection' \"kids\"  \"All
  children\" (oneOrList kidSpec)\n\n     return $\n       let happyText = case happy
  of Just True  -> \" and is happy\"\n                                     Just False
  -> \" and is not happy\"\n                                     Nothing    -> \"
  and is private\"\n\n       in name <> \" is \" <> Text.pack (show (age::Integer))
  <>\n             \" years old and has kids \" <>\n             Text.intercalate
  \", \" kids <>\n             happyText\n\nkidSpec :: ValueSpecs Text\nkidSpec =
  sectionsSpec \"kid\" (reqSection \"name\" \"Kid's name\")\n\n\n-- | Matches the
  'yes' and 'no' atoms\nyesOrNo :: ValueSpecs Bool\nyesOrNo = True  <$ atomSpec \"yes\"
  <!>\n          False <$ atomSpec \"no\"\n\n\nprintDoc :: IO ()\nprintDoc = Text.putStr
  (generateDocs exampleSpec)\n-- *Example> printDoc\n-- Configuration file fields:\n--
  \    name: REQUIRED text\n--        Full name\n--     age: REQUIRED integer\n--
  \       Age of user\n--     happy: `yes` or `no`\n--        Current happiness status\n--
  \    kids: REQUIRED kid or list of kid\n--        All children\n--\n-- kid\n--     name:
  REQUIRED text\n--        Kid's name\n\nexample :: Either [LoadError] Text\nexample
  = loadValue exampleSpec exampleValue\n-- *Example> exampleVal\n-- Right \"Johny
  Appleseed is 99 years old and has kids Bob, Tom and is happy\"\n```\n"
license-name: ISC
