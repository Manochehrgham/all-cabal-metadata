homepage: https://github.com/trskop/connection-pool
changelog-type: markdown
hash: 8379520734600545013a5e0d0b486ccfe84edea08061dce45eca27751cba6b45
test-bench-deps: {}
maintainer: peter.trsko@gmail.com
synopsis: Connection pool built on top of resource-pool and streaming-commons.
changelog: ! "# ChangeLog / ReleaseNotes\n\n\n## Version 0.1.1.0\n\n* Package is now
  buildable on Windows. (new)\n* Introducing function `validateResourcePoolParams`.
  (new)\n* Introducing internal function `destroyAllConnections`. (new)\n* Introducing
  functions `destroyAllTcpClientConnections` and\n  `destroyAllTcpClientConnections`
  both build on top of\n  `destroyAllConnections`. (new)\n* Corrected some typos in
  documentation and Haddock markup.\n* Small documentation enhancements.\n* Uploaded
  to [Hackage][]:\n  <http://hackage.haskell.org/package/connection-pool-0.1.1.0>\n\n\n##
  Version 0.1.0.0\n\n* First public release.\n* Uploaded to [Hackage][]:\n  <http://hackage.haskell.org/package/connection-pool-0.1.0.0>\n\n\n\n[Hackage]:\n
  \ http://hackage.haskell.org/\n  \"HackageDB (or just Hackage) is a collection of
  releases of Haskell packages.\"\n"
basic-deps:
  streaming-commons: ! '>=0.1.3'
  base: ! '>=4.6 && <4.8'
  data-default-class: ==0.0.*
  time: ! '>=1.0'
  monad-control: ! '>=0.2.0.1'
  resource-pool: ! '>=0.2.0.0 && <1'
  network: ! '>=2.2.3'
  between: ! '>=0.9.0.0'
  transformers-base: ! '>=0.4.2 && <0.5'
all-versions:
- '0.1.0.0'
- '0.1.1.0'
author: Peter TrÅ¡ko
latest: '0.1.1.0'
description-type: markdown
description: ! "Connection Pool\n===============\n\n[![Hackage](http://img.shields.io/hackage/v/connection-pool.svg)\n][Hackage:
  connection-pool]\n\n\nDescription\n-----------\n\nConnection poll is a family specialised
  resource pools. Currently package\nprovides two\n\n1. pool for TCP client connections,\n2.
  and pool for UNIX Sockets client connections.\n\nThis package is built on top of
  [resource-pool][Hackage: resource-pool] and\n[streaming-commons][Hackage: streaming-commons].
  The later allows us to use\n[conduit-extra][Hackage: conduit-extra] package for
  implementation of TCP or\nUNIX Sockets clients.\n\n\nDocumentation\n-------------\n\nStable
  releases with API documentation are available on\n[Hackage][Hackage: connection-pool]\n\n\nExamples\n--------\n\nSimple
  code examples, including example from the following section, are\navailable in [example/](example/)
  directory.\n\n\nTCP Client Example\n------------------\n\nHere is a simple example
  that demonstrates how TCP client can be created and\nhow connection pool behaves.\n\n```haskell\n{-#
  LANGUAGE OverloadedStrings #-}\nmodule Main (main)\n  where\n\nimport Control.Monad
  (void)\nimport Control.Concurrent (forkIO, threadDelay)\nimport System.Environment
  (getArgs)\n\nimport Control.Lens ((.~), (&))\nimport Data.ConnectionPool\n    (
  createTcpClientPool\n    , numberOfResourcesPerStripe\n    , numberOfStripes\n    ,
  withTcpClientConnection\n    )\nimport Data.Default.Class (Default(def))\nimport
  Data.Streaming.Network (appWrite, clientSettingsTCP)\n\n\nmain :: IO ()\nmain =
  do\n    [port, numStripes, numPerStripe] <- getArgs\n    pool <- createTcpClientPool\n
  \       (poolParams numStripes numPerStripe)\n        (clientSettingsTCP (read port)
  \"127.0.0.1\")\n    void . forkIO . withTcpClientConnection pool $ \\appData ->
  do\n       threadDelay 100\n       appWrite appData \"1: I'm alive!\\n\"\n    void
  . forkIO . withTcpClientConnection pool $ \\appData ->\n       appWrite appData
  \"2: I'm alive!\\n\"\n  where\n    poolParams m n =\n        def & numberOfStripes
  .~ read m\n            & numberOfResourcesPerStripe .~ read n\n```\n\nTo test it
  we can use `socat` or some `netcat` like application. Our test will\nrequire two
  terminals, in one we will execute `socat` as a server listenting on\nUNIX socket
  and in the other one we execute above example.\n\nSimple TCP server listening on
  port `8001` that prints what it receives to\nstdout:\n\n    $ socat TCP4-LISTEN:8001,bind=127.0.0.1,fork
  -\n\nThe `fork` parameter in the above example is important, otherwise `socat` would\nterminate
  when client closes its connection.\n\nIf we run above example as:\n\n    $ runghc
  tcp-example.hs 8001 1 1\n\nWe can see that `socat` received following text:\n\n
  \   1: I'm alive!\n    2: I'm alive!\n\nBut if we increment number of stripes or
  number of connections (resources) per\nstripe, then we will get:\n\n    2: I'm alive!\n
  \   1: I'm alive!\n\nThe reason for this is that we use `threadDelay 100` in the
  first executed\nthread. So when we have only one stripe and one connection per stripe,
  then we\nhave only one connection in the pool. Therefore when the first thread executes\nand
  acquires a connection, then all the other threads (the other one in above\nexample)
  will block. If we have more then one connection available in our pool,\nthen the
  first thread acquires connection, blocks on `threadDelay` call, but\nthe other thread
  also acquires connection and prints its output while the first\nthread is still
  blocked on `threadDelay`. This example demonstrates how\nconnection pool behaves
  if it reached its capacity and when it has onough free\nresources.\n\n\nLicense\n-------\n\nThe
  BSD 3-Clause License, see [LICENSE](LICENSE) file for details.\n\n\nContributions\n-------------\n\nContributions,
  pull requests and bug reports are welcome! Please don't be\nafraid to contact author
  using GitHub or by e-mail (see `.cabal` file for\nthat).\n\n\n\n[Hackage: conduit-extra]:\n
  \ http://hackage.haskell.org/package/conduit-extra\n[Hackage: connection-pool]:\n
  \ http://hackage.haskell.org/package/connection-pool\n[Hackage: resource-pool]:\n
  \ http://hackage.haskell.org/package/resource-pool\n[Hackage: streaming-commons]:\n
  \ http://hackage.haskell.org/package/streaming-commons\n"
license-name: BSD3
