homepage: ''
changelog-type: markdown
hash: f0ded2e0f8a9b9aabf7d3d7c0cc14a7a9cf0b6a92685454b521349b0f835e91b
test-bench-deps:
  test-framework-hunit: -any
  test-framework: ! '>=0.3.3'
  base: ! '>=4.2 && <5'
  test-framework-quickcheck2: ! '>=0.2.9'
  HUnit: -any
  array: -any
  ghc-prim: -any
  ChasingBottoms: -any
  deepseq: ! '>=1.2 && <1.5'
  QuickCheck: ! '>=2.4.0.1'
maintainer: fox@ucw.cz
synopsis: Assorted concrete container types
changelog: ! "# Changelog for [`containers` package](http://github.com/haskell/containers)\n\n##
  0.5.7.1  *Dec 2015*\n\n  * Planned to bundle with GHC 8.0.1.\n\n  * Add `IsString`
  instance to `Data.Sequence`.\n\n  * Define `Semigroup` instances for ``Data.Map`,
  `Data.Set`, `Data.IntMap`,\n    `Data.IntSet` and `Data.Sequence`.\n\n## 0.5.6.2
  \ *Dec 2014*\n\n  * Bundled with GHC 7.10.1.\n\n  * Add role annotations for `Data.Map`
  and `Data.Set`.\n\n  * Add `IsList` instances for `Data.Map`, `Data.Set`, `Data.IntMap`
  and\n    `Data.IntSet`.\n\n  * Several performance improvements for `Data.Sequence`.\n\n
  \ * Add `Data.Sequence.fromFunction` and `Data.Sequence.fromArray`.\n\n## 0.5.4.0
  \ *Jan 2014*\n\n  * Bundled with GHC 7.8.1.\n\n  * The `Data.Map.fromList` and `Data.Set.fromList`
  now use linear-time\n    algorithm if the input is sorted, without need to call
  `fromDistinctAscList`.\n\n  * Implement indexing operations (`lookupIndex`, `findIndex`,
  `elemAt`,\n    `deletaAt`) for `Data.Set` too.\n\n  * Add `Applicative` and `Alternative`
  instances for `Data.Sequence`.\n\n  * Add `foldMapWithKey` to `Data.Map` and `Data.IntMap`.\n\n
  \ * Implement poly-kinded `Typeable`.\n\n  * Add `Functor` instance for `Data.Graph.SCC`.\n\n
  \ * Add `Data.Map.splitRoot` and `Data.Set.splitRoot`.\n\n## 0.5.0.0  *May 2012*\n\n
  \ * Bundled with GHC 7.6.1.\n\n  * Major improvements since last release:\n    *
  a clearer distinction between value-lazy and value-strict containers,\n    * performance
  improvements across the board,\n    * a big internal clean-up, and\n    * new functions
  for e.g. merging, updating, and searching containers.\n\n  * While the old `Data.Map`
  and\n    `Data.IntMap` modules will continue to exist for the foreseeable future,
  we've\n    abandoned the practice of having the strict and lazy versions of each\n
  \   function distinguished by an apostrophe. The distinction is instead made at\n
  \   the module level, by introducing four new modules:\n    * Data.Map.Strict\n
  \   * Data.Map.Lazy\n    * Data.IntMap.Strict\n    * Data.IntMap.Lazy\n\n    This
  split has three benefits:\n    * It makes the choice between value-strict and value-lazy
  containers\n      more declarative; you pick once at import time, instead of having
  to\n      remember to use the strict or lazy versions of a function every time\n
  \     you modify the container.\n    * It alleviates a common source of performance
  issues, by forcing the\n      user to think about the strictness properties upfront.
  For example,\n      using insertWith instead of insertWith' is a common source of\n
  \     containers-related performance bugs.\n    * There are fewer functions per
  module, making it easier to get an\n      overview of each module.\n\n  * Note that
  the types used in the strict and lazy APIs are the same, so\n    you can still use
  the same container in a \"mixed\" manner, if needed.\n\n  * The `Data.IntSet` representation
  changed to store small sets using\n    bits in an `Word`. Larger sets are stored
  as a collection of such\n    dense small sets, connected together by a prefix trie.\n\n##
  0.4.2.1  *Feb 2012*\n\n  * Bundled with GHC 7.4.1.\n\n  * `Data.Map now exports
  `foldr`, `foldr'`, `foldl` and `foldl'`.\n\n  * `Data.Set now exports `foldr`, `foldr'`,
  `foldl` and `foldl'`.\n\n  * `Data.IntMap now exports `foldr`, `foldr'`, `foldl`,
  `foldl'`, `foldrWithKey`, `foldrWithKey'`, `foldlWithKey` and `foldlWithKey'`.\n\n
  \ * `Data.IntSet now exports `foldr`, `foldr'`, `foldl` and `foldl'`.\n\n  * `Data.Map.foldWithKey`
  is no longer deprecated, although it is expected to be deprecated again in the future.\n\n
  \ * There are now `NFData` instance for `Data.Map.Map`, `Data.Set.Set`, `Data.IntMap.IntMap`,
  `Data.IntSet.IntSet` and `Data.Tree.Tree`.\n\n## 0.4.1.0  *Aug 2011*\n\n  * Bundled
  with GHC 7.2.1.\n\n  * `Data.Map` now exports new functions `foldrWithKey'` and
  `foldlWithKey'`, which are strict variants of `foldrWithKey` and `foldlWithKey`
  respectively.\n\n  * `Data.IntMap` now exports new functions `insertWith'` and `insertWithKey'`,
  which are strict variants of `insertWith` and `insertWithKey` respectively.\n\n##
  0.4.0.0  *Nov 2010*\n\n  * Bundled with GHC 7.0.1.\n\n  * Strictness is now more
  consistent, with containers being strict in their elements even in singleton cases.\n\n
  \ * There is a new function `insertLookupWithKey'` in `Data.Map`.\n\n  * The `foldWithKey`
  function in `Data.Map` has been deprecated in favour of `foldrWithKey`.\n\n## 0.3.0.0
  \ *Dec 2009*\n\n  * Bundled with GHC 6.12.1.\n\n  * `mapAccumRWithKey` has been
  added to `Data.IntMap`.\n\n  * A `Traversable` instance has been added to `Data.IntMap.IntMap`.\n\n
  \ * The types of `Data.IntMap.intersectionWith` and `Data.IntMap.intersectionWithKey`
  have been changed from\n    `intersectionWith :: (a -> b -> a) -> IntMap a -> IntMap
  b -> IntMap a`\n    `intersectionWithKey :: (Key -> a -> b -> a) -> IntMap a ->
  IntMap b -> IntMap a`\n    to\n    `intersectionWith :: (a -> b -> c) -> IntMap
  a -> IntMap b -> IntMap c`\n    `intersectionWithKey :: (Key -> a -> b -> c) ->
  IntMap a -> IntMap b -> IntMap c`\n\n  * The types of `Data.IntMap.findMin` and
  `Data.IntMap.findMax` have been changed from\n    `findMin :: IntMap a -> a`\n    `findMax
  :: IntMap a -> a`\n    to\n    `findMin :: IntMap a -> (Int,a)`\n    `findMax ::
  IntMap a -> (Int,a)`\n\n  * `Data.Map` now exports `mapAccumRWithKey`, `foldrWithKey`,
  `foldlWithKey` and `toDescList`.\n\n  * `Data.Sequence` now exports `replicate`,
  `replicateA`, `replicateM`, `iterateN`, `unfoldr`, `unfoldl`, `scanl`, `scanl1`,
  `scanr`, `scanr1`, `tails`, `inits`, `takeWhileL`, `takeWhileR`, `dropWhileL`, `dropWhileR`,
  `spanl`, `spanr`, `breakl`, `breakr`, `partition`, `filter`, `sort`, `sortBy`, `unstableSort`,
  `unstableSortBy`, `elemIndexL`, `elemIndicesL`, `elemIndexR`, `elemIndicesR`, `findIndexL`,
  `findIndicesL`, `findIndexR`, `findIndicesR`, `foldlWithIndex`, `foldrWithIndex`,
  `mapWithIndex`, `zip`, `zipWith`, `zip3`, `zipWith3`, `zip4` and `zipWith4`.\n\n##
  0.2.0.0  *Nov 2008*\n\n  * Bundled with GHC 6.10.1.\n\n  * Various result type now
  use `Maybe` rather than allowing any `Monad`.\n\n## 0.1.0.0  *Nov 2007*\n\n  * Bundled
  with GHC 6.8.1.\n\n  * Initial split off from GHC base.\n"
basic-deps:
  base: ! '>=4.2 && <5'
  array: -any
  ghc-prim: -any
  deepseq: ! '>=1.2 && <1.5'
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.2.0.0'
- '0.2.0.1'
- '0.3.0.0'
- '0.4.0.0'
- '0.4.1.0'
- '0.4.2.0'
- '0.4.2.1'
- '0.5.0.0'
- '0.5.1.0'
- '0.5.2.0'
- '0.5.2.1'
- '0.5.3.0'
- '0.5.3.1'
- '0.5.4.0'
- '0.5.5.0'
- '0.5.5.1'
- '0.5.6.0'
- '0.5.6.1'
- '0.5.6.2'
- '0.5.6.3'
- '0.5.7.0'
- '0.5.7.1'
author: ''
latest: '0.5.7.1'
description-type: haddock
description: ! 'This package contains efficient general-purpose implementations

  of various basic immutable container types.  The declared cost of

  each operation is either worst-case or amortized, but remains

  valid even if structures are shared.'
license-name: BSD3
