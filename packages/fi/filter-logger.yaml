homepage: https://github.com/caneroj1/filter-logger#readme
changelog-type: ''
hash: 5913ee13540a6ec20ea72f5ab7076dc085de1edbb48f3e23e008aa3d15d506e1
test-bench-deps:
  bytestring: -any
  base: -any
  HUnit: -any
  filter-logger: -any
maintainer: jmc41493@gmail.com
synopsis: Filterable request logging as a wai middleware. Change what data is logged
  and when.
changelog: ''
basic-deps:
  bytestring: -any
  wai: -any
  base: ! '>=4.7 && <5'
  aeson-pretty: -any
  data-default: -any
  fast-logger: -any
  filter-logger: -any
  wai-extra: -any
  scotty: -any
  http-types: -any
  aeson: -any
all-versions:
- '0.1.0.0'
- '0.2.0.0'
author: Joe Canero
latest: '0.2.0.0'
description-type: markdown
description: ! "# filter-logger\n\nFilterable request logging as a wai middleware.
  Change what data is logged and when.\n\n## Usage\n\nHere is one example from the
  **examples/password** directory where we use the filter logger to implement password
  filtering. The example uses `scotty` for our web server, and we use the `logShowJSON`
  and `logFilterJSON` helper functions to help us create our instances.\n\n### Password
  Filtering\n\n```haskell\n\n{-# LANGUAGE DeriveGeneric     #-}\n{-# LANGUAGE OverloadedStrings
  #-}\n{-# LANGUAGE RecordWildCards   #-}\n\nmodule Main where\n\nimport           Data.Aeson\nimport
  \          GHC.Generics\nimport           Network.Wai.Middleware.FilterLogger\nimport
  \          Web.Scotty\n\ndata LoginRequest = LoginRequest {\n    username :: String\n
  \ , password :: String\n  } deriving (Generic)\n\ninstance FromJSON LoginRequest
  where\ninstance ToJSON LoginRequest where\n\ninstance LogShowable LoginRequest where\n
  \ logShow = logShowJSON\n\ninstance LogFilterable LoginRequest where\n  prep = logFilterJSON\n\ninstance
  Loggable LoginRequest where\n\nmain :: IO ()\nmain = scotty 3000 $ do\n  middleware
  filterPasswords\n  post \"/\" $ text \"SUCCESS\"\n\nfilterPasswords =\n  mkFilterLogger
  True hidePasswords\n  where hidePasswords r@LoginRequest{..} = Just r {password
  = \"*****\"}\n\n```\n\nSending a POST request to localhost:3000 with a body like\n```\n{\n
  \ \"username\": \"test-username\",\n  \"password\": \"myPassw0rd123\"\n}\n```\n\n
  \ will result in a log message like\n```\n11/Jul/2017:21:48:20 -0400\n200 - OK\n0.03ms\n{\n
  \   \"username\": \"test-username\",\n    \"password\": \"*****\"\n}\n```\n\n###
  Chaining Filters\n\nHere is a rather contrived example showing that you can chain
  these filters together easily and do all sorts of filtering.\n\n```haskell\n\n{-#
  LANGUAGE OverloadedStrings #-}\n\nmodule Main where\n\nimport           Control.Monad\nimport
  qualified Data.ByteString                     as BS (elem, length)\nimport           Data.Char\nimport
  \          Data.Word\nimport           Network.Wai.Middleware.FilterLogger\nimport
  \          Web.Scotty\n\nmain :: IO ()\nmain = scotty 3000 $ do\n  middleware filteringMiddleware\n
  \ post \"/\" $ text \"SUCCESS\"\n\nfilteringMiddleware =\n  mkFilterLogger True
  (keepShortBodies >=> containing 'c')\n  where keepShortBodies bs\n          | BS.length
  bs < 10 = Just bs\n          | otherwise         = Nothing\n        containing c
  bs\n          | BS.elem (fromIntegral $ ord c) bs = Just bs\n          | otherwise
  \                        = Nothing\n\n```\n\nSending a POST request to localhost:3000
  with a body like\n```\nabcdefghi\n```\n\nwill result in a log message like\n```\n11/Jul/2017:22:00:59
  -0400\n200 - OK\n0.03ms\nabcdefghi\n```\n\nIf you send a POST request with a body
  like\n```\nabcdefghij\n```\nor\n```\nabdefghij\n```\n\nyou won't see anything in
  the server logs.\n"
license-name: MIT
