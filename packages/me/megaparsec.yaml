homepage: https://github.com/mrkkrp/megaparsec
changelog-type: markdown
hash: c9df29f1a3bb2d7bf5e7ede351aaa84dee98639cb925e9538c70a39e2243fb30
test-bench-deps:
  test-framework-hunit: ! '>=0.2 && <0.4'
  bytestring: ! '>=0.10 && <2'
  test-framework: ! '>=0.6 && <1'
  base: ! '>=4.6 && <5'
  text: ! '>=1.2 && <2'
  megaparsec: ! '>=4.3'
  test-framework-quickcheck2: ! '>=0.3 && <0.4'
  criterion: ! '>=0.6.2.1 && <1.2'
  HUnit: ! '>=1.2 && <1.4'
  mtl: ==2.*
  transformers: ==0.4.*
  QuickCheck: ! '>=2.4 && <3'
maintainer: Mark Karpov <markkarpov@opmbx.org>
synopsis: Monadic parser combinators
changelog: ! "## Megaparsec 4.3.0\n\n* Canonicalized `Applicative`/`Monad` instances.
  Thanks to Herbert Valerio\n  Riedel.\n\n* Custom messages in `ParseError` are printed
  each on its own line.\n\n* Now accumulated hints are not used with `ParseError`
  records that have\n  only custom messages in them (created with `Message` constructor,
  as\n  opposed to `Unexpected` or `Expected`). This strips “expected” line from\n
  \ custom error messages where it's unlikely to be relevant anyway.\n\n* Added higher-level
  combinators for indentation-sensitive grammars:\n  `indentLevel`, `nonIndented`,
  and `indentBlock`.\n\n## Megaparsec 4.2.0\n\n* Made `newPos` constructor and other
  functions in `Text.Megaparsec.Pos`\n  smarter. Now it's impossible to create `SourcePos`
  with non-positive line\n  number or column number. Unfortunately we cannot use `Numeric.Natural`\n
  \ because we need to support older versions of `base`.\n\n* `ParseError` is now
  a monoid. `mergeError` is used as `mappend`.\n\n* Added functions `addErrorMessages`
  and `newErrorMessages` to add several\n  messages to existing error and to construct
  error with several attached\n  messages respectively.\n\n* `parseFromFile` now lives
  in `Text.Megaparsec.Prim`. Previously we had 5\n  nearly identical definitions of
  the function, varying only in\n  type-specific `readFile` function. Now the problem
  is solved by\n  introduction of `StorableStream` type class. All supported stream
  types\n  are instances of the class out of box and thus we have polymorphic version\n
  \ of `parseFromFile`.\n\n* `ParseError` is now instance of `Exception` (and `Typeable`).\n\n*
  Introduced `runParser'` and `runParserT'` functions that take and return\n  parser
  state. This makes it possible to partially parse input, resume\n  parsing, specify
  non-standard initial textual position, etc.\n\n* Introduced `failure` function that
  allows to fail with arbitrary\n  collection of messages. `unexpected` is now defined
  in terms of\n  `failure`. One consequence of this design decision is that `failure`
  is\n  now method of `MonadParsec`, while `unexpected` is not.\n\n* Removed deprecated
  combinators from `Text.Megaparsec.Combinator`:\n\n    * `chainl`\n    * `chainl1`\n
  \   * `chainr`\n    * `chainr1`\n\n* `number` parser in `Text.Megaparsec.Lexer`
  now can be used with `signed`\n  combinator to parse either signed `Integer` or
  signed `Double`.\n\n## Megaparsec 4.1.1\n\n* Fixed bug in implementation of `sepEndBy`
  and `sepEndBy1` and removed\n  deprecation notes for these functions.\n\n* Added
  tests for `sepEndBy` and `sepEndBy1`.\n\n## Megaparsec 4.1.0\n\n* Relaxed dependency
  on `base`, so that minimal required version of `base`\n  is now 4.6.0.0. This allows
  Megaparsec to compile with GHC 7.6.x.\n\n* `Text.Megaparsec` and `Text.Megaparsec.Prim`
  do not export data types\n  `Consumed` and `Reply` anymore because they are rather
  low-level\n  implementation details that should not be visible to end-user.\n\n*
  Representation of file name and textual position in error messages was\n  made conventional.\n\n*
  Fixed some typos is documentation and other materials.\n\n## Megaparsec 4.0.0\n\n###
  General changes\n\n* Renamed `many1` → `some` as well as other parsers that had
  `many1` part in\n  their names.\n\n* The following functions are now re-exported
  from `Control.Applicative`:\n  `(<|>)`, `many`, `some`, `optional`. See #9.\n\n*
  Introduced type class `MonadParsec` in the style of MTL monad\n  transformers. Eliminated
  built-in user state since it was not flexible\n  enough and can be emulated via
  stack of monads. Now all tools in\n  Megaparsec work with any instance of `MonadParsec`,
  not only with\n  `ParsecT`.\n\n* Added new function `parseMaybe` for lightweight
  parsing where error\n  messages (and thus file name) are not important and entire
  input should be\n  parsed. For example it can be used when parsing of single number
  according\n  to specification of its format is desired.\n\n* Fixed bug with `notFollowedBy`
  always succeeded with parsers that don't\n  consume input, see #6.\n\n* Flipped
  order of arguments in the primitive combinator `label`, see #21.\n\n* Renamed `tokenPrim`
  → `token`, removed old `token`, because `tokenPrim` is\n  more general and original
  `token` is little used.\n\n* Made `token` parser more powerful, now its second argument
  can return\n  `Either [Message] a` instead of `Maybe a`, so it can influence error\n
  \ message when parsing of token fails. See #29.\n\n* Added new primitive combinator
  `hidden p` which hides “expected” tokens in\n  error message when parser `p` fails.\n\n*
  Tab width is not hard-coded anymore. It can be manipulated via\n  `getTabWidth`
  and `setTabWidth`. Default tab-width is `defaultTabWidth`,\n  which is 8.\n\n###
  Error messages\n\n* Introduced type class `ShowToken` and improved representation
  of\n  characters and strings in error messages, see #12.\n\n* Greatly improved quality
  of error messages. Fixed entire\n  `Text.Megaparsec.Error` module, see #14 for more
  information. Made\n  possible normal analysis of error messages without “render
  and re-parse”\n  approach that previous maintainers had to practice to write even
  simplest\n  tests, see module `Utils.hs` in `old-tests` for example.\n\n* Reduced
  number of `Message` constructors (now there are only `Unexpected`,\n  `Expected`,
  and `Message`). Empty “magic” message strings are ignored now,\n  all the library
  now uses explicit error messages.\n\n* Introduced hint system that greatly improves
  quality of error messages and\n  made code of `Text.Megaparsec.Prim` a lot clearer.\n\n###
  Built-in combinators\n\n* All built-in combinators in `Text.Megaparsec.Combinator`
  now work with any\n  instance of `Alternative` (some of them even with `Applicaitve`).\n\n*
  Added more powerful `count'` parser. This parser can be told to parse from\n  `m`
  to `n` occurrences of some thing. `count` is defined in terms of\n  `count'`.\n\n*
  Removed `optionMaybe` parser, because `optional` from\n  `Control.Applicative` does
  the same thing.\n\n* Added combinator `someTill`.\n\n* These combinators are considered
  deprecated and will be removed in future:\n\n    * `chainl`\n    * `chainl1`\n    *
  `chainr`\n    * `chainr1`\n    * `sepEndBy`\n    * `sepEndBy1`\n\n### Character
  parsing\n\n* Renamed some parsers:\n\n    * `alphaNum` → `alphaNumChar`\n    * `digit`
  → `digitChar`\n    * `endOfLine` → `eol`\n    * `hexDigit` → `hexDigitChar`\n    *
  `letter` → `letterChar`\n    * `lower` → `lowerChar`\n    * `octDigit` → `octDigitChar`\n
  \   * `space` → `spaceChar`\n    * `spaces` → `space`\n    * `upper` → `upperChar`\n\n*
  Added new character parsers in `Text.Megaparsec.Char`:\n\n    * `asciiChar`\n    *
  `charCategory`\n    * `controlChar`\n    * `latin1Char`\n    * `markChar`\n    *
  `numberChar`\n    * `printChar`\n    * `punctuationChar`\n    * `separatorChar`\n
  \   * `symbolChar`\n\n* Descriptions of old parsers have been updated to accent
  some\n  Unicode-specific moments. For example, old description of `letter` stated\n
  \ that it parses letters from “a” to “z” and from “A” to “Z”. This is wrong,\n  since
  it used `Data.Char.isAlpha` predicate internally and thus parsed\n  many more characters
  (letters of non-Latin languages, for example).\n\n* Added combinators `char'`, `oneOf'`,
  `noneOf'`, and `string'` which are\n  case-insensitive variants of `char`, `oneOf`,
  `noneOf`, and `string`\n  respectively.\n\n### Lexer\n\n* Rewritten parsing of numbers,
  fixed #2 and #3 (in old Parsec project these\n  are number 35 and 39 respectively),
  added per bug tests.\n\n    * Since Haskell report doesn't say anything about sign,
  `integer` and\n      `float` now parse numbers without sign.\n\n    * Removed `natural`
  parser, it's equal to new `integer` now.\n\n    * Renamed `naturalOrFloat` → `number`
  — this doesn't parse sign too.\n\n    * Added new combinator `signed` to parse all
  sorts of signed numbers.\n\n* Transformed `Text.Parsec.Token` into `Text.Megaparsec.Lexer`.
  Little of\n  Parsec's code remains in the new lexer module. New module doesn't impose\n
  \ any assumptions on user and should be vastly more useful and\n  general. Hairy
  stuff from original Parsec didn't get here, for example\n  built-in Haskell functions
  are used to parse escape sequences and the like\n  instead of trying to re-implement
  the whole thing.\n\n### Other\n\n* Renamed the following functions:\n\n    * `permute`
  → `makePermParser`\n    * `buildExpressionParser` → `makeExprParser`\n\n* Added
  comprehensive QuickCheck test suite.\n\n* Added benchmarks.\n\n## Parsec 3.1.9\n\n*
  Many and various updates to documentation and package description\n  (including
  the homepage links).\n\n* Add an `Eq` instance for `ParseError`.\n\n* Fixed a regression
  from 3.1.6: `runP` is again exported from module\n  `Text.Parsec`.\n\n## Parsec
  3.1.8\n\n* Fix a regression from 3.1.6 related to exports from the main module.\n\n##
  Parsec 3.1.7\n\n* Fix a regression from 3.1.6 related to the reported position of
  error\n  messages. See bug #9 for details.\n\n* Reset the current error position
  on success of `lookAhead`.\n\n## Parsec 3.1.6\n\n* Export `Text` instances from
  `Text.Parsec`.\n\n* Make `Text.Parsec` exports more visible.\n\n* Re-arrange `Text.Parsec`
  exports.\n\n* Add functions `crlf` and `endOfLine` to `Text.Parsec.Char` for handling\n
  \ input streams that do not have normalized line terminators.\n\n* Fix off-by-one
  error in `Token.charControl`.\n\n## Parsec 3.1.4 & 3.1.5\n\n* Bump dependency on
  `text`.\n\n## Parsec 3.1.3\n\n* Fix a regression introduced in 3.1.2 related to
  positions reported by\n  error messages.\n"
basic-deps:
  bytestring: -any
  base: ! '>=4.6 && <5'
  text: ! '>=0.2'
  mtl: ==2.*
  transformers: ! '>=0.4'
all-versions:
- '4.0.0'
- '4.1.0'
- '4.1.1'
- '4.2.0'
- '4.3.0'
author: ! 'Megaparsec contributors,

  Paolo Martini <paolo@nemail.it>,

  Daan Leijen <daan@microsoft.com>'
latest: '4.3.0'
description-type: markdown
description: ! "# Megaparsec\n\n[![License FreeBSD](https://img.shields.io/badge/license-FreeBSD-brightgreen.svg)](http://opensource.org/licenses/BSD-2-Clause)\n[![Hackage](https://img.shields.io/hackage/v/megaparsec.svg?style=flat)](https://hackage.haskell.org/package/megaparsec)\n[![Stackage
  Nightly](http://stackage.org/package/megaparsec/badge/nightly)](http://stackage.org/nightly/package/megaparsec)\n[![Build
  Status](https://travis-ci.org/mrkkrp/megaparsec.svg?branch=master)](https://travis-ci.org/mrkkrp/megaparsec)\n[![Coverage
  Status](https://coveralls.io/repos/mrkkrp/megaparsec/badge.svg?branch=master&service=github)](https://coveralls.io/github/mrkkrp/megaparsec?branch=master)\n\n*
  [Features](#features)\n    * [Core features](#core-features)\n    * [Character parsing](#character-parsing)\n
  \   * [Permutation parsing](#permutation-parsing)\n    * [Expression parsing](#expression-parsing)\n
  \   * [Lexer](#lexer)\n* [Documentation](#documentation)\n* [Tutorials](#tutorials)\n*
  [Comparison with other solutions](#comparison-with-other-solutions)\n    * [Megaparsec
  and Attoparsec](#megaparsec-and-attoparsec)\n    * [Megaparsec and Parsec](#megaparsec-and-parsec)\n
  \   * [Megaparsec and Parsers](#megaparsec-and-parsers)\n* [Authors](#authors)\n*
  [Contribution](#contribution)\n* [License](#license)\n\nThis is an industrial-strength
  monadic parser combinator library. Megaparsec\nis a fork of [Parsec](https://github.com/aslatter/parsec)
  library originally\nwritten by Daan Leijen.\n\n## Features\n\nThis project provides
  flexible solutions to satisfy common parsing\nneeds. The section describes them
  shortly. If you're looking for\ncomprehensive documentation, see the\n[section about
  documentation](#documentation).\n\n### Core features\n\nThe package is built around
  `MonadParsec`, a MTL-style monad\ntransformer. All tools and features work with
  any instance of\n`MonadParsec`. You can achieve various effects combining monad
  transformers,\ni.e. building monad stack. Since most common monad transformers like\n`WriterT`,
  `StateT`, `ReaderT` and others are instances of `MonadParsec`,\nyou can wrap `ParsecT`
  *in* these monads, achieving, for example,\nbacktracking state.\n\nOn the other
  hand `ParsecT` is instance of many type classes as well. The\nmost useful ones are
  `Monad`, `Applicative`, `Alternative`, and\n`MonadParsec`.\n\nThe module\n[`Text.Megaparsec.Combinator`](https://hackage.haskell.org/package/megaparsec/docs/Text-Megaparsec-Combinator.html)\n(its
  functions are included in `Text.Megaparsec`) contains traditional,\ngeneral combinators
  that work with any instance of `Alternative` and some\neven with instances of `Applicative`.\n\nRole
  of `Monad`, `Applicative`, and `Alternative` should be obvious, so\nlet's enumerate
  methods of `MonadParsec` type class. The class represents\ncore, basic functions
  of Megaparsec parsing. The rest of library is built\nvia combination of these primitives:\n\n*
  `failure` allows to fail with arbitrary collection of messages.\n\n* `label` allows
  to add a “label” to any parser, so when it fails the user will\n  see the label
  in the error message where “expected” items are enumerated.\n\n* `hidden` hides
  any parser from error messages altogether, this is\n  officially recommended way
  to hide things, prefer it to the `label \"\"`\n  approach.\n\n* `try` enables backtracking
  in parsing.\n\n* `lookAhead` allows to parse something without consuming input.\n\n*
  `notFollowedBy` succeeds when its argument fails, it does not consume\n  input.\n\n*
  `eof` only succeeds at the end of input.\n\n* `token` is used to parse single token.\n\n*
  `tokens` makes it easy to parse several tokens in a row.\n\n* `getParserState` returns
  full parser state.\n\n* `updateParserState` applies given function on parser state.\n\nThis
  list of core functions is longer than in some other libraries. Our goal\nwas easy
  and readable implementation of functionality provided by every such\nprimitive,
  not minimal number of them. You can read the comprehensive\ndescription of every
  primitive function in [Megaparsec documentation](https://hackage.haskell.org/package/megaparsec/docs/Text-Megaparsec-Prim.html).\n\nMegaparsec
  can currently work with the following types of input stream:\n\n* `String` = `[Char]`\n\n*
  `ByteString` (strict and lazy)\n\n* `Text` (strict and lazy)\n\n### Character parsing\n\nMegaparsec
  has decent support for Unicode-aware character parsing. Functions\nfor character
  parsing live in [`Text.Megaparsec.Char`](https://hackage.haskell.org/package/megaparsec/docs/Text-Megaparsec-Char.html)
  (they all are\nincluded in `Text.Megaparsec`). The functions can be divided into
  several\ncategories:\n\n* *Simple parsers* — parsers that parse certain character
  or several\n  characters of the same kind. This includes `newline`, `crlf`, `eol`,\n
  \ `tab`, and `space`.\n\n* *Parsers corresponding to categories of characters* parse
  single character\n  that belongs to certain category of characters, for example:\n
  \ `controlChar`, `spaceChar`, `upperChar`, `lowerChar`, `printChar`,\n  `digitChar`,
  and others.\n\n* *General parsers* that allow you to parse a single character you
  specify\n  or one of given characters, or any character except for given ones, or\n
  \ character satisfying given predicate. Case-insensitive versions of the\n  parsers
  are available.\n\n* *Parsers for sequences of characters* parse strings. These are
  more\n  efficient and provide better error messages than other approaches most\n
  \ programmers can come up with. Case-sensitive `string` parser is available\n  as
  well as case-insensitive `string'`.\n\n### Permutation parsing\n\nFor those who
  are interested in parsing of permutation phrases, there is\n[`Text.Megaparsec.Perm`](https://hackage.haskell.org/package/megaparsec/docs/Text-Megaparsec-Perm.html).
  You have to import the module explicitly, it's not\nincluded in the `Text.Megaparsec`
  module.\n\n### Expression parsing\n\nMegaparsec has a solution for parsing of expressions.
  Take a look at\n[`Text.Megaparsec.Expr`](https://hackage.haskell.org/package/megaparsec/docs/Text-Megaparsec-Expr.html).
  You have to import the module explicitly, it's not\nincluded in the `Text.Megaparsec`.\n\nGiven
  a table of operators that describes their fixity and precedence, you\ncan construct
  a parser that will parse any expression involving the\noperators. See documentation
  for comprehensive description of how it works.\n\n### Lexer\n\n[`Text.Megaparsec.Lexer`](https://hackage.haskell.org/package/megaparsec/docs/Text-Megaparsec-Lexer.html)\nis
  a module that should help you write your lexer. If you have used `Parsec`\nin the
  past, this module “fixes” its particularly inflexible\n`Text.Parsec.Token`.\n\n`Text.Megaparsec.Lexer`
  is intended to be imported qualified, it's not\nincluded in `Text.Megaparsec`. The
  module doesn't impose how you should\nwrite your parser, but certain approaches
  may be more elegant than\nothers. An especially important theme is parsing of white
  space, comments,\nand indentation.\n\nThe design of the module allows you quickly
  solve simple tasks and doesn't\nget in your way when you want to implement something
  less standard.\n\n## Documentation\n\nMegaparsec is well-documented. All functions
  and data-types are thoroughly\ndescribed. We pay attention to avoid outdated info
  or unclear phrases in our\ndocumentation. See the [current version of Megaparsec
  documentation on\nHackage](https://hackage.haskell.org/package/megaparsec) for yourself.\n\n##
  Tutorials\n\nYou can visit [site of the project](https://mrkkrp.github.io/megaparsec/)\nwhich
  has [several tutorials](https://mrkkrp.github.io/megaparsec/tutorials.html) that\nshould
  help you to start with your parsing tasks. The site also has\ninstructions and tips
  for Parsec users who decide to switch.\n\n## Comparison with other solutions\n\nThere
  are quite a few libraries that can be used for parsing in Haskell,\nlet's compare
  Megaparsec with some of them.\n\n### Megaparsec and Attoparsec\n\n[Attoparsec](https://github.com/bos/attoparsec)
  is another prominent Haskell\nlibrary for parsing. Although the both libraries deal
  with parsing, it's\nusually easy to decide which you will need in particular project:\n\n*
  *Attoparsec* is much faster but not that feature-rich. It should be used\n  when
  you want to process large amounts of data where performance matters\n  more than
  quality of error messages.\n\n* *Megaparsec* is good for parsing of source code
  or other human-readable\n  texts. It has better error messages and it's implemented
  as monad\n  transformer.\n\nSo, if you work with something human-readable where
  size of input data is\nusually not huge, just go with Megaparsec, otherwise Attoparsec
  may be a\nbetter choice.\n\n### Megaparsec and Parsec\n\nSince Megaparsec is a fork
  of Parsec, it's necessary to list main\ndifferences between the two libraries:\n\n*
  Better error messages. We test our error messages using dense QuickCheck\n  tests.
  Good error messages are just as important for us as correct return\n  values of
  our parsers. Megaparsec will be especially useful if you write\n  compiler or interpreter
  for some language.\n\n* Some quirks and “buggy features” (as well as plain bugs)
  of original\n  Parsec are fixed. There is no undocumented surprising stuff in Megaparsec.\n\n*
  Better support for Unicode parsing in `Text.Megaparsec.Char`.\n\n* Megaparsec has
  more powerful combinators and can parse languages where\n  indentation matters.\n\n*
  Comprehensive QuickCheck test suite covering nearly 100% of our code.\n\n* We have
  benchmarks to detect performance regressions.\n\n* Better documentation, with 100%
  of functions covered, without typos and\n  obsolete information, with working examples.
  Megaparsec's documentation is\n  well-structured and doesn't contain things useless
  to end users.\n\n* Megaparsec's code is clearer and doesn't contain “magic” found
  in original\n  Parsec.\n\nIf you want to see a detailed change log, `CHANGELOG.md`
  may be helpful.\n\nTo be honest Parsec's development has seemingly stagnated. It
  has no test\nsuite (only three per-bug tests), and all its releases beginning from\nversion
  3.1.2 (according or its change log) were about introducing and\nfixing regressions.
  Parsec is old and somewhat famous in Haskell community,\nso we understand there
  will be some kind of inertia, but we advise you use\nMegaparsec from now on because
  it solves many problems of original Parsec\nproject. If you think you still have
  a reason to use original Parsec, open\nan issue.\n\n### Megaparsec and Parsers\n\nThere
  is [Parsers](https://hackage.haskell.org/package/parsers) package,\nwhich is great.
  You can use it with Megaparsec or Parsec, but consider the\nfollowing:\n\n* It depends
  on *both* Attoparsec and Parsec, which means you always grab\n  useless code installing
  it. This is ridiculous, by the way, because this\n  package is supposed to be useful
  for parser builders, so they can write\n  basic core functionality and get the rest
  “for free”. But with these\n  useful functions you get two more parsers as dependencies.\n\n*
  It currently has a bug in definition of `lookAhead` for various monad\n  transformers
  like `StateT`, etc. which is visible when you create\n  backtracking state via monad
  stack, not via built-in features.\n\nWe intended to use Parsers library in Megaparsec
  at some point, but aside\nfrom already mentioned flaws the library has different
  conventions for\nnaming of things, different set of “core” functions, etc., different\napproach
  to lexer. So it didn't happen, Megaparsec has minimal dependencies,\nit is feature-rich
  and self-contained.\n\n## Authors\n\nThe project was started and is currently maintained
  by Mark Karpov. You can\nfind complete list of contributors in `AUTHORS.md` file
  in official\nrepository of the project. Thanks to all the people who propose features
  and\nideas, although they are not in `AUTHORS.md`, without them Megaparsec would\nnot
  be that good.\n\n## Contribution\n\nIssues (bugs, feature requests or otherwise
  feedback) may be reported in\n[the GitHub issue tracker for this project](https://github.com/mrkkrp/megaparsec/issues).\n\nPull
  requests are also welcome (and yes, they will get attention and will be\nmerged
  quickly if they are good, we are progressive folks).\n\nIf you want to write a tutorial
  to be hosted on Megaparsec's site, open an\nissue or pull request [here](https://github.com/mrkkrp/megaparsec-site).\n\n##
  License\n\nCopyright © 2015–2016 Megaparsec contributors<br>\nCopyright © 2007 Paolo
  Martini<br>\nCopyright © 1999–2000 Daan Leijen\n\nDistributed under FreeBSD license.\n"
license-name: BSD2
