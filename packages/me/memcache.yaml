homepage: https://github.com/dterei/memcache-hs
changelog-type: ''
hash: e2c5539d954c45c856aaf2f3258f039ec510d705bbc5aca95a6e3411b6c87f73
test-bench-deps:
  bytestring: ! '>=0.9.2.1'
  base: <5
  criterion: ! '>0.6.0.0'
  memcache: -any
maintainer: David Terei <code@davidterei.com>
synopsis: A memcached client library.
changelog: ''
basic-deps:
  bytestring: ! '>=0.9.2.1'
  base: <5
  time: ! '>=1.4'
  resource-pool: ! '>=0.2.1.0'
  network: ! '>=2.4'
  blaze-builder: ! '>=0.3.1.0'
  binary: ! '>=0.6.2.0'
  hashable: ! '>=1.2.0.3'
  vector-algorithms: ! '>=0.5'
  vector: ! '>=0.7'
all-versions:
- '0.0.0'
- '0.0.1'
author: David Terei <code@davidterei.com>
latest: '0.0.1'
description-type: markdown
description: ! "# memcache: Haskell Memcache Client\n\n[![Hackage version](https://img.shields.io/hackage/v/memcache.svg?style=flat)](https://hackage.haskell.org/package/memcache)
  [![Build Status](https://img.shields.io/travis/dterei/memcache-hs.svg?style=flat)](https://travis-ci.org/dterei/memcache-hs)\n\nThis
  library provides a client interface to a Memcache cluster. It is\naimed at full
  binary protocol support, ease of use and speed.\n\n## Licensing\n\nThis library
  is BSD-licensed.\n\n## Tools\n\nThis library also includes a few tools for manipulating
  and\nexperimenting with memcached servers.\n\n* `OpGen` -- A load generator for
  memcached. Doesn't collect timing\n  statistics, other tools like\n  [mutilate](https://github.com/leverich/mutilate)
  already do that\n  very well. This tool is useful in conjunction with mutilate.\n*
  `Loader` -- A tool to load random data of a certain size into a\n  memcache server.
  Useful for priming a server for testing.\n\n## Architecture Notes\n\nWe're relying
  on `Data.Pool` for thread safety right now, which is\nfine but is a blocking API
  in that when we grab a socket\n(`withResource`) we are blocking any other requests
  being sent over\nthat connection until we get a response. That is, we can't pipeline.\n\nNow,
  use of multiple connections through the pool abstraction is an\neasy way to solve
  this and perhaps the right approach. But, could also\nimplement own pool abstraction
  that allowed pipelining. This wouldn't\nbe a pool abstraction so much as just round-robbining
  over multiple\nconnections for performance.\n\nEither way, a pool is fine for now.\n\n##
  ToDo\n\nRequired:\n* Connection error handling\n* SASL -- tie in with cluster management\n*
  Timeouts\n* Pull cluster and server creation into client\n\nOptional:\n* Multi-get\n*
  Generic multi operation support\n* Customizable server sharding -- mod & virtual
  servers\n\nNice-to-have:\n* Asynchronous support\n* Customizable -- timeout, max
  connection retries, hash algorithm\n* Max value validation\n* Optimizations --  http://code.google.com/p/spymemcached/wiki/Optimizations\n*
  UDP\n* ASCII\n* Server error handling mode where we return misses and ignore sets\n\nMaybe:\n*
  Typeclass for serialization\n* Monad / Typeclass for memcache\n\n## Other clients\n\n*
  [C: libmemcached](http://libmemcached.org/libMemcached.html)\n* [Java: SpyMemcached](http://code.google.com/p/spymemcached/)\n*
  [Ruby: Dalli](https://github.com/mperham/dalli)\n\n## Get involved!\n\nWe are happy
  to receive bug reports, fixes, documentation enhancements,\nand other improvements.\n\nPlease
  report bugs via the\n[github issue tracker](http://github.com/dterei/mc-hs/issues).\n\nMaster
  [git repository](http://github.com/dterei/mc-hs):\n\n* `git clone git://github.com/dterei/mc-hs.git`\n\n##
  Authors\n\nThis library is written and maintained by David Terei,\n<code@davidterei.com>.\n\n"
license-name: BSD3
