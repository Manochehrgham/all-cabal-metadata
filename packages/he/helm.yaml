changelog-type: ''
hash: 17ef9b89c073ecda6e4d4e7d7e7138a9a58c21c7ff6d64d51c49a966fde9f9fc
test-bench-deps:
  test-framework-hunit: ! '>=0.3 && <1'
  test-framework: ! '>=0.8 && <1'
  base: ! '>=4 && <5'
  time: ! '>=1.4 && <1.5'
  test-framework-quickcheck2: ! '>=0.3 && <1'
  cairo: ! '>0.12 && <0.13'
  HUnit: ! '>=1.2 && <2'
  sdl2: ! '>=1.1 && <1.3'
  containers: ! '>=0.5 && <1'
  elerea: ! '>=2.7 && <3'
synopsis: A functionally reactive game engine.
changelog: ''
basic-deps:
  pango: ! '>0.12 && <0.13'
  base: ! '>=4 && <5'
  time: ! '>=1.4 && <1.5'
  text: ! '>=1.1.1.3'
  filepath: ! '>=1.3 && <2'
  cairo: ! '>0.12 && <0.13'
  sdl2: ! '>=1.1 && <1.3'
  containers: ! '>=0.5 && <1'
  ghc-prim: -any
  elerea: ! '>=2.7 && <3'
  mtl: ! '>=2.1 && <2.2'
  transformers: ! '>=0.3.0.0'
  random: ! '>=1.0.1.1 && <1.2'
  cpu: ! '>=0.1.2 && <1'
all-versions:
- '0.1.0'
- '0.2.0'
- '0.3.0'
- '0.3.1'
- '0.4'
- '0.5.0'
- '0.6.0'
- '0.6.1'
- '0.7.0'
- '0.7.1'
latest: '0.7.1'
description-type: markdown
description: ! "<p align=\"center\">\n  <a href=\"http://helm-engine.org\" title=\"Homepage\"><img
  src=\"http://helm-engine.org/img/logo-alt.png\" /></a>\n  <br>\n  <br>\n  <a href=\"https://travis-ci.org/switchface/helm\"
  title=\"Travis CI\"><img src=\"https://travis-ci.org/switchface/helm.svg\" /></a>\n</p>\n\n##
  Introduction\n\nHelm is a functionally reactive game engine written in Haskell and
  built around\nthe [Elerea FRP framework](https://github.com/cobbpg/elerea). Helm
  is\nheavily inspired by the [Elm programming language](http://elm-lang.org) (especially
  the API).\nAll rendering is done through a vector-graphics based API. At the core,
  Helm is\nbuilt on SDL and the Cairo vector graphics library.\n\nIn Helm, every piece
  of input that can be gathered from a user (or the operating system)\nis hidden behind
  a signal. For those unfamiliar with FRP, signals are essentially\na value that changes
  over time. This sort of architecture used for a game allows for pretty\nsimplistic
  (and in my opinion, artistic) code.\n\nDocumentation of the Helm API is available
  on [Hackage](http://hackage.haskell.org/package/helm).\nThere is currently a heavily
  work-in-progress guide on [Helm's website](http://helm-engine.org/guide),\nwhich
  is a resource aiming to give thorough explanations of the way Helm and its API work
  through examples.\nYou can [ask on the mailing list](https://groups.google.com/d/forum/helm-dev)
  if you're having any trouble\nwith using the engine for games or working on the
  engine itself, or if you just want to chit-chat about\nHelm.\n\n## Features\n\n*
  Allows you to express game logic dependent on input in a straightforward manner,\n
  \ treating events as first class values (the essence of FRP).\n* Vector graphics
  based rendering, allow you to either write art\n  designed for any resolution or
  still load generic images and render\n  those as you would with any pixel-blitting
  engine.\n* Straightforward API heavily inspired by the Elm programming language.
  The API\n  is broken up into the following areas:\n  * `FRP.Helm` contains the main
  code for interfacing with the game engine but\n    also includes some utility functions
  and the modules `FRP.Helm.Color`, `FRP.Helm.Utilities`\n    and `FRP.Helm.Graphics`
  in the style of a sort of prelude library, allowing it to be included\n    and readily
  make the most basic of games.\n  * `FRP.Helm.Color` contains the `Color` data structure,
  functions for composing\n    colors and a few pre-defined colors that are usually
  used in games.\n  * `FRP.Helm.Graphics` contains all the graphics data structures,
  functions\n    for composing these structures and other general graphical utilities.\n
  \ * `FRP.Helm.Keyboard` contains signals for working with keyboard state.\n  * `FRP.Helm.Mouse`
  contains signals for working with mouse state.\n  * `FRP.Helm.Random` contains signals
  for generating random values\n  * `FRP.Helm.Signal`  constains useful functions
  for working with signals such\n     as lifting/folding\n  * `FRP.Helm.Text` contains
  functions for composing text, formatting it\n    and then turning it into an element.\n
  \ * `FRP.Helm.Time` contains functions for composing units of time and time-dependant
  signals\n  * `FRP.Helm.Utilities` contains an assortment of useful functions,\n
  \ * `FRP.Helm.Window` contains signals for working with the game window state.\n\n##
  Example\n\nThe simplest example of a Helm game that doesn't require any input from
  the user is the following:\n\n```haskell\nimport FRP.Helm\nimport qualified FRP.Helm.Window
  as Window\n\nrender :: (Int, Int) -> Element\nrender (w, h) = collage w h [move
  (100, 100) $ filled red $ square 64]\n\nmain :: IO ()\nmain = run defaultConfig
  $ render <~ Window.dimensions\n```\n\nIt renders a red square at the position `(100,
  100)` with a side length of `64`.\n\nThe next example is the barebones of a game
  that depends on input. It shows how to create\nan accumulated state that depends
  on the values sampled from signals (e.g. mouse input).\nYou should see a white square
  on the screen and pressing the arrow keys allows you to move it.\n\n```haskell\nimport
  FRP.Helm\nimport qualified FRP.Helm.Keyboard as Keyboard\nimport qualified FRP.Helm.Window
  as Window\n\ndata State = State { mx :: Double, my :: Double }\n\nstep :: (Int,
  Int) -> State -> State\nstep (dx, dy) state = state { mx = (10 * (realToFrac dx))
  + mx state,\n                              my = (10 * (realToFrac dy)) + my state
  }\n\nrender :: (Int, Int) -> State -> Element\nrender (w, h) (State { mx = mx, my
  = my }) =\n  centeredCollage w h [move (mx, my) $ filled white $ square 100]\n\nmain
  :: IO ()\nmain = run defaultConfig $ render <~ Window.dimensions ~~ stepper\n  where\n
  \   state = State { mx = 0, my = 0 }\n    stepper = foldp step state Keyboard.arrows\n```\n\n##
  Installing and Building\n\nHelm requires GHC 7.6 (Elerea doesn't work with older
  versions due to a compiler bug).\nTo install the latest (stable) version from the
  Hackage repository, use:\n\n```\ncabal install helm\n```\n\nAlternatively to get
  the latest development version, you can clone this repository and then run:\n\n```\ncabal
  install\n```\n\nYou may need to jump a few hoops to install the Cairo bindings (which
  are a dependency),\nwhich unfortunately is out of my hands. Read the [installing
  guide](http://helm-engine.org/guide/installing/)\non the website for a few platform-specific
  instructions.\n\n## License\n\nHelm is licensed under the MIT license. See the LICENSE
  file for more details.\n\n## Contributing\n\nHelm would benefit from either of the
  following contributions:\n\n1. Try out the engine, reporting any issues or suggestions
  you have.\n2. Look through the source, get a feel for the code and then\n   contribute
  some features or fixes. If you plan on contributing\n   code please submit a pull
  request and follow the formatting\n   styles set out in the current code: 2 space
  indents, documentation\n   on every top-level function, favouring monad operators
  over\n   do blocks when there is a logical flow of data, spaces between operators\n
  \  and after commas, etc. Please also confirm that the code passes under\n   HLint.\n\nThere
  are a number of issues [tagged with the bounty tag](https://github.com/switchface/helm/issues?labels=bounty&state=open),\nmeaning
  they have associated bounties on [Bountysource](https://www.bountysource.com/trackers/290443-helm).\n"
