homepage: https://github.com/seereason/process-extras
changelog-type: ''
hash: 7227b7d946daf1ccafe901b31c7893a183df52a9d3287bbe89e22ab7bad0e673
test-bench-deps: {}
maintainer: David Fox <dsf@seereason.com>
synopsis: Process extras
changelog: ''
basic-deps:
  bytestring: -any
  base: ! '>=4.5 && <5'
  text: -any
  generic-deriving: ! '>=1.10'
  process: -any
  deepseq: ! '>=1.1'
  ListLike: ! '>=4'
all-versions:
- '0.1.0'
- '0.1.1'
- '0.1.2'
- '0.1.3'
- '0.2.0'
- '0.3.0'
- '0.3.0.1'
- '0.3.1'
- '0.3.3.1'
- '0.3.3.2'
- '0.3.3.3'
- '0.3.3.4'
- '0.3.3.5'
- '0.3.3.6'
- '0.3.3.7'
- '0.3.3.8'
- '0.3.4'
- '0.4'
author: David Lazar, Bas van Dijk, David Fox
latest: '0.4'
description-type: markdown
description: ! "# About\n\nExtra functionality for the [Process library](http://hackage.haskell.org/package/process).\n\n
  * Read process input and output as ByteStrings or Text, or write your own ProcessOutput
  instance.\n * Lazy process input and output (i.e. read output from processes that
  run forever.)\n * ProcessMaker class for more flexibility in the process creation
  API.\n\n# Contributing\n\nThis project is available on [GitHub](https://github.com/seereason/process-extras).
  You may contribute changes there.\n\nPlease report bugs and feature requests using
  the [GitHub issue tracker](https://github.com/seereason/process-extras/issues).\n\n#
  Examples:\n\nThe output type of the raw system process functions is ByteString.\nInstances
  of ListLikeProcessIO are provided to read as type String,\nText, Lazy Text, ByteString,
  or Lazy ByteString.  Select by casting\nthe result, or by specifying the module
  containing the specialized\nfunction:\n\n    > :m +System.Process.ListLike Data.ByteString
  Data.Text.Lazy\n    > readCreateProcessWithExitCode (shell \"echo 'λ'\") mempty
  :: IO (ExitCode, ByteString, ByteString)\n    (ExitSuccess,\"\\206\\187\\n\",\"\")\n
  \   > readCreateProcessWithExitCode (shell \"echo 'λ'\") mempty :: IO (ExitCode,
  Text, Text)\n    (ExitSuccess,\"\\955\\n\",\"\")\n    > readCreateProcessWithExitCode
  (shell \"echo 'λ'\") mempty :: IO (ExitCode, String, String)\n    (ExitSuccess,\"\\955\\n\",\"\")\n
  \   > System.Process.Text.readCreateProcessWithExitCode (shell \"yes | head -10\")
  mempty\n    (ExitSuccess,\"y\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\n\",\"\")\n\nAlthough
  the output *type* can be lazy, normal process functions still\nneed to read until
  EOF on the process output before returing anything.\nIf you have a process whose
  output never ends you can use the\nreadCreateProcessLazy function to read it.  Functions
  like readProcess\nwould block waiting for EOF on the process output:\n\n    > (Prelude.take
  4 <$> readCreateProcessLazy (proc \"yes\" []) mempty :: IO [Chunk Text]) >>= mapM_
  (putStrLn . show)\n    ProcessHandle <process>\n    Stdout \"y\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny
  ...\"\n    ...\n\nThe output type can be any instance of ProcessOutput, instances
  for\ntypes (ExitCode, a, a), [Chunk a], and (ExitCode, [Chunk a]) are\nprovided.
  \ [Chunk a] can be converted to any other instance of\nProcessOutput using collectOutput\n\n
  \   > (readCreateProcess (shell \"gzip -v < /proc/uptime\") mempty :: IO [Chunk
  ByteString]) >>= mapM_ (putStrLn . show)\n    Stdout \"\\US\\139\\b\\NUL\\237\\136\\&7W\\NUL\\ETX345\\183\\&403\\215\\&31Q04267\\177\\&0\\177\\212\\&33\\225\\STX\\NUL_\\169\\142\\178\\ETB\\NUL\\NUL\\NUL\"\n
  \   Stderr \"gzip: stdin: file size changed while zipping\\n -8.7%\\n\"\n    Result
  ExitSuccess\n    > (readCreateProcess (shell \"uptime\") mempty :: IO [Chunk ByteString])
  >>= writeOutput\n     14:00:34 up 18 days,  7:16,  6 users,  load average: 0.04,
  0.10, 0.08\n    > collectOutput <$> (readCreateProcess (shell \"gzip -v < /proc/uptime\")
  mempty :: IO [Chunk ByteString]) :: IO (ExitCode, ByteString, ByteString)\n    (ExitSuccess,\"\\US\\139\\b\\NUL\\185\\137\\&7W\\NUL\\ETX345\\183\\&427\\212\\&33W0426731\\177\\208\\&35\\225\\STX\\NUL\\237\\192\\CAN\\224\\ETB\\NUL\\NUL\\NUL\",\"gzip:
  stdin: file size changed while zipping\\n -8.7%\\n\")\n    > collectOutput <$> (readCreateProcess
  (shell \"gzip -v < /proc/uptime\") mempty :: IO [Chunk ByteString]) :: IO (ExitCode,
  ByteString, ByteString)\n    (ExitSuccess,\"\\US\\139\\b\\NUL\\185\\137\\&7W\\NUL\\ETX345\\183\\&427\\212\\&33W0426731\\177\\208\\&35\\225\\STX\\NUL\\237\\192\\CAN\\224\\ETB\\NUL\\NUL\\NUL\",\"gzip:
  stdin: file size changed while zipping\\n -8.7%\\n\")\n    > (collectOutput . filter
  (\\x -> case x of Stderr _ -> False; _ -> True)) <$> (readCreateProcess (shell \"gzip
  -v < /proc/uptime\") mempty :: IO [Chunk ByteString]) :: IO (ExitCode, ByteString,
  ByteString)\n    (ExitSuccess,\"\\US\\139\\b\\NUL<\\138\\&7W\\NUL\\ETX345\\183\\&410\\210\\&3\\176P04267713\\213\\&37\\224\\STX\\NULT\\142\\EOT\\165\\ETB\\NUL\\NUL\\NUL\",\"\")\n\nSome
  cases that need investigation:\n\n    > (readCreateProcess (shell \"gzip -v < /proc/uptime\")
  mempty :: IO [Chunk String]) >>= mapM_ (putStrLn . show)\n    *** Exception: fd:13:
  hGetContents: invalid argument (invalid byte sequence)\n    > (readCreateProcess
  (shell \"gzip -v < /proc/uptime\") mempty :: IO [Chunk Text]) >>= mapM_ (putStrLn
  . show)\n    *** Exception: fd:13: hClose: invalid argument (Bad file descriptor)\n"
license-name: MIT
