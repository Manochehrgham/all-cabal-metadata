homepage: http://github.com/alpmestan/probable
changelog-type: ''
hash: 9b054ec44ea9544295e97794852c20831091b5b36fa7c5c340f52e55ae92943c
test-bench-deps:
  mwc-random: -any
  base: ==4.*
  mwc-random-monad: -any
  criterion: -any
  probable: -any
  primitive: -any
  vector: ! '>=0.7'
maintainer: alpmestan@gmail.com
synopsis: Easy and reasonably efficient probabilistic programming and random generation
changelog: ''
basic-deps:
  mwc-random: ! '>=0.10'
  base: ! '>=4.5 && <4.8'
  mtl: -any
  statistics: ! '>=0.10'
  transformers: ! '>=0.3'
  primitive: -any
  vector: ! '>=0.10'
all-versions:
- '0.1.0.0'
author: Alp Mestanogullari
latest: '0.1.0.0'
description-type: markdown
description: ! "probable\n========\n\nSimple random value generation for haskell,
  using an efficient\nrandom generator and minimizing system calls. But the library
  also\nlets you work with distributions over a finite set, adapting\ncode from Eric
  Kidd's posts, and all the usual distributions\ncovered in the [statistics](http://hackage.haskell.org/package/statistics)\npackage.\n\nYou
  can see how it looks in [examples](https://github.com/alpmestan/probable/tree/master/examples),
  or below. You can view the documentation for 0.1 [here](http://alpmestan.com/probable/).\n\n##
  Example\n\nSimple example of random generation for your types, using _probable_.\n\n```
  haskell\nmodule Main where\n\nimport Control.Applicative\nimport Control.Monad\nimport
  Math.Probable\n\nimport qualified Data.Vector.Unboxed as VU\n\ndata Person = Person
  \n    { age    :: Int\n    , weight :: Double\n    , salary :: Int\n    } deriving
  (Eq, Show)\n\nperson :: RandT IO Person\nperson = \n    Person <$> intIn (1, 100)\n
  \          <*> doubleIn (2, 130)\n           <*> intIn (500, 10000)\n\nrandomPersons
  :: Int -> IO [Person]\nrandomPersons n = mwc $ listOf n person\n\nrandomDoubles
  :: Int -> IO (VU.Vector Double)\nrandomDoubles n = mwc $ vectorOf n double\n\nmain
  :: IO ()\nmain = do\n\trandomPersons 10 >>= mapM_ print\n\trandomDoubles 10 >>=
  VU.mapM_ print\n```\n\nDistributions over finite sets, conditional probabilities
  and random sampling.\n\n``` haskell\nmodule Main where\n\nimport Math.Probable\n\nimport
  qualified Data.Vector as V\n\ndata Book = Interesting \n\t\t  | Boring\n\tderiving
  (Eq, Show)\n\nbookPrior :: Finite d => d Book\nbookPrior = weighted [ (Interesting,
  0.2) \n\t\t\t\t\t , (Boring, 0.8) \n\t\t\t\t\t ]\n\ntwoBooks :: Finite d => d (Book,
  Book)\ntwoBooks = do\n\tbook1 <- bookPrior\n\tbook2 <- bookPrior\n\treturn (book1,
  book2)\n\nsampleBooks :: RandT IO (V.Vector Book)\nsampleBooks = vectorOf 10 bookPrior\n\noneInteresting
  :: Fin (Book, Book)\noneInteresting = bayes $ do\n\t(b1, b2) <- twoBooks\n\tcondition
  (b1 == Interesting || b2 == Interesting)\n\treturn (b1, b2)\n\nmain :: IO ()\nmain
  = do\n\tprint $ exact bookPrior\n\tmwc sampleBooks >>= print\n\tprint $ exact twoBooks\n\tprint
  $ exact oneInteresting\n```\n"
license-name: BSD3
