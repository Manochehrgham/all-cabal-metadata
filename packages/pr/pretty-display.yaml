homepage: https://github.com/githubuser/pretty-display
changelog-type: ''
hash: 73a0e19cbe87835f591669187aa0eedec343f9f1a1005fed00ea7b86b97515c1
test-bench-deps:
  base: -any
  pretty-display: -any
maintainer: Justin Sermeno
synopsis: Typeclass for human-readable display
changelog: ''
basic-deps:
  ansi-wl-pprint: -any
  base: ! '>=4.7 && <5'
  text: -any
  pretty-show: -any
  pretty-display: -any
all-versions:
- '0.1.0'
- '0.1.1'
- '0.1.2'
- '0.1.3'
- '0.1.4'
- '0.1.5'
author: Justin Sermeno
latest: '0.1.5'
description-type: markdown
description: ! "# pretty-display: typeclass for human-readable display\n\n[![Build
  Status](https://travis-ci.org/jsermeno/pretty-display.svg?branch=master)](https://travis-ci.org/jsermeno/pretty-display)\n[![Haskell
  Programming Language](https://img.shields.io/badge/language-Haskell-blue.svg)](Haskell.org)\n![BSD3
  License](http://img.shields.io/badge/license-BSD3-brightgreen.svg)\n\nIn Haskell
  the `Show` typeclass is used to display a syntactically correct Haskell expression.
  However, there are times when you want to provide a richer display for a value while
  still retaining the benefits of having derived `Show` instances. This can be especially
  useful when working interactively in ghci. `pretty-display` provides a tiny registered
  package with the `Display` typeclass for just this purpose.\n\n## GHCi usage\n\nTo
  use `Display` instances as the default in ghci create a `.ghci` file with the following:\n\n```\nimport
  Text.Display\n\n:set -interactive-print=Text.Display.dPrint\n:def pp (\\_ -> return
  \":set -interactive-print=Text.Display.dPrint\")\n:def npp (\\_ -> return \":set
  -interactive-print=print\")\n```\n\n<img src=\"https://cloud.githubusercontent.com/assets/197051/20393285/4d04a098-aca9-11e6-85ea-a025c5e752f1.png\"
  alt=\"ghci example\" width=\"638\" height=\"213\" />\n\n## Typeclass usage\n\nBy
  default, all instances of `Show` are also instances of `Display`. To create a custom
  instance you will need to use the `OVERLAPPING` pragma, and define the `display`
  method of type `a -> DisplayText`. For example:\n\n```\nimport Numeric\n\nimport
  Text.Display\nimport Text.PrettyPrint.ANSI.Leijen as PP\n\ndata MyRecord = MyRecord\n
  \ { numerators :: [Double]\n  , denominator :: Double\n  } deriving (Show)\n\nrecord
  :: MyRecord\nrecord = MyRecord\n  { numerators = [0, 5..100]\n  , denominator =
  1326\n  }\n\ninstance {-# OVERLAPPING #-} Display MyRecord where\n  display a =
  mkDisplayTextFromStr\n      $ show\n      $ toCol \"MyRecord (percentage): \" <>
  toCol (displayPerc a)\n    where\n      displayPerc a = showFFloat (Just 2) (toPerc
  a) \"%\"\n      toPerc a = sum (numerators a) / denominator a * 100\n      toCol
  a = (PP.dullgreen . PP.fill 25 . PP.text) a\n\nmain :: IO ()\nmain = do\n  dPrint
  record\n  pPrint record\n```\n\n## Using `Show` when defaulting to `Display`\n\nIf
  you've set ghci to use `dPrint` by default you can still print `Show` instances
  for debugging. For normal printing use `print`. For convenience `pretty-display`
  re-exports `pPrint` from the `pretty-show` package for pretty printing `Show` instances.\n"
license-name: BSD3
