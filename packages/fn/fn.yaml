homepage: http://github.com/dbp/fn#readme
changelog-type: markdown
hash: d70e9a642b88558a969935b49724da6b813fbc2ff7d3982bb1f617eb66972dca
test-bench-deps:
  wai: -any
  base: -any
  hspec: -any
  text: -any
  fn: -any
  http-types: -any
maintainer: dbp@dbpmail.net
synopsis: A functional web framework.
changelog: ! "* 0.1.0.0 Daniel Patterson <dbp@dbpmail.net> 2015-10-25\n\n  Initial
  release.\n"
basic-deps:
  bytestring: -any
  wai: -any
  base: ! '>=4.7 && <5'
  text: -any
  blaze-builder: -any
  http-types: -any
all-versions:
- '0.1.0.0'
author: Daniel Patterson <dbp@dbpmail.net>
latest: '0.1.0.0'
description-type: markdown
description: ! "## Fn (eff-enn) - a functional web framework.\n\n> Or, how to do away
  with the monad transformers, and just use plain\n> functions.\n\n## Example\n\nSee
  the example application in the repository for a full usage, but a minimal application
  is the following:\n\n```\n\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell
  \  #-}\n\nimport           Control.Lens\nimport           Data.Monoid\nimport           Data.Text
  \               (Text)\nimport qualified Data.Text                as T\nimport           Network.HTTP.Types\nimport
  \          Network.Wai\nimport           Network.Wai.Handler.Warp\nimport qualified
  Network.Wai.Util         as W\nimport           Web.Fn\n\ndata Ctxt = Ctxt { _req
  :: Request\n                 }\n\nmakeLenses ''Ctxt\n\ninstance RequestContext Ctxt
  where\n  requestLens = req\n\ninitializer :: IO Ctxt\ninitializer = return (Ctxt
  defaultRequest)\n\nmain :: IO ()\nmain = do context <- initializer\n          run
  8000 $ toWAI context app\n\napp :: Ctxt -> IO Response\napp ctxt =\n  route ctxt
  [ end ==> index\n             , path \"foo\" // segment // path \"baz\" /? param
  \"id\" ==> handler]\n    `fallthrough` notFoundText \"Page not found.\"\n\nindex
  :: IO (Maybe Response)\nindex = okText \"This is the index page! Try /foo/bar/baz?id=10\"\n\nhandler
  :: Ctxt -> Text -> Int -> IO (Maybe Response)\nhandler _ fragment i = okText (fragment
  <> \" - \" <> T.pack (show i))\n\n```\n\n## Recommended Pairings\n\nPart of the
  design of `Fn` is that you won't need a suite of `fn-foo`\nlibraries that generally
  serve to adapt the functions from `foo` to\nthe monad transformer stack of the web
  framework of choice (we may add\nan `fn-extra` package with a few helpers in it
  in the future, but it'll\nbe small). Still, it's helpful to know what are common
  tools that are\nwell designed and tested, so here are a list (those marked with
  `[*]`\nare used in the example application included in the repository):\n\n- [warp](http://hackage.haskell.org/package/warp)`[*]`:
  perhaps obvious,\n  but you will need to choose an HTTP server to use with your
  `Fn`\n  application, and `warp` is the defacto standard for applications that\n
  \ use the `WAI` interface that `Fn` does.\n- [heist](http://hackage.haskell.org/package/heist)`[*]`:
  a wonderful\n  templating system that is both really simple (the templates are just\n
  \ html) and powerful (any html tag can be bound to run haskell\n  code). This may
  be the one place where we may add some adaptors, as\n  it would be wonderful to
  have splices (those haskell-bound html\n  tags) that were normal functions, rather
  than monadic.\n- [postgresql-simple](https://hackage.haskell.org/package/postgresql-simple)`[*]`:\n
  \ a well designed interface to PostgreSQL; ofter the lower level way\n  to interact
  with the database (setting up connections, etc), if you\n  use a higher level, safer
  abstraction like `opaleye` (below) for actual\n  queries. Use it with\n  [resource-pool](https://hackage.haskell.org/package/resource-pool)`[*]`\n
  \ to have it manage many connections.\n- [opaleye](https://hackage.haskell.org/package/opaleye):
  a type-safe\n  composable way to write database queries against PostgreSQL.\n- [hedis](https://hackage.haskell.org/package/hedis)`[*]`:
  a full-featured\n  client for the key-value store Redis.\n- [logging](https://hackage.haskell.org/package/logging)`[*]`:
  a simple\n  library for writing log messages, which allow you to change the\n  logging
  level and suppress some subset of messages.\n- [hspec](https://hackage.haskell.org/package/hspec)`[*]`:
  a\n  full-featured testing framework. Use with\n  [hspec-wai](https://hackage.haskell.org/package/hspec-wai)`[*]`
  -\n  though the latter could use some work to make it do everything it\n  needs
  to!\n- [wai-session](https://hackage.haskell.org/package/wai-session)`[*]`:\n  Combine
  with something like\n  [wai-session-clientsession](https://hackage.haskell.org/package/wai-session-clientsession)`[*]`\n
  \ to store session data in encrypted cookies (like, who a user is\n  logged in as).\n"
license-name: ISC
