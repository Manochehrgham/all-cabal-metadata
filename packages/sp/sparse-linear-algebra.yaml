homepage: https://github.com/ocramz/sparse-linear-algebra
changelog-type: ''
hash: 8d9e568a3c84fcacf6d742c4ea0073c8fa1e5921262688533402c71593c7210e
test-bench-deps:
  mwc-random: -any
  base: -any
  hspec: -any
  criterion: -any
  containers: -any
  mtl: ! '>=2.2.1'
  sparse-linear-algebra: -any
  primitive: ! '>=0.6.1.0'
maintainer: zocca.marco gmail
synopsis: Numerical computation in native Haskell
changelog: ''
basic-deps:
  mwc-random: -any
  base: ! '>=4.7 && <5'
  hspec: -any
  containers: -any
  mtl: ! '>=2.2.1'
  QuickCheck: -any
  primitive: ! '>=0.6.1.0'
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.1.0.2'
- '0.1.0.3'
- '0.2.0.0'
- '0.2.0.1'
- '0.2.0.2'
- '0.2.0.3'
- '0.2.0.4'
- '0.2.0.5'
- '0.2.0.7'
- '0.2.0.8'
author: Marco Zocca
latest: '0.2.0.8'
description-type: markdown
description: ! "# sparse-linear-algebra\n\nNumerical computation in native Haskell\n\nTravisCI
  : [![Build Status](https://travis-ci.org/ocramz/sparse-linear-algebra.png)](https://travis-ci.org/ocramz/sparse-linear-algebra)\n\nThis
  library provides common numerical analysis functionality, without requiring any
  external bindings. It is not optimized for performance (yet), but it serves as an
  experimental platform for scientific computation in a purely functional setting.\n\nAlgorithms
  :\n\n* Iterative linear solvers\n\n    * BiConjugate Gradient (BCG)\n\n    * Conjugate
  Gradient Squared (CGS)\n\n    * BiConjugate Gradient Stabilized (BiCGSTAB) (non-Hermitian
  systems)\n\n    * Transpose-Free Quasi-Minimal Residual (TFQMR)\n\n* Matrix decompositions\n\n
  \   * QR factorization\n\n    * LU factorization\n\n* Eigenvalue algorithms\n\n
  \   * QR algorithm\n\n    * Rayleigh quotient iteration\n\n* Utilities : Vector
  and matrix norms, matrix condition number, Givens rotation, Householder reflection\n\n*
  Predicates : Matrix orthogonality test (A^T A ~= I)\n\n\n---------\n\n## Examples\n\nThe
  module `Numeric.LinearAlgebra.Sparse` contains the user interface.\n\n### Creation
  and pretty-printing\n\nTo create a sparse matrix from an array of its entries we
  use `fromListSM` :\n\n    fromListSM :: Foldable t => (Int, Int) -> t (IxRow, IxCol,
  a) -> SpMatrix a\n\ne.g.\n\n    > amat = fromListSM (3,3) [(0,0,2),(1,0,4),(1,1,3),(1,2,2),(2,2,5)]\n\nAnd
  similarly for sparse vectors : `fromListSV :: Int -> [(Int, a)] -> SpVector a`.\n\nBoth
  sparse vectors and matrices can be pretty-printed using `prd`:\n\n    > prd amat\n
  \   ( 3 rows, 3 columns ) , 5 NZ ( sparsity 0.5555555555555556 )\n\n    [2,0,0]\n
  \   [4,3,2]\n    [0,0,5]\n\nThe zeros are just added at pretty printing time; sparse
  vectors and matrices should only contain non-zero entries.\n\n### Matrix operations\n\nMatrix
  factorizations are available as `lu` and `qr` respectively, and are straightforward
  to verify by using the matrix product `##`  :\n\n    > (l, u) = lu amat\n    > prd
  $ l ## u\n    ( 3 rows, 3 columns ) , 9 NZ ( sparsity 1.0 )\n\n    [2.0,0.0,0.0]\n
  \   [4.0,3.0,2.0]\n    [0.0,0.0,5.0]\n\nNotice that the result is _dense_, i.e.
  certain entries are numerically zero but have been inserted into the result along
  with all the others (thus taking up memory!).\nTo preserve sparsity, we can use
  a sparsifying matrix-matrix product `#~#`, which filters out all the elements x
  for which `|x| <= eps`, where `eps` (defined) in `Numeric.Eps`, is fixed at 10^-8.\n\n
  \   > prd $ l #~# u\n    ( 3 rows, 3 columns ) , 5 NZ ( sparsity 0.5555555555555556
  )\n\n    [2.0,0.0,0.0]\n    [4.0,3.0,2.0]\n    [0.0,0.0,5.0]\n\n\n### Linear systems\n\nLinear
  systems can be solved with either `linSolve` (which also requires choosing a method)
  or with `<\\>` (which uses BiCGSTAB as default) :\n\n    > b = fromListSV 3 [(0,3),(1,2),(2,5)]\n
  \   > x = amat <\\> b\n    > prd x\n    ( 3 elements ) ,  3 NZ ( sparsity 1.0 )\n\n
  \   [1.4999999999999998,-1.9999999999999998,0.9999999999999998]\n\nThe result can
  be verified by computing the matrix-vector action `amat #> x`, which should (ideally)
  be very close to the right-hand side `b` :\n\n    > prd $ amat #> x\n    ( 3 elements
  ) ,  3 NZ ( sparsity 1.0 )\n\n    [2.9999999999999996,1.9999999999999996,4.999999999999999]\n\n\n\n\n----------\n\nThis
  is also an experiment in principled scientific programming :\n\n* set the stage
  by declaring typeclasses and some useful generic operations (normed linear vector
  spaces, i.e. finite-dimensional spaces equipped with an inner product that induces
  a distance function),\n\n* define appropriate data structures, and how they relate
  to those properties (sparse vectors and matrices, defined internally via `Data.IntMap`,
  are made instances of the VectorSpace and Additive classes respectively). This allows
  to decouple the algorithms from the actual implementation of the backend,\n\n* implement
  the algorithms, following 1:1 the textbook [1] \n\n\n## License\n\nGPL3, see LICENSE\n\n##
  Credits\n\nInspired by\n\n* `linear` : https://hackage.haskell.org/package/linear\n*
  `sparse-lin-alg` : https://github.com/laughedelic/sparse-lin-alg\n\n## References\n\n[1]
  : Y. Saad, Iterative Methods for Sparse Linear Systems, 2nd ed., 2000"
license-name: GPL-3
