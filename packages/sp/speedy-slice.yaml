homepage: http://github.com/jtobin/speedy-slice
changelog-type: ''
hash: 705eb190a4a019f9786f0becfe4ba5dfd7258503eed399fcb9c13c35bac5401e
test-bench-deps:
  base: <5
  containers: -any
  speedy-slice: -any
  mwc-probability: ! '>=1.0.1'
maintainer: jared@jtobin.ca
synopsis: Speedy slice sampling.
changelog: ''
basic-deps:
  base: <5
  mcmc-types: ! '>=1.0.1'
  lens: ! '>=4 && <5'
  pipes: ! '>=4 && <5'
  transformers: -any
  mwc-probability: ! '>=1.0.1'
  primitive: -any
all-versions:
- '0.1.0.0'
- '0.1.1'
- '0.1.2'
- '0.1.3'
author: Jared Tobin
latest: '0.1.3'
description-type: haddock
description: ! 'Speedy slice sampling.


  This implementation of the slice sampling algorithm uses ''lens'' as a means to

  operate over generic indexed traversable functors, so you can expect it to

  work if your target function takes a list, vector, map, sequence, etc. as its

  argument.


  Additionally you can sample over anything that''s an instance of both ''Num'' and

  ''Variate'', which is useful in the case of discrete parameters.


  Exports a ''mcmc'' function that prints a trace to stdout, as well as a

  ''slice'' transition operator that can be used more generally.


  > import Numeric.MCMC.Slice

  > import Data.Sequence (Seq, index, fromList)

  >

  > bnn :: Seq Double -> Double

  > bnn xs = -0.5 * (x0 ^ 2 * x1 ^ 2 + x0 ^ 2 + x1 ^ 2 - 8 * x0 - 8 * x1) where

  >   x0 = index xs 0

  >   x1 = index xs 1

  >

  > main :: IO ()

  > main = withSystemRandom . asGenIO $ mcmc 10000 1 (fromList [0, 0]) bnn'
license-name: MIT
