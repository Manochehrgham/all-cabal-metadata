homepage: http://github.com/jtobin/speedy-slice
changelog-type: ''
hash: a2edf8d42e0961d816f03e4cee71ca0d606ee148eb3f1d8345e2659c3ba412db
test-bench-deps:
  base: <5
  containers: -any
  speedy-slice: -any
  mwc-probability: ! '>=1.0.1'
maintainer: jared@jtobin.ca
synopsis: Speedy slice sampling.
changelog: ''
basic-deps:
  base: <5
  mcmc-types: ! '>=1.0.1'
  lens: -any
  pipes: -any
  ghc-prim: -any
  transformers: -any
  mwc-probability: ! '>=1.0.1'
  primitive: -any
all-versions:
- '0.1.0.0'
author: Jared Tobin
latest: '0.1.0.0'
description-type: haddock
description: ! 'Speedy slice sampling.


  This implementation of the slice sampling algorithm uses ''lens'' as a means to

  operate over generic indexed traversable functors, so you can expect it to

  work if your target function takes a list, vector, map, sequence, etc. as its

  argument.


  Exports a ''mcmc'' function that prints a trace to stdout, as well as a

  ''slice'' transition operator that can be used more generally.


  > import Numeric.MCMC.Slice

  > import Data.Sequence (Seq, index, fromList)

  >

  > bnn :: Seq Double -> Double

  > bnn xs = -0.5 * (x0 ^ 2 * x1 ^ 2 + x0 ^ 2 + x1 ^ 2 - 8 * x0 - 8 * x1) where

  >   x0 = index xs 0

  >   x1 = index xs 1

  >

  > main :: IO ()

  > main = withSystemRandom . asGenIO $ mcmc 10000 1 (fromList [0, 0]) bnn'
license-name: MIT
