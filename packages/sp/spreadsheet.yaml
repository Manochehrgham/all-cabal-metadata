changelog-type: ''
hash: fd3ad9a1f023ce0ce029fe38680d0425cc50ace1e4d7285f11dc85537f3f6b6b
test-bench-deps: {}
synopsis: Read and write spreadsheets from and to CSV files in a lazy way
changelog: ''
basic-deps:
  explicit-exception: ! '>=0.1 && <0.2'
  base: ! '>=2 && <5'
  utility-ht: ! '>=0.0.2 && <0.1'
  transformers: ! '>=0.2 && <0.5'
all-versions:
- '0.1'
- '0.1.1'
- '0.1.1.1'
- '0.1.2'
- '0.1.2.1'
- '0.1.3'
- '0.1.3.1'
- '0.1.3.2'
- '0.1.3.3'
latest: '0.1.3.3'
description-type: haddock
description: ! 'Read and write spreadsheets from and to files

  containing comma separated values (CSV) in a lazy way.

  See also the

  csv package <http://hackage.haskell.org/package/csv> and

  <http://www.xoltar.org/languages/haskell.html>,

  <http://www.xoltar.org/languages/haskell/CSV.hs>.

  Both do not parse lazy.

  Reading from other source than plain ''String''s could be easily added.


  If you install this package by


  cabal install -fbuildExamples


  then an example program is compiled and installed, too.

  This program fills a template text using data from a CSV file.

  E.g. given a file @template.txt@ with content


  > Name: FIRSTNAME SURNAME

  > Born: BIRTH


  and @names.csv@ with content


  > "FIRSTNAME","SURNAME",BIRTH

  > "Georg","Cantor",1845

  > "Haskell","Curry",1900

  > "Ada","Lovelace",1815


  the call


  > csvreplace template.txt <names.csv


  produces the output


  > Name: Georg Cantor

  > Born: 1845

  > Name: Haskell Curry

  > Born: 1900

  > Name: Ada Lovelace

  > Born: 1815


  You may also generate one file per CSV row in the following manner:


  > csvreplace --multifile=FIRSTNAME-SURNAME.txt template.txt <names.csv


  For similar (non-Haskell) programs see @cut@, @csvfix@, @csvtool@.'
