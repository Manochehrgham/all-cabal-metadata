homepage: https://github.com/trskop/endo
changelog-type: markdown
hash: 3a812a2de04db8df3f7b5e82e9351d6e207f3573798dc1fe17d7c69e6d3cd41f
test-bench-deps: {}
maintainer: peter.trsko@gmail.com
synopsis: Endomorphism utilities.
changelog: ! "# ChangeLog / ReleaseNotes\n\n\n## Version 0.2.0.1\n\n* API documentation
  ehancements and clarifications.\n* Explicit implementation of `aDualEndo` for\n
  \ `instance AnEndo a => AnEndo (Maybe a)`.\n* Uploaded to [Hackage][]: <http://hackage.haskell.org/package/endo-0.2.0.1>\n\n\n##
  Version 0.2.0.0\n\n* Default implementation for `anEndo` method of 'AnEndo' type
  class, which is\n  now defined as: `anEndo = getDual . aDualEndo`. As a consequence
  it is now\n  possible to define complete instances of `AnEndo` by providing either\n
  \ `anEndo` or `aDualEndo`. (new, change)\n* Introducing associated type `Result`
  to `FoldEndoArgs` type class. This\n  allows result of the whole folding to be explicitly
  stated in a type\n  signature. (new, change)\n* Introducing functions `embedEndoWith`
  and `embedDualEndoWith`. Both can be\n  used to simplify application of endomorphisms
  that are result of folding.\n  (new)\n    - `embedEndoWith :: (AnEndo e, EndoOperatesOn
  e ~ a) => (Endo a -> b) -> e\n      -> b`\n    - `embedDualEndoWith :: (AnEndo e,
  EndoOperatesOn e ~ a) => (Dual (Endo a)\n      -> b) -> e -> b`\n* Introducing `instance
  AnEndo (Proxy a)`, which is useful in cases when one\n  needs to force constraint
  `EndoOperatesOn args ~ a` where `a` is the `a` from\n  `Proxy a`. This is done by
  encoding value of `Proxy` in to identity\n  endomorphism that operates on specified
  type `a`. (new)\n* Introducing `instance (Monoid c, FoldEndoArgs r) => FoldEndoArgs
  (Const c\n  r)`, which is useful in cases when one needs to discard the computation
  and\n  return a constant instead. (new)\n* Bumping upper bounds on base and between,
  therefore it now builds on GHC 7.10\n  with base 4.8. (new)\n* Uploaded to [Hackage][]:
  <http://hackage.haskell.org/package/endo-0.2.0.0>\n\n\n## Version 0.1.0.2\n\n* Bugfix
  release.\n* Bugfix: Unable to compile with transformers >= 0.4 (again).\n* Minor
  documentation updates.\n* Uploaded to [Hackage][]: <http://hackage.haskell.org/package/endo-0.1.0.2>\n\n\n##
  Version 0.1.0.1\n\n* Bugfix release.\n* Bugfix: Unable to compile with transformers
  >= 0.4.\n* Uploaded to [Hackage][]: <http://hackage.haskell.org/package/endo-0.1.0.1>\n\n\n##
  Version 0.1.0.0\n\n* **This version doesn't work with transformers >= 0.4.**\n*
  First public release.\n* Uploaded to [Hackage][]: <http://hackage.haskell.org/package/endo-0.1.0.0>\n\n\n\n[Hackage]:\n
  \ http://hackage.haskell.org/\n  \"HackageDB (or just Hackage) is a collection of
  releases of Haskell packages.\"\n\n<!--\n  vim: filetype=markdown softtabstop=4
  shiftwidth=4 expandtab\n-->\n"
basic-deps:
  base: ! '>=4.6 && <4.9'
  between: ! '>=0.9 && <0.11'
  transformers: ! '>=0.3 && <0.5'
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.1.0.2'
- '0.2.0.0'
- '0.2.0.1'
author: Peter TrÅ¡ko
latest: '0.2.0.1'
description-type: markdown
description: ! "# Endo\n\n[![Hackage](http://img.shields.io/hackage/v/endo.svg)][Hackage:
  endo]\n[![Hackage Dependencies](https://img.shields.io/hackage-deps/v/endo.svg)](http://packdeps.haskellers.com/reverse/endo)\n[![Haskell
  Programming Language](https://img.shields.io/badge/language-Haskell-blue.svg)][Haskell.org]\n[![BSD3
  License](http://img.shields.io/badge/license-BSD3-brightgreen.svg)][tl;dr Legal:
  BSD3]\n\n[![Build](https://travis-ci.org/trskop/endo.svg)](https://travis-ci.org/trskop/endo)\n\n\n##
  Description\n\nEndomorphism utilities.\n\n\n## Usage Examples\n\nLets define simple
  application `Config` data type as:\n\n````Haskell\ndata Verbosity = Silent | Normal
  | Verbose | Annoying\n  deriving (Show)\n\ndata Config = Config\n    { _verbosity
  :: Verbosity\n    , _outputFile :: FilePath\n    }\n  deriving (Show)\n````\n\nNow
  lets define setters for `_verbosity` and `_outputFile`:\n\n````Haskell\nsetVerbosity
  :: Verbosity -> E Config\nsetVerbosity b cfg = cfg{_verbosity = b}\n\nsetOutputFile
  :: FilePath -> E Config\nsetOutputFile b cfg = cfg{_outputFile = b}\n````\n\nNote
  that E is defined in `Data.Monoid.Endo` module and it looks like:\n\n````Haskell\ntype
  E a = a -> a\n````\n\nIts purpose is to simplify type signatures.\n\nNow lets get
  to our first example:\n\n````Haskell\nexample1 :: E Config\nexample1 = appEndo $
  foldEndo\n    &$ setVerbosity Annoying\n    &$ setOutputFile \"an.out.put\"\n````\n\nAbove
  example shows us that it is possible to modify `Config` as if it was a\nmonoid,
  but without actually having to state it as such. In practice it is\nnot always possible
  to define it as `Monoid` or at least a `Semigroup`. What\nusually works are endomorphisms,
  like in this example.\n\nNow, `FilePath` has one pathological case, and that is
  `\"\"`. There is a lot of\nways to handle it. Here we will concentrate only few
  basic techniques to\nillustrate versatility of our approach.\n\n````Haskell\n--
  | Trying to set output file to \\\"\\\" will result in keeping original value.\nsetOutputFile2
  :: FilePath -> E Config\nsetOutputFile2 \"\" = id\nsetOutputFile2 fp = setOutputFile
  fp\n\nexample2 :: E Config\nexample2 = appEndo $ foldEndo\n    &$ setVerbosity Annoying\n
  \   &$ setOutputFile2 \"an.out.put\"\n````\n\nSame as above, but exploits `instance
  AnEndo a => AnEndo Maybe a`:\n\n````Haskell\nsetOutputFile3 :: FilePath -> Maybe
  (E Config)\nsetOutputFile3 \"\" = Nothing\nsetOutputFile3 fp = Just $ setOutputFile
  fp\n\nexample3 :: E Config\nexample3 = appEndo $ foldEndo\n    &$ setVerbosity Annoying\n
  \   &$ setOutputFile3 \"an.out.put\"\n````\n\nFollowing example uses common pattern
  of using `Either` as error reporting\nmonad. This approach can be easily modified
  for arbitrary error reporting\nmonad.\n\n````Haskell\nsetOutputFile4 :: FilePath
  -> Either String (E Config)\nsetOutputFile4 \"\" = Left \"Output file: Empty file
  path.\"\nsetOutputFile4 fp = Right $ setOutputFile fp\n\nexample4 :: Either String
  (E Config)\nexample4 = appEndo <&$> foldEndo\n    <*> pure (setVerbosity Annoying)\n
  \   <*> setOutputFile4 \"an.out.put\"\n````\n\nNotice, that above example uses applicative
  style. Normally when using this\nstyle, for setting record values, one needs to
  keep in sync order of\nconstructor arguments and order of operations. Using `foldEndo`
  (and its\ndual `dualFoldEndo`) doesn't have this restriction.\n\nInstead of setter
  functions one may want to use lenses (in terms of\n[lens package][Hackage: lens]):\n\n````Haskell\nverbosity
  :: Lens' Config Verbosity\nverbosity = _verbosity ~@@^> \\s b -> s{_verbosity =
  b}\n\noutputFile :: Lens' Config FilePath\noutputFile = _outputFile ~@@^> \\s b
  -> s{_outputFile = b}\n````\n\nNow setting values of `Config` would look like:\n\n````Haskell\nexample5
  :: E Config\nexample5 = appEndo $ foldEndo\n    &$ verbosity  .~ Annoying\n    &$
  outputFile .~ \"an.out.put\"\n````\n\nProbably one of the most interesting things
  that can be done with this\nmodule is following:\n\n````Haskell\ninstance AnEndo
  Verbosity where\n    type EndoOperatesOn Verbosity = Config\n    anEndo = Endo .
  set verbosity\n\nnewtype OutputFile = OutputFile FilePath\n\ninstance AnEndo OutputFile
  where\n    type EndoOperatesOn OutputFile = Config\n    anEndo (OutputFile fp) =
  Endo $ outputFile .~ fp\n\nexample6 :: E Config\nexample6 = appEndo $ foldEndo\n
  \   &$ Annoying\n    &$ OutputFile \"an.out.put\"\n````\n\n\n### Using with optparse-applicative\n\nThis
  is a more complex example that defines parser for\n[optparse-applicative][Hackage:
  optparse-applicative] built on top of some of\nthe above definitions:\n\n````Haskell\noptions
  :: Parser Config\noptions = runIdentityT $ runEndo defaultConfig <$> options'\n
  \ where\n    -- All this IdentityT clutter is here to avoid orphan instances.\n
  \   options' :: IdentityT Parser (Endo Config)\n    options' = foldEndo\n        <*>
  outputOption     -- :: IdentityT Parser (Maybe (E Config))\n        <*> verbosityOption
  \ -- :: IdentityT Parser (Maybe (E Config))\n        <*> annoyingFlag     -- ::
  IdentityT Parser (E Config)\n        <*> silentFlag       -- :: IdentityT Parser
  (E Config)\n        <*> verboseFlag      -- :: IdentityT Parser (E Config)\n\n    defaultConfig
  :: Config\n    defaultConfig = Config Normal \"\"\n\n-- >>> :main -o an.out.put
  --annoying\n-- Config {_verbosity = Annoying, _outputFile = \"an.out.put\"}\nmain
  :: IO ()\nmain = execParser (info options fullDesc) >>= print\n````\n\nParsers for
  individual options and flags are wrapped in `IdentityT`, because\nthere is no following
  instance:\n\n````Haskell\ninstance FoldEndoArgs r => FoldEndoArgs (Parser r)\n````\n\nBut
  there is:\n\n````Haskell\ninstance (Applicative f, FoldEndoArgs r) => FoldEndoArgs
  (IdentityT f r)\n````\n\nFunctions used by the above code example:\n\n````Haskell\noutputOption
  :: IdentityT Parser (Maybe (E Config))\noutputOption =\n    IdentityT . optional
  . option (set outputFile <$> parseFilePath)\n    $ short 'o' <> long \"output\"
  <> metavar \"FILE\"\n        <> help \"Store output in to a FILE.\"\n  where\n    parseFilePath
  = eitherReader $ \\s ->\n        if null s\n            then Left \"Option argument
  can not be empty file path.\"\n            else Right s\n\nverbosityOption :: IdentityT
  Parser (Maybe (E Config))\nverbosityOption =\n    IdentityT . optional . option
  (set verbosity <$> parseVerbosity)\n    $ long \"verbosity\" <> metavar \"LEVEL\"
  <> help \"Set verbosity to LEVEL.\"\n  where\n    verbosityToStr = map toLower .
  Data.showConstr . Data.toConstr\n    verbosityIntValues = [(show $ fromEnum v, v)
  | v <- [Silent .. Annoying]]\n    verbosityStrValues =\n        (\"default\", Normal)
  : [(verbosityToStr v, v) | v <- [Silent .. Annoying]]\n\n    parseVerbosityError
  = unwords\n        [ \"Verbosity can be only number from interval\"\n        , show
  $ map fromEnum [minBound, maxBound :: Verbosity]\n        , \"or one of the following:\"\n
  \       , concat . intersperse \", \" $ map fst verbosityStrValues\n        ]\n\n
  \   parseVerbosity = eitherReader $ \\s ->\n        case lookup s $ verbosityIntValues
  ++ verbosityStrValues of\n            Just v  -> Right v\n            Nothing ->
  Left parseVerbosityError\n\nannoyingFlag :: IdentityT Parser (E Config)\nannoyingFlag
  = IdentityT . flag id (verbosity .~ Annoying)\n    $ long \"annoying\" <> help \"Set
  verbosity to maximum.\"\n\nsilentFlag :: IdentityT Parser (E Config)\nsilentFlag
  = IdentityT . flag id (verbosity .~ Silent)\n    $ short 's' <> long \"silent\"
  <> help \"Set verbosity to minimum.\"\n\nverboseFlag :: IdentityT Parser (E Config)\nverboseFlag
  = IdentityT . flag id (verbosity .~ Verbose)\n    $ short 'v' <> long \"verbose\"
  <> help \"Be verbose.\"\n````\n\n\n## Building Options\n\n* `-fpedantic` (disabled
  by default)\n\n  Pass additional warning flags to GHC.\n\n\n## Contributions\n\nContributions,
  pull requests and bug reports are welcome! Please don't be\nafraid to contact author
  using GitHub or by e-mail.\n\n\n\n[Hackage: endo]:\n  http://hackage.haskell.org/package/endo\n
  \ \"endo package on Hackage\"\n[Hackage: lens]:\n  http://hackage.haskell.org/package/lens\n
  \ \"lens package on Hackage\"\n[Hackage: optparse-applicative]:\n  http://hackage.haskell.org/package/optparse-applicative\n
  \ \"optparse-applicative package on Hackage\"\n[Haskell.org]:\n  http://www.haskell.org\n
  \ \"The Haskell Programming Language\"\n[tl;dr Legal: BSD3]:\n  https://tldrlegal.com/license/bsd-3-clause-license-%28revised%29\n
  \ \"BSD 3-Clause License (Revised)\"\n"
license-name: BSD3
