changelog-type: markdown
hash: 13786b2468cba9ab9c62be4ab0d3759b953e51aff860d6ce244a9d195d7d18fa
test-bench-deps: {}
synopsis: Endomorphism utilities.
changelog: ! "# ChangeLog / ReleaseNotes\n\n\n## Version 0.1.0.2\n\n* Bugfix release.\n*
  Bugfix: Unable to compile with transformers >= 0.4 (again).\n* Minor documentation
  updates.\n* Uploaded to [Hackage][]\n  <http://hackage.haskell.org/package/endo-0.1.0.2>\n\n\n##
  Version 0.1.0.1\n\n* Bugfix release.\n* Bugfix: Unable to compile with transformers
  >= 0.4.\n* Uploaded to [Hackage][]:\n  <http://hackage.haskell.org/package/endo-0.1.0.1>\n\n\n##
  Version 0.1.0.0\n\n* **This version doesn't work with transformers >= 0.4.**\n*
  First public release.\n* Uploaded to [Hackage][]:\n  <http://hackage.haskell.org/package/endo-0.1.0.0>\n\n\n\n[Hackage]:\n
  \ http://hackage.haskell.org/\n  \"HackageDB (or just Hackage) is a collection of
  releases of Haskell packages.\"\n"
basic-deps:
  base: ! '>=4.6 && <4.8'
  between: ==0.9.*
  transformers: ! '>=0.3 && <0.5'
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.1.0.2'
latest: '0.1.0.2'
description-type: markdown
description: ! "# Endo\n\n[![Hackage](http://img.shields.io/hackage/v/endo.svg)][Hackage:
  endo]\n[![Haskell Programming Language](https://img.shields.io/badge/language-Haskell-blue.svg)][Haskell.org]\n[![BSD3
  License](http://img.shields.io/badge/license-BSD3-brightgreen.svg)][tl;dr Legal:
  BSD3]\n\n\n## Description\n\nEndomorphism utilities.\n\n\n## Usage Examples\n\nLets
  define simple application `Config` data type as:\n\n````Haskell\ndata Verbosity
  = Silent | Normal | Verbose | Annoying\n  deriving (Show)\n\ndata Config = Config\n
  \   { _verbosity :: Verbosity\n    , _outputFile :: FilePath\n    }\n  deriving
  (Show)\n````\n\nNow lets define setters for `_verbosity` and `_outputFile`:\n\n````Haskell\nsetVerbosity
  :: Verbosity -> E Config\nsetVerbosity b cfg = cfg{_verbosity = b}\n\nsetOutputFile
  :: FilePath -> E Config\nsetOutputFile b cfg = cfg{_outputFile = b}\n````\n\nNote
  that E is defined in `Data.Monoid.Endo` module and it looks like:\n\n````Haskell\ntype
  E a = a -> a\n````\n\nIts purpose is to simplify type signatures.\n\nNow lets get
  to our first example:\n\n````Haskell\nexample1 :: E Config\nexample1 = appEndo $
  foldEndo\n    &$ setVerbosity Annoying\n    &$ setOutputFile \"an.out.put\"\n````\n\nAbove
  example shows us that it is possible to modify `Config` as if it was a\nmonoid,
  but without actually having to state it as such. In practice it is\nnot always possible
  to define it as `Monoid` or at least a `Semigroup`. What\nusually works are endomorphisms,
  like in this example.\n\nNow, `FilePath` has one pathological case, and that is
  `\"\"`. There is a lot of\nways to handle it. Here we will concentrate only few
  basic techniques to\nillustrate versatility of our approach.\n\n````Haskell\n--
  | Trying to set output file to \\\"\\\" will result in keeping original value.\nsetOutputFile2
  :: FilePath -> E Config\nsetOutputFile2 \"\" = id\nsetOutputFile2 fp = setOutputFile
  fp\n\nexample2 :: E Config\nexample2 = appEndo $ foldEndo\n    &$ setVerbosity Annoying\n
  \   &$ setOutputFile2 \"an.out.put\"\n````\n\nSame as above, but exploits `instance
  AnEndo a => AnEndo Maybe a`:\n\n````Haskell\nsetOutputFile3 :: FilePath -> Maybe
  (E Config)\nsetOutputFile3 \"\" = Nothing\nsetOutputFile3 fp = Just $ setOutputFile
  fp\n\nexample3 :: E Config\nexample3 = appEndo $ foldEndo\n    &$ setVerbosity Annoying\n
  \   &$ setOutputFile3 \"an.out.put\"\n````\n\nFollowing example uses common pattern
  of using `Either` as error reporting\nmonad. This approach can be easily modified
  for arbitrary error reporting\nmonad.\n\n````Haskell\nsetOutputFile4 :: FilePath
  -> Either String (E Config)\nsetOutputFile4 \"\" = Left \"Output file: Empty file
  path.\"\nsetOutputFile4 fp = Right $ setOutputFile fp\n\nexample4 :: Either String
  (E Config)\nexample4 = appEndo <&$> foldEndo\n    <*> pure (setVerbosity Annoying)\n
  \   <*> setOutputFile4 \"an.out.put\"\n````\n\nNotice, that above example uses applicative
  style. Normally when using this\nstyle, for setting record values, one needs to
  keep in sync order of\nconstructor arguments and order of operations. Using `foldEndo`
  (and its\ndual `dualFoldEndo`) doesn't have this restriction.\n\nInstead of setter
  functions one may want to use lenses (in terms of\n[lens package][Hackage: lens]):\n\n````Haskell\nverbosity
  :: Lens' Config Verbosity\nverbosity = _verbosity ~@@^> \\s b -> s{_verbosity =
  b}\n\noutputFile :: Lens' Config FilePath\noutputFile = _outputFile ~@@^> \\s b
  -> s{_outputFile = b}\n````\n\nNow setting values of `Config` would look like:\n\n````Haskell\nexample5
  :: E Config\nexample5 = appEndo $ foldEndo\n    &$ verbosity  .~ Annoying\n    &$
  outputFile .~ \"an.out.put\"\n````\n\nProbably one of the most interesting things
  that can be done with this\nmodule is following:\n\n````Haskell\ninstance AnEndo
  Verbosity where\n    type EndoOperatesOn Verbosity = Config\n    anEndo = Endo .
  set verbosity\n\nnewtype OutputFile = OutputFile FilePath\n\ninstance AnEndo OutputFile
  where\n    type EndoOperatesOn OutputFile = Config\n    anEndo (OutputFile fp) =
  Endo $ outputFile .~ fp\n\nexample6 :: E Config\nexample6 = appEndo $ foldEndo\n
  \   &$ Annoying\n    &$ OutputFile \"an.out.put\"\n````\n\n\n### Using with optparse-applicative\n\nThis
  is a more complex example that defines parser for\n[optparse-applicative][Hackage:
  optparse-applicative] built on top of some of\nthe above definitions:\n\n````Haskell\noptions
  :: Parser Config\noptions = runIdentityT $ runEndo defaultConfig <$> options'\n
  \ where\n    options' :: IdentityT Parser (Endo Config)\n    options' = foldEndo\n
  \       <*> outputOption     -- :: IdentityT Parser (Maybe (E Config))\n        <*>
  verbosityOption  -- :: IdentityT Parser (Maybe (E Config))\n        <*> annoyingFlag
  \    -- :: IdentityT Parser (E Config)\n        <*> silentFlag       -- :: IdentityT
  Parser (E Config)\n        <*> verboseFlag      -- :: IdentityT Parser (E Config)\n\n
  \   defaultConfig :: Config\n    defaultConfig = Config Normal \"\"\n\n-- >>> :main
  -o an.out.put --annoying\n-- Config {_verbosity = Annoying, _outputFile = \"an.out.put\"}\nmain
  :: IO ()\nmain = execParser (info options fullDesc) >>= print\n````\n\nParsers for
  individual options and flags are wrapped in `IdentityT`, because\nthere is no following
  instance:\n\n````Haskell\ninstance FoldEndoArgs r => FoldEndoArgs (Parser r)\n````\n\nBut
  there is:\n\n````Haskell\ninstance (Applicative f, FoldEndoArgs r) => FoldEndoArgs
  (IdentityT f r)\n````\n\nFunctions used by the above code example:\n\n````Haskell\noutputOption
  :: IdentityT Parser (Maybe (E Config))\noutputOption =\n    IdentityT . optional
  . option (set outputFile <$> parseFilePath)\n    $ short 'o' <> long \"output\"
  <> metavar \"FILE\"\n        <> help \"Store output in to a FILE.\"\n  where\n    parseFilePath
  = eitherReader $ \\s ->\n        if null s\n            then Left \"Option argument
  can not be empty file path.\"\n            else Right s\n\nverbosityOption :: IdentityT
  Parser (Maybe (E Config))\nverbosityOption =\n    IdentityT . optional . option
  (set verbosity <$> parseVerbosity)\n    $ long \"verbosity\" <> metavar \"LEVEL\"
  <> help \"Set verbosity to LEVEL.\"\n  where\n    verbosityToStr = map toLower .
  Data.showConstr . Data.toConstr\n    verbosityIntValues = [(show $ fromEnum v, v)
  | v <- [Silent .. Annoying]]\n    verbosityStrValues =\n        (\"default\", Normal)
  : [(verbosityToStr v, v) | v <- [Silent .. Annoying]]\n\n    parseVerbosityError
  = unwords\n        [ \"Verbosity can be only number from interval\"\n        , show
  $ map fromEnum [minBound, maxBound :: Verbosity]\n        , \"or one of the following:\"\n
  \       , concat . intersperse \", \" $ map fst verbosityStrValues\n        ]\n\n
  \   parseVerbosity = eitherReader $ \\s ->\n        case lookup s $ verbosityIntValues
  ++ verbosityStrValues of\n            Just v  -> Right v\n            Nothing ->
  Left parseVerbosityError\n\nannoyingFlag :: IdentityT Parser (E Config)\nannoyingFlag
  = IdentityT . flag id (verbosity .~ Annoying)\n    $ long \"annoying\" <> help \"Set
  verbosity to maximum.\"\n\nsilentFlag :: IdentityT Parser (E Config)\nsilentFlag
  = IdentityT . flag id (verbosity .~ Silent)\n    $ short 's' <> long \"silent\"
  <> help \"Set verbosity to minimum.\"\n\nverboseFlag :: IdentityT Parser (E Config)\nverboseFlag
  = IdentityT . flag id (verbosity .~ Verbose)\n    $ short 'v' <> long \"verbose\"
  <> help \"Be verbose.\"\n````\n\n\n## Building Options\n\n* `-fpedantic` (disabled
  by default)\n\n  Pass additional warning flags to GHC.\n\n\n## Contributions\n\nContributions,
  pull requests and bug reports are welcome! Please don't be\nafraid to contact author
  using GitHub or by e-mail.\n\n\n\n[Hackage: endo]:\n  http://hackage.haskell.org/package/endo\n
  \ \"endo package on Hackage\"\n[Hackage: lens]:\n  http://hackage.haskell.org/package/lens\n
  \ \"lens package on Hackage\"\n[Hackage: optparse-applicative]:\n  http://hackage.haskell.org/package/optparse-applicative\n
  \ \"optparse-applicative package on Hackage\"\n[Haskell.org]:\n  http://www.haskell.org\n
  \ \"The Haskell Programming Language\"\n[tl;dr Legal: BSD3]:\n  https://tldrlegal.com/license/bsd-3-clause-license-%28revised%29\n
  \ \"BSD 3-Clause License (Revised)\"\n"
