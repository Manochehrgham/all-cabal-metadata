changelog-type: ''
hash: d55129a2f8379906cc801f8037816da86fe0f1b93a2f7343b8cf2d24996fc6dc
test-bench-deps: {}
synopsis: Write once concurrency primitives.
changelog: ''
basic-deps:
  base: ! '>=4 && <5'
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.2'
- '0.3'
latest: '0.3'
description-type: text
description: ! "What is this?\n-------------\n\nivar-simple provides immutable, write-once
  variables (IVars) in the\nData.IVar.Simple module.\n\nIt also provides two more
  experimental channel implementations built on\ntop of IVars,\n\n    Data.IVar.Simple.IChan:\n
  \       multi-cast channels with write-once semantics.\n\n    Data.IVar.Simple.MIChan:\n
  \       channels with write semantics similar to Control.Concurrent.Chan\n\nComparison
  to data-ivar\n-----------------------\n\nBoth data-ivar and ivar-simple provide
  a write-once variable. That's where\nthe similarities end:\n\n- Reading an IVar
  with data-ivar is an IO operation. In ivar-simple it's a\n  pure function.\n- data-ivar
  provides a 'Reader' monoid, monad, etc. for reading from one of\n  several IVars.
  ivar-simple has no such functionality.\n- The data-ivar implementation can, in principle,
  add arbitrary IO actions\n  that are called when an IVar is written. (This detail
  is not exposed,\n  however)\n- Technically, ivar-simple tries for efficiency by
  exploiting the existing\n  locking structures in the RTS; in particular, reading
  a full IVar for a\n  second time is as cheap as evaluating a record selector.\n
  \ I have no performance numbers for this.\n"
