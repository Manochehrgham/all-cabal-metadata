homepage: http://documentup.com/haskell-suite/haskell-names
changelog-type: markdown
hash: 3322c0f3372676f0e5a941f4693d389bb5eb723fc67151751eb0e8f1241c9311
test-bench-deps:
  traverse-with-class: -any
  bytestring: -any
  Cabal: -any
  filemanip: -any
  base: ! '>=4 && <5'
  tasty-golden: ! '>=2.2.1'
  hse-cpp: -any
  filepath: ! '>=1.1'
  uniplate: ! '>=1.5.1'
  tagged: -any
  containers: ! '>=0.2'
  haskell-src-exts: ! '>=1.9'
  utf8-string: -any
  mtl: -any
  haskell-names: -any
  haskell-packages: -any
  pretty-show: ! '>=1.6.1 && <1.7'
  tasty: -any
  aeson: -any
maintainer: Philipp Schuster
synopsis: Name resolution library for Haskell
changelog: ! "Changes\n=======\n\nVersion 0.5.2\n-------------\n\n* Handle more syntactic
  constructs\n\nVersion 0.5.1\n-------------\n\n* Resolve associated types\n* Resolve
  fixity declarations\n* Resolve classes and instances\n* Various bugfixes\n\nVersion
  0.5.0\n-------------\n\n* Unify type-level and value-level symbols\n* Remove fixities
  from symbol type\n* Properly annotate classes and instances\n* Inline original name
  into symbol type\n* Remove original package from symbol type\n* Annotate symbol
  references with the way they are referenced\n\nVersion 0.4.1\n-------------\n\n*
  Export types defined by top level data family declarations\n* Update to haskell-src-exts
  1.16\n\nVersion 0.4\n-----------\n\nReplace `data-lens` with `data-lens-light`\n\nVersion
  0.3.3.2\n---------------\n\nRemove the upper version bound on Cabal\n\nVersion 0.3.3.1\n---------------\n\nUpdate
  to work with haskell-src-exts 1.15\n\nVersion 0.3.3\n-------------\n\n* Expose `Language.Haskell.Names.ModuleSymbols.getTopDecls`\n*
  Define a `Monoid` instance for `LocalSymbolTable.Table`\n* Support for parallel
  list comprehensions\n\nVersion 0.3.2.8\n---------------\n\nIntroduce a lower dependency
  bound on `tasty-golden` in the test suite\n\nVersion 0.3.2.7\n---------------\n\n`type-eq`
  is fixed; depend on the new version\n\nVersion 0.3.2.6\n---------------\n\nWork
  around a regression in `type-eq`\n\nVersion 0.3.2.5\n---------------\n\nRelax `pretty-show`
  version bound\n\nVersion 0.3.2.4\n---------------\n\nMake haskell-names build GHC
  7.8\n\nVersion 0.3.2.3\n---------------\n\nInclude interfaces for `array`\n\nVersion
  0.3.2.2\n---------------\n\nAllow `pretty-show-1.6.2` in the test suite\n\nVersion
  0.3.2.1\n---------------\n\nUse `pretty-show-1.6.1` in the test suite\n\nVersion
  0.3.2\n-------------\n\n* Export `getDeclHead` from `Language.Haskell.Names.SyntaxUtils`\n*
  Annotate `QName`s in export lists\n* Update the bundled library interfaces (they
  were broken in earlier 0.3.*\n  versions because of the interface format change)\n\nVersion
  0.3.1\n-------------\n\n* Documentation improvements\n* Add `rfoldMap`\n* Relax
  Cabal dependency constraint to include Cabal-1.14\n\nVersion 0.3\n-----------\n\nThis
  release brings support for record puns and wildcards.\n\n### Interface file format
  changes\n\nFor field selectors, the new field `constructors` is added. It contains
  a list\nof constructors that contain that field.\n\n### API changes\n\n* The `sv_constructors`
  field is added to `SymSelector`\n* Add `Language.Haskell.Names.SyntaxUtils.stringToName`\n*
  The class `GetBound` is moved to a new module,\n  `Language.Haskell.Names.GetBound`.
  Its method, `getBound`, now has a new\n  argument, the global symbol table\n* `NameInfo`
  got two more constructors to annotate wildcards,\n  `RecPatWildcard` and `RecExpWildcard`\n*
  `Scope` now has a new field of type `WcNames`, which can be accessed\n  through
  the `wcNames` lens. This is needed for record wildcards\n  resolution.\n* Add field
  selectors to `GName`\n* Don't export `GName` and `OrigName` from `GlobalSymbolTable`\n\n\nVersion
  0.2.1\n-------------\n\n* Fix a bug where global symbols were annotated as local\n*
  Make the code compile with aeson-0.6.2.0\n\nVersion 0.2\n-------------\n\n* Proper
  annotations for types and binding sites. `NameContext` now has a few\n  new constructors.\n*
  Properly support n+k patterns\n* Expose the `Alg` datatype for open name resolution\n*
  Expose the `HasOrigName` class\n\nVersion 0.1.2\n-------------\n\nRestore compatibility
  with Cabal 1.16\n\nVersion 0.1.1\n-------------\n\nDummy release to force rebuild
  on hackage (now that haskell-src-exts 1.14 is\nreleased).\n"
basic-deps:
  traverse-with-class: -any
  bytestring: -any
  data-lens-light: -any
  Cabal: ! '>=1.14'
  base: ! '>=4 && <5'
  hse-cpp: -any
  filepath: ! '>=1.1'
  uniplate: ! '>=1.5.1'
  tagged: -any
  containers: ! '>=0.2'
  haskell-src-exts: ! '>=1.16'
  mtl: -any
  haskell-packages: ! '>=0.2'
  transformers: -any
  aeson: -any
  type-eq: ! '>=0.4.2'
all-versions:
- '0.1'
- '0.1.1'
- '0.1.2'
- '0.2'
- '0.2.1'
- '0.3'
- '0.3.1'
- '0.3.2'
- '0.3.2.1'
- '0.3.2.2'
- '0.3.2.3'
- '0.3.2.4'
- '0.3.2.5'
- '0.3.2.6'
- '0.3.2.7'
- '0.3.2.8'
- '0.3.3'
- '0.3.3.1'
- '0.3.3.2'
- '0.4'
- '0.4.1'
- '0.5.0'
- '0.5.1'
- '0.5.2'
- '0.5.3'
author: Philipp Schuster, Roman Cheplyaka, Lennart Augustsson
latest: '0.5.3'
description-type: markdown
description: ! "haskell-names\n=============\n\nhaskell-names does name and module
  resolution for haskell-src-exts AST.\n\nNamely, it can do the following:\n\n* for
  a module, compute its interface, i.e. the set of entities exported by the\n  module,
  together with their original names.\n* for each name in the module, figure out what
  it refers to — whether it's bound\n  locally (say, by a `where` clause) or globally
  (and then give its origin).\n\nInstallation\n------------\n\nTo install a released
  version:\n\n1. Install Cabal and cabal-install from [the git repository][cabal]
  (the\n   `master` branch)\n2. `cabal install haskell-names hs-gen-iface`\n\nIf you're
  building a development version, then you might also need to install\ndevelopment
  versions of [haskell-src-exts][hse], [haskell-packages][hp], and [hse-cpp][].\n\n[cabal]:
  https://github.com/haskell/cabal/\n[hse]: https://github.com/haskell-suite/haskell-src-exts\n[hp]:
  https://github.com/haskell-suite/haskell-packages\n[hse-cpp]: https://github.com/haskell-suite/hse-cpp\n\nModule
  interfaces\n-----------------\n\n`hs-gen-iface` is a «compiler» that generates interfaces
  for Haskell modules.\n\nAn interface is a JSON file that lists all entities (types,
  classes, functions\netc.) exported by every module. For example, here are a couple
  of entries from\n`Prelude.names`:\n\n``` json\n[\n  {\n    \"name\": \"map\",\n
  \   \"entity\": \"value\",\n    \"module\": \"GHC.Base\"\n  },\n  {\n    \"name\":
  \"IO\",\n    \"entity\": \"newtype\",\n    \"module\": \"GHC.Types\"\n  },\n  ...\n]\n```\n\nAs
  you see, each entity is annotated with the module where it was\noriginally defined.
  Additionally, class methods, field selectors, and data\nconstructors are annotated
  with the class or type they belong to.\n\n### Generating interfaces\n\nThanks to
  haskell-packages, `hs-gen-iface` is fully integrated with Cabal. To\nproduce and
  install interface files, pass `--haskell-suite -w hs-gen-iface` flags\nto `cabal
  install`, for instance\n\n    cabal install --haskell-suite -w hs-gen-iface mtl\n\nThis
  assumes that the `hs-gen-iface` executable is in your `PATH`. You can specify\nthe
  full path to `hs-gen-iface` after `-w`, too.\n\n#### Core packages\n\nhaskell-names
  comes with the global package database populated with some core\npackages:\n\n    %
  hs-gen-iface pkg list --global\n    array-0.4.0.2\n    base-4.7.0.0\n    integer-simple-0.1.1.0\n
  \   ghc-prim-0.3.1.0\n\n#### Compiling core packages by hand\n\nSuppose you need
  to compile any of the core packages by hand — for example, to\nget a different version
  than the one bundled with haskell-names.\n\nCore packages, such as `ghc-prim`, `integer-simple`,
  `array`, and `base`, are\nhighly GHC-specific and need to be tweaked a bit before
  they can be processed by\nhaskell-names. Get our modified versions:\n\n* [ghc-prim](https://github.com/haskell-suite/ghc-prim)\n*
  [array](https://github.com/haskell-suite/array)\n* [base](https://github.com/haskell-suite/base)\n*
  [integer-simple](https://github.com/haskell-suite/integer-simple)\n\nNote that Cabal's
  new dependency solver won't let you install `ghc-prim`\nor `base` easily. There
  are two ways to work around this:\n\n1. Use the old solver:\n\n        cabal install
  --haskell-suite -w hs-gen-iface --solver=topdown\n\n2. Invoke all the steps manually:\n\n
  \       cabal configure --haskell-suite -w hs-gen-iface\n        cabal build\n        cabal
  install --only\n\n### Using interfaces\n\nYou can parse interface files directly,
  but a better idea is to use\n`Distribution.HaskellSuite.Packages` API (from haskell-packages),
  combined with\nthe package database `NamesDB` defined in `Language.Haskell.Modules.Interfaces`.\n\nName
  resolution\n---------------\n\nThe `annotateModule` function annotates the module
  with scoping information.\n\nIts essence is described in the article [Open your
  name resolution][openrec].\n\n[openrec]: http://ro-che.info/articles/2013-03-04-open-name-resolution.html\n\n###
  Example\n\nLet's say you have a module and you want to find out whether it uses\n`Prelude.head`.\n\n```
  haskell\nmodule Main where\n\nimport Language.Haskell.Exts.Annotated\nimport qualified
  Language.Haskell.Exts as UnAnn (Name(Ident))\nimport Language.Haskell.Names\nimport
  Language.Haskell.Names.Interfaces\nimport Distribution.HaskellSuite\nimport Distribution.Simple.Compiler\n\nimport
  Data.Maybe\nimport Data.List\nimport Data.Proxy\nimport qualified Data.Foldable
  as Foldable\nimport Text.Printf\nimport Control.Applicative\nimport Control.Monad\n\nmain
  :: IO ()\nmain = do\n\n  -- read the program's source from stdin\n  source <- getContents\n\n
  \ let\n    -- parse the program (using haskell-src-exts)\n    ast = fromParseResult
  $\n      parseModuleWithMode defaultParseMode {parseFilename=\"stdin\"} source\n\n
  \ -- get all installed packages (user and global)\n  pkgs <-\n    (++) <$>\n      getInstalledPackages
  (Proxy :: Proxy NamesDB) UserPackageDB <*>\n      getInstalledPackages (Proxy ::
  Proxy NamesDB) GlobalPackageDB\n\n  headUsages <- evalNamesModuleT (findHeads ast)
  pkgs\n\n  forM_ headUsages $ \\loc ->\n    printf \"Prelude.head is used at %s\\n\"
  (prettyPrint $ srcInfoSpan loc)\n\n  when (null headUsages) $\n    printf \"Congratulations!
  Your code doesn't use Prelude.head\\n\"\n\n-- | The `findHeads` function finds all
  occurrences of the `head` symbol in\n-- a given AST of a Haskell module. It needs
  access to stored name information\n-- and therefore runs in `ModuleT`.\n    findHeads
  :: Module SrcSpanInfo -> ModuleT [Symbol] IO [SrcSpanInfo]\n    findHeads ast =
  do\n\n-- First we get all symbols exported from `Prelude` with `getModuleInfo`.\n
  \     symbols <- fromMaybe (error \"Prelude not found\") <$>\n        getModuleInfo
  \"Prelude\"\n\n-- Then we filter those for the one with name `\"head\"`.\n      let\n
  \       headSymbol =\n          fromMaybe (error \"Prelude.head not found\") (listToMaybe
  (do\n            symbol <- symbols\n            guard (symbolName symbol == UnAnn.Ident
  \"head\")\n            return symbol))\n\n-- We annotate the given ast.\n      annotatedAst
  <-\n        annotateModule\n          Haskell2010 -- base language\n          []
  \         -- set of extensions\n          ast\n\n-- We get a list of all annotations
  from the annotated module.\n      let\n        annotations = Foldable.toList annotatedAst\n\n--
  A `GlobalSymbol` annotation means that the annotated name refers to a\n-- global
  symbol. It also contains the qualified name that corresponds\n-- to how it is referenced
  but that is not needed here.\n        headUsages = nub (do\n          Scoped (GlobalSymbol
  globalSymbol _) location <- annotations\n          guard (globalSymbol == headSymbol)\n
  \         return location)\n\n-- And finally we return all found usages.\n     return
  headUsages\n\n```\n\n#### Example invocation\n\n\n    % ./find-heads \n    one =
  head [1]\n    ^D\n    Prelude.head is used at stdin: (1:7) - (1:11)\n\n    % ./find-heads\n
  \   import Prelude hiding (head)\n    import Data.Text\n\n    f = head (pack \"foo\")\n
  \   ^D\n    Congratulations! Your code doesn't use Prelude.head\n\n### API documentation\n\nSee
  [haskell-names haddock documentation][doc-index].\n\nThe two modules you need are:\n\n*
  [Language.Haskell.Names][] — exports the core functions and data types\n* [Language.Haskell.Names.Interfaces][]
  — lets you work with haskell-names interface files\n\nOther modules are more experimental,
  less documented, and you probably don't need\nthem anyway.\n\n[doc-index]: http://haskell-suite.github.io/docs/haskell-names/\n[Language.haskell.Names]:
  http://haskell-suite.github.io/docs/haskell-names/Language-Haskell-Names.html\n[Language.Haskell.Names.Interfaces]:
  http://haskell-suite.github.io/docs/haskell-names/Language-Haskell-Names-Interfaces.html\n\n###
  Known issues\n\nSee the [list of all issues][issues].\n\n* Because a non-trivial
  amount of packages are not designed to work with\n  anything except GHC, hs-gen-iface
  currently pretends to be GHC. This is of\n  course not acceptable — contributions
  here are welcome. ([#32][])\n* haskell-names doesn't perform validation yet. If
  a module is not valid\n  Haskell, then the behaviour is undefined. See the issues
  marked as\n  [validation][].\n* Symbol fixities are not recorded ([#1][])\n* Type
  variables are not resolved ([#2][])\n* Arrows are not fully supported ([#8][])\n\n[issues]:
  https://github.com/haskell-suite/haskell-names/issues/\n[#1]: https://github.com/haskell-suite/haskell-names/issues/1\n[#2]:
  https://github.com/haskell-suite/haskell-names/issues/2\n[#8]: https://github.com/haskell-suite/haskell-names/issues/8\n[#32]:
  https://github.com/haskell-suite/haskell-names/issues/32\n[validation]: https://github.com/haskell-suite/haskell-names/issues?labels=validation&page=1&state=open\n\nMaintainers\n-----------\n\n[Philipp
  Schuster](https://github.com/phischu) is the primary maintainer.\n\n[Adam Bergmark](https://github.com/bergmark)
  is the backup maintainer. Please\nget in touch with him if the primary maintainer
  cannot be reached.\n"
license-name: BSD3
