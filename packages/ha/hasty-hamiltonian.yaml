homepage: http://github.com/jtobin/hasty-hamiltonian
changelog-type: ''
hash: c4cd098920a1353720fe8028baf412357c73e0eac7462996669ff5cf2f8728d2
test-bench-deps:
  base: <5
  ad: ! '>=4 && <5'
  hasty-hamiltonian: -any
  mwc-probability: ! '>=1.0.1'
maintainer: jared@jtobin.ca
synopsis: Speedy traversal through parameter space.
changelog: ''
basic-deps:
  base: <5
  mcmc-types: ! '>=1.0.1'
  lens: ! '>=4 && <5'
  pipes: ! '>=4 && <5'
  transformers: -any
  mwc-probability: ! '>=1.0.1'
  primitive: -any
all-versions:
- '1.1.0'
- '1.1.1'
- '1.1.2'
- '1.1.3'
author: Jared Tobin
latest: '1.1.3'
description-type: haddock
description: ! 'Gradient-based traversal through parameter space.


  This implementation of HMC algorithm uses ''lens'' as a means to operate over

  generic indexed traversable functors, so you can expect it to work if your

  target function takes a list, vector, map, sequence, etc. as its argument.


  If you don''t want to calculate your gradients by hand you can use the

  handy <https://hackage.haskell.org/package/ad ad> library for automatic

  differentiation.


  Exports a ''mcmc'' function that prints a trace to stdout, as well as a

  ''hamiltonian'' transition operator that can be used more generally.


  > import Numeric.AD (grad)

  > import Numeric.MCMC.Hamiltonian

  >

  > target :: RealFloat a => [a] -> a

  > target [x0, x1] = negate ((x0 + 2 * x1 - 7) ^ 2 + (2 * x0 + x1 - 5) ^ 2)

  >

  > gTarget :: [Double] -> [Double]

  > gTarget = grad target

  >

  > booth :: Target [Double]

  > booth = Target target (Just gTarget)

  >

  > main :: IO ()

  > main = withSystemRandom . asGenIO $ mcmc 10000 0.05 20 [0, 0] booth'
license-name: MIT
