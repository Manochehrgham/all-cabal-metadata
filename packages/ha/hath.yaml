changelog-type: ''
hash: 410c0f58d55e8138fc4126a7cc0cb82e1aa97b58adce63a2596d2079e30439f0
test-bench-deps:
  MissingH: ! '>=1.2'
  bytestring: ! '>=0.10'
  split: ! '>=0.2'
  base: ==4.*
  process: ! '>=1.1'
  tasty-quickcheck: ! '>=0.8.1'
  cmdargs: ! '>=0.10'
  tasty-hunit: ! '>=0.8'
  parallel-io: ! '>=0.3'
  tasty: ! '>=0.8'
  dns: ! '>=1.2'
synopsis: Hath manipulates network blocks in CIDR notation.
changelog: ''
basic-deps:
  MissingH: ! '>=1.2'
  bytestring: ! '>=0.10'
  split: ! '>=0.2'
  base: ==4.*
  tasty-quickcheck: ! '>=0.8.1'
  cmdargs: ! '>=0.10'
  tasty-hunit: ! '>=0.8'
  parallel-io: ! '>=0.3'
  tasty: ! '>=0.8'
  dns: ! '>=1.2'
all-versions:
- '0.0.1'
- '0.0.2'
- '0.0.3'
- '0.0.4'
- '0.0.5'
- '0.1.0'
- '0.1.1'
- '0.1.2'
- '0.2.0'
- '0.2.1'
- '0.2.2'
- '0.2.3'
latest: '0.2.3'
description-type: haddock
description: ! 'Hath is a Haskell program for working with network blocks in CIDR

  notation. When dealing with blocks of network addresses, there are a

  few things that one usually wants to do with them:


  * Create a regular expression matching the CIDR block(s). This is

  because grep will throw up if you feed it CIDR.


  * Combine small blocks into larger ones. For example, if you have two

  consecutive \/24s, they might combine into a larger \/23.


  * View the result of block combination in a useful way.


  * List them.


  * Find their associated PTR records.


  Hath has several modes to perform these functions:


  [@Regexed@]

  This computes a (Perl-compatible) regular expression matching

  the input CIDR blocks. It''s the default mode of operation.


  [@Reduced@]

  This combines small blocks into larger ones where possible, and

  eliminates redundant blocks. The output should be equivalent to

  the input, though.


  [@Duped@]

  Shows only the blocks that would be removed by reduce; that is, it

  shows the ones that would get combined into larger blocks or are

  simply redundant.


  [@Diffed@]

  Shows what would change if you used reduce. Uses diff-like

  notation.


  [@Listed@]

  List the IP addresses contained within the given CIDRs.


  [@Reversed@]

  Perform reverse DNS (PTR) lookups on the IP addresses contained

  within the given CIDRs.


  /Examples/:


  Compute a (Perl-compatible) regular expression matching

  the input CIDR blocks. It''s the default mode of operation.


  @

  $ hath <<< \"10.0.0.0\/29 10.0.0.8\/29\"

  ((10)\.(0)\.(0)\.(15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0))

  @


  Combine two \/24s into a \/23:


  @

  $ hath reduced <<< \"10.0.0.0\/24 10.0.1.0\/24\"

  10.0.0.0/23

  @


  List the addresses in 192.168.0.240\/29:


  @

  $ hath listed <<< 192.168.0.240\/29

  192.168.0.240

  192.168.0.241

  192.168.0.242

  192.168.0.243

  192.168.0.244

  192.168.0.245

  192.168.0.246

  192.168.0.247

  @


  Perform PTR lookups on all of 198.41.0.4\/30:


  @

  $ hath reversed <<< 198.41.0.4\/30

  198.41.0.4: a.root-servers.net.

  198.41.0.5:

  198.41.0.6: rs.internic.net.

  198.41.0.7:

  @


  The DNS lookups are usually the bottleneck for this mode, but we can

  perform them in parallel. Simply pass the number of threads to the

  GHC runtime on the command line; for example, the following will

  perform 25 lookups in parallel:


  @

  $ hath reversed +RTS -N25 <<< 198.41.0.4\/24

  198.41.0.4: a.root-servers.net.

  198.41.0.5:

  198.41.0.6: rs.internic.net.

  ...

  @


  The command-line syntax and complete set of options are documented in

  the man page.'
