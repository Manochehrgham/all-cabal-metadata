changelog-type: ''
hash: 853fab31771710c43790987239629e24c350ad546a583ed82a7440e7b1bf5559
test-bench-deps: {}
synopsis: A quasiquoter for haskell-src-exts.
changelog: ''
basic-deps:
  base: ! '>=4 && <5'
  syb: -any
  haskell-src-exts: ! '>=1.9.0'
  haskell-src-meta: ! '>=0.3'
  template-haskell: -any
all-versions:
- '0.1'
- '0.2'
- '0.2.1'
- '0.2.2'
- '0.2.3'
- '0.3.0'
- '0.4.0'
- '0.5.0'
- '0.6.0'
- '0.6.1'
latest: '0.6.1'
description-type: haddock
description: ! 'Allows one to write programs that generate Haskell programs much

  more concisely and legibly. This package supports:


  * Antiquotations, denoted by stealing the splice syntax of

  Template Haskell, for example @[hs| $x ++ $(Hs.strE "bar") |]@.

  Splices may not nested.


  * Antiquoting pattern variables in patterns, using double

  parentheses. For instance:


  > let x = Hs.name "n" in [hs| \ ((x)) -> $(Hs.Var (Hs.UnQual x)) + 1 |]


  * Antiquoting bound names. Names that are antiquoted appear

  surrounded by double underscores. For instance:


  > let f = "incr"

  >     fE = Hs.Var $ Hs.UnQual $ Hs.name f

  > in [hs| let __f__ x = x + 1 in $fE 10 |]


  We need three different syntaxes for antiquotations, because we do

  not extend the haskell-src-exts parser in any way and the Template

  Haskell splicing syntax is only available in expression contexts.'
