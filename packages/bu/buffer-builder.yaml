changelog-type: ''
hash: 5415990cccc6680adfca1318c9ad950e9ba7f0c4bb9f89f14d44b2adc5e75bf4
synopsis: Library for efficiently building up buffers, one piece at a time
changelog: ''
all-versions:
- '0.1.0.0'
- '0.2.0.0'
- '0.2.0.1'
- '0.2.0.2'
- '0.2.0.3'
- '0.2.1.0'
- '0.2.2.0'
- '0.2.2.1'
- '0.2.2.2'
latest: '0.2.2.2'
description-type: haddock
description: ! '"Data.BufferBuilder" is an efficient library for incrementally building

  up ''ByteString''s, one chunk at a time.  Early benchmarks show it

  is over twice as fast as ByteString Builder, primarily because

  ''BufferBuilder'' is built upon an ST-style restricted monad and

  mutable state instead of ByteString Builder''s monoidal AST.


  Internally, BufferBuilder is backed by a few C functions.

  Examination of GHC''s output shows nearly optimal code generation

  with no intermediate thunks -- and thus, continuation passing and

  its associated indirect jumps and stack traffic only occur when

  BufferBuilder is asked to append a non-strict ByteString.


  I benchmarked four approaches with a URL encoding benchmark:


  * State monad, concatenating ByteStrings: 6.98 us


  * State monad, ByteString Builder: 2.48 us


  * Crazy explicit RealWorld baton passing with unboxed state: 28.94 us (GHC generated
  really awful code for this, but see the revision history for the technique)


  * C + FFI + ReaderT: 1.11 us


  Using BufferBuilder is very simple:


  > import qualified Data.BufferBuilder as BB

  >

  > let byteString = BB.runBufferBuilder $ do

  >       BB.appendBS "http"

  >       BB.appendChar8 ''/''

  >       BB.appendBS "//"


  This package also provides "Data.BufferBuilder.Utf8" for generating UTF-8 buffers

  and "Data.BufferBuilder.Json" for encoding data structures into JSON.'
