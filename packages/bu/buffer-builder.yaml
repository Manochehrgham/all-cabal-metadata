homepage: https://github.com/chadaustin/buffer-builder
changelog-type: markdown
hash: f9c58bd17942059dfbbcb169ba6bf3d350909c4c0c9345c13b75b0623525b9fc
test-bench-deps:
  buffer-builder: -any
  bytestring: -any
  tasty-th: -any
  base: ==4.*
  text: -any
  criterion: -any
  HUnit: -any
  json-builder: -any
  tasty-quickcheck: -any
  tasty-hunit: -any
  attoparsec: -any
  tasty: -any
  deepseq: -any
  http-types: -any
  aeson: -any
  vector: -any
maintainer: chad@chadaustin.me
synopsis: Library for efficiently building up buffers, one piece at a time
changelog: ! '0.2.3.0


  * Add the ability to query the current buffer size

  * Add the ability to return a value from a BufferBuilder


  0.2.2.2


  * Add the ability to percent-encode directly into a Utf8Builder

  * Add Utf8Builder.unsafeAppendBufferBuilder


  0.2.2.0


  * Add the ability to encode custom types as JSON keys


  0.2.1.0


  * Fix a buffer overrun in the double serializer

  * Add support for URL percent-encoding

  * Tweak the BufferWriter struct to improve code generation

'
basic-deps:
  bytestring: -any
  base: ==4.*
  unordered-containers: -any
  text: -any
  mtl: -any
  vector: -any
all-versions:
- '0.1.0.0'
- '0.2.0.0'
- '0.2.0.1'
- '0.2.0.2'
- '0.2.0.3'
- '0.2.1.0'
- '0.2.2.0'
- '0.2.2.1'
- '0.2.2.2'
- '0.2.3.0'
author: Chad Austin, Andy Friesen
latest: '0.2.3.0'
description-type: haddock
description: ! '"Data.BufferBuilder" is an efficient library for incrementally building

  up ''ByteString''s, one chunk at a time.  Early benchmarks show it

  is over twice as fast as ByteString Builder, primarily because

  ''BufferBuilder'' is built upon an ST-style restricted monad and

  mutable state instead of ByteString Builder''s monoidal AST.


  Internally, BufferBuilder is backed by a few C functions.

  Examination of GHC''s output shows nearly optimal code generation

  with no intermediate thunks -- and thus, continuation passing and

  its associated indirect jumps and stack traffic only occur when

  BufferBuilder is asked to append a non-strict ByteString.


  I benchmarked four approaches with a URL encoding benchmark:


  * State monad, concatenating ByteStrings: 6.98 us


  * State monad, ByteString Builder: 2.48 us


  * Crazy explicit RealWorld baton passing with unboxed state: 28.94 us (GHC generated
  really awful code for this, but see the revision history for the technique)


  * C + FFI + ReaderT: 1.11 us


  Using BufferBuilder is very simple:


  > import qualified Data.BufferBuilder as BB

  >

  > let byteString = BB.runBufferBuilder $ do

  >       BB.appendBS "http"

  >       BB.appendChar8 ''/''

  >       BB.appendBS "//"


  This package also provides "Data.BufferBuilder.Utf8" for generating UTF-8 buffers

  and "Data.BufferBuilder.Json" for encoding data structures into JSON.'
license-name: BSD3
