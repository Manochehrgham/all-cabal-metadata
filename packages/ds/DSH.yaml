changelog-type: ''
hash: a3b0fb4a514a9d54ccc6a227b6e05168bc466e534ac2b7e1064d1049f671e81b
test-bench-deps:
  test-framework-hunit: ! '>=0.3'
  DSH: ! '>=0.10'
  test-framework: ! '>=0.6'
  base: ! '>=4.7 && <5'
  HDBC: ! '>=2.3'
  text: ! '>=1.1'
  test-framework-quickcheck2: ! '>=0.2'
  HUnit: ! '>=1.2'
  HDBC-postgresql: ! '>=2.3'
  containers: ! '>=0.5'
  QuickCheck: ! '>=2.4'
synopsis: Database Supported Haskell
changelog: ''
basic-deps:
  either: ! '>=4.0'
  bytestring: ! '>=0.10'
  ansi-wl-pprint: ! '>=0.6'
  base: ! '>=4.7 && <5'
  HDBC: ! '>=2.3'
  text: ! '>=1.1'
  dlist: ! '>=0.7'
  semigroups: ! '>=0.16'
  HDBC-postgresql: ! '>=2.3'
  kure: ! '>=2.16'
  containers: ! '>=0.5'
  mtl: ! '>=2.1'
  algebra-sql: ! '>=0.1'
  set-monad: ! '>=0.1'
  pretty: ! '>=1.1'
  aeson: ! '>=0.8'
  template-haskell: ! '>=2.9'
  algebra-dag: ! '>=0.1'
all-versions:
- '0.4'
- '0.4.0.1'
- '0.4.1'
- '0.4.2'
- '0.4.2.1'
- '0.4.3'
- '0.5'
- '0.5.3'
- '0.5.5'
- '0.6'
- '0.6.1'
- '0.6.2'
- '0.6.6'
- '0.7'
- '0.7.1'
- '0.7.2'
- '0.7.3'
- '0.7.4'
- '0.7.5'
- '0.7.6'
- '0.7.7'
- '0.7.8'
- '0.7.8.1'
- '0.7.8.2'
- '0.8.0.1'
- '0.8.1.0'
- '0.8.2.0'
- '0.8.2.1'
- '0.8.2.2'
- '0.8.2.3'
- '0.10.0.0'
- '0.10.0.1'
- '0.10.0.2'
latest: '0.10.0.2'
description-type: markdown
description: ! "# Database-Supported Haskell (DSH)\n\nThis is a Haskell library for
  database-supported program execution. Using\nthis library a relational database
  management system (RDBMS) can be used as\na coprocessor for the Haskell programming
  language, especially for those\nprogram fragments that carry out data-intensive
  and data-parallel\ncomputations.\n\nDatabase executable program fragments can be
  written using the monad\ncomprehension notation [2] and list processing combinators
  from the Haskell\nlist prelude. Note that rather than embedding a relational language
  into\nHaskell, we turn idiomatic Haskell programs into SQL queries.\n\nDSH faithfully
  represents list order and nesting, and compiles the list\nprocessing combinators
  into relational queries. The implementation avoids\nunnecessary data transfer and
  context switching between the database\ncoprocessor and the Haskell runtime by ensuring
  that the number of generated\nrelational queries is only determined by the program
  fragment's type and not\nby the database size.\n\nDSH can be used to allow existing
  Haskell programs to operate on large scale\ndata (e.g., larger than the available
  heap) or query existing database\nresident data with Haskell.\n\nNote that this
  package is flagged experimental and therefore is not suited\nfor production use.
  This is a proof of concept implementation only. To learn\nmore about DSH, our paper
  entitled as \"Haskell Boards the Ferry: Database-\nSupported Program Execution for
  Haskell\" [1] is a recommended reading. The\npackage includes a couple of examples
  that demonstrate how to use DSH.\n\nIn contrast to the DSH version described in
  [1], the current release\ndoes not rely anymore on the loop-lifting compilation
  technique\ntogether with the Pathfinder optimizer. Instead, it brings a\ncompletely
  rewritten query compiler based on Guy Blelloch's flattening\ntransformation. This
  approach leads to a more robust compilation and\nproduces more efficient query code.\n\n1.
  [http://db.inf.uni-tuebingen.de/staticfiles/publications/ferryhaskell.pdf](Grust\n
  \  et al. Haskell Boards the Ferry. Database-Supported Program\n   Execution for
  Haskell. IFL 2010)\n2. [http://db.inf.uni-tuebingen.de/staticfiles/publications/haskell2011.pdf](Grust\n
  \  et al. Bringing Back Monad Comprehensions. Haskell Symposium 2011).\n\n# Release
  Notes\n\n* This is an experimental proof-of-concept implementation that most\n  likely
  contains bugs. You have been warned. We are happy to receive\n  bug reports.\n*
  For documentation, have a look at the examples included in directory\n  'examples'
  in the source distribution.\n* DSH works with a HDBC PostgreSQL connection. Other
  databases (*e.g.*\n  MySQL, Sqlite) are unlikely to work.\n* Support for general
  algebraic data types is currently broken. Flat\n  record types do work.\n* Comprehension
  syntax for DSH queries is currently implemented using\n  monad comprehensions and
  the `RebindableSyntax` extension. This\n  means that any module that contains DSH
  queries and makes use of\n  comprehension syntax has to enable the extension. Additionally,\n
  \ `do`-notation and comprehensions over other monads (*e.g.* lists)\n  can not be
  used in such a module. This limitation is an\n  implementation artifact that we
  hope to get rid of soon.\n"
