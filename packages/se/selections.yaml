homepage: https://github.com/ChrisPenner/selections#readme
changelog-type: ''
hash: 7aed2d48530fe5fb7170979c86f0be4d9bcc3fa9ccd2b1a98da894c01b15da70
test-bench-deps: {}
maintainer: christopher.penner@gmail.com
synopsis: Combinators for operating with selections over an underlying functor
changelog: ''
basic-deps:
  base: ! '>=4.7 && <5'
  comonad: -any
  bifunctors: -any
all-versions:
- '0.1.0.0'
- '0.1.0.2'
- '0.1.0.3'
author: Chris Penner
latest: '0.1.0.3'
description-type: markdown
description: ! "Selections\n==========\n[![Hackage](https://img.shields.io/badge/hackage-latest-green.svg)](https://hackage.haskell.org/package/selections)\n\n[See
  it on Hackage](https://hackage.haskell.org/package/selections)\n\n`selections` is
  a haskell package for transforming subsets of values within a functor using\nan
  intuitive selection-based interface.\n\nEver wished you could select just a few
  values within a functor, perform some\noperations on them, then flatten them back
  into the plain old functor again? Now\nyou can!\n\n`Selection` is a newtype wrapper
  around Functors which adds several\ncombinators and interesting instances. Wrapping
  a functor in `Selection` allows\nyou to:\n\n-   Select specific values within your
  functor according to a predicate\n-   Expand/Contract selections based on additional
  predicates using `include`\n    and `exclude`\n-   Select values based on their
  context if your functor is also a Comonad\n-   Map over unselected and/or selected
  values using `Bifunctor`\n-   Traverse over unselected and/or selected values using
  `Bitraversable`\n-   Fold over unselected and/or selected values using `Bifoldable`\n-
  \  Perform monad computations over selected values if your functor is a Monad\n-
  \  Extract all unselected or selected elements to a list\n-   Deselect and return
  to your original functor using `unify`\n\nLenses and traversals coming eventually!\n\nTechnically
  you could use `Selection` as a monad-transformer, but it's a bit\nclunky and you'd
  probably be better off with\n[`EitherT`](https://hackage.haskell.org/package/either-4.4.1.1/docs/Control-Monad-Trans-Either.html).\nFun
  fact, `Selection` is isomorphic to `EitherT`, but the semantics are quite\ndifferent
  and they're suited to different purposes.\n\n## Examples\n\nWe'll start off using
  a simple list as our underlying functor.\n\nYou may find it useful to throw in some
  [Type\nApplications](https://ghc.haskell.org/trac/ghc/wiki/TypeApplication) to help\ndisambiguate
  type for the compiler. This typically isn't an issue in compiled code,\nbut the
  interpreter can get confused from time to time.\n\n```haskell\n{-# language TypeApplications
  #-}\nimport Data.Functor.Selection\n\n-- This combinator is super handy for chaining
  selections along\n(&) :: a -> (a -> c) -> c\n(&) = flip ($)\n\nxs :: [Int]\nxs =
  [1..6]\n```\n\nLet's select just the even numbers and see what we get!\n\n```haskell\nevens
  :: Selection [] Int Int\nevens = newSelection xs & select even\n-- Selection {runSelection
  = [Left 1,Right 2,Left 3,Right 4,Left 5,Right 6]}\n```\n\nCool, we can see that
  the underlying representation consists of our original\nfunctor, except it uses
  Either to show which elements are selected. Let's \nmultiply our odd elements by
  two with `mapUnselected`\n\n```haskell\nbyTwo :: Selection [] Int Int\nbyTwo = evens
  & mapUnselected (*2)\n-- Selection {runSelection = [Left 2,Right 2,Left 6,Right
  4,Left 10,Right 6]}\n```\n\nNotice that even though the numbers became even as a
  result of the transformation\nthe same elements remain selected. If you wanted to
  you could run 'select even'\nagain to include the new elements.\n\nLet's exclude
  anything greater than 5 from our selection, then get the numbers\nthat remain selected
  as a list\n\n```haskell\nexcluded :: [Int]\nexcluded = byTwo & exclude (>5) & getSelected\n--
  [2, 4]\n```\nNice! Looks like it worked! Notice how the order of elements remained
  \nthe same through the whole thing!\n\nThe types of the selected and unselected
  elements are allowed to diverge!\nSo long as they line up when we decide to get
  the results then it's all good!\nWe can use `unify :: Selectable s f => (b -> c)
  -> (a -> c) -> s b a -> f c` to\nhelp us out with that.\n\nLet's try it out!\n\n```haskell\ndiverged
  :: Selection [] String Int\ndiverged = newSelection @(Selection []) [1..6] & select
  even & mapUnselected show\n-- Selection {runSelection = [Left \"1\",Right 2,Left
  \"3\",Right 4,Left \"5\",Right 6]}\n \nunified :: [Int]\nunified = diverged & mapUnselected
  (\"100\"++) & unify read id\n[1001,2,1003,4,1005,6]\n```\n\n`[]` is a great functor
  to try out because it has Applicative and Monad instances\ndefined, which both act
  pretty much as you'd expect, but they only consider selected\nvalues!\n\n```haskell\nevens
  :: Selection [] Int Int\nevens = newSelection [1..6] & select even \n\nplus10 ::
  Selection [] Int Int\nplus10 = do\n  x <- evens\n  newSelection [x + 10, x + 100]\n--
  Selection {runSelection = [Left 1,Right 12,Right 102,Left 3,Right 14,Right 104,Left
  5,Right 16,Right 106]}\n```\n\n\n"
license-name: BSD3
