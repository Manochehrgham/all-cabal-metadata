homepage: http://github.com/haskoin/secp256k1#readme
changelog-type: ''
hash: 6ae4ad266e0648b287ebab7e4d01d91d2fb4df750e2bd19d47dd89bf350603cc
test-bench-deps:
  test-framework-hunit: -any
  bytestring: -any
  test-framework: -any
  base: -any
  entropy: -any
  test-framework-quickcheck2: -any
  HUnit: -any
  binary: -any
  mtl: -any
  base16-bytestring: -any
  QuickCheck: -any
  string-conversions: -any
  secp256k1: -any
  cryptohash: -any
maintainer: Jean-Pierre Rupp <root@haskoin.com>
synopsis: secp256k1 bindings for Haskell
changelog: ''
basic-deps:
  bytestring: -any
  base: ! '>=4.8 && <5'
  largeword: -any
  entropy: -any
  binary: -any
  mtl: -any
  base16-bytestring: -any
  QuickCheck: -any
  string-conversions: -any
all-versions:
- '0.1.0'
- '0.1.1'
- '0.1.2'
- '0.1.3'
- '0.1.4'
- '0.1.5'
- '0.1.6'
- '0.1.7'
- '0.1.8'
- '0.1.9'
- '0.1.10'
- '0.1.11'
- '0.2.0'
- '0.3.0'
- '0.3.1'
- '0.3.2'
- '0.4.0'
- '0.4.1'
author: Pieter Wuille
latest: '0.4.1'
description-type: markdown
description: ! "libsecp256k1\n============\n\n[![Build Status](https://travis-ci.org/bitcoin/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin/secp256k1)\n\nOptimized
  C library for EC operations on curve secp256k1.\n\nThis library is a work in progress
  and is being used to research best practices. Use at your own risk.\n\nFeatures:\n*
  secp256k1 ECDSA signing/verification and key generation.\n* Adding/multiplying private/public
  keys.\n* Serialization/parsing of private keys, public keys, signatures.\n* Constant
  time, constant memory access signing and pubkey generation.\n* Derandomized DSA
  (via RFC6979 or with a caller provided function.)\n* Very efficient implementation.\n\nImplementation
  details\n----------------------\n\n* General\n  * No runtime heap allocation.\n
  \ * Extensive testing infrastructure.\n  * Structured to facilitate review and analysis.\n
  \ * Intended to be portable to any system with a C89 compiler and uint64_t support.\n
  \ * Expose only higher level interfaces to minimize the API surface and improve
  application security. (\"Be difficult to use insecurely.\")\n* Field operations\n
  \ * Optimized implementation of arithmetic modulo the curve's field size (2^256
  - 0x1000003D1).\n    * Using 5 52-bit limbs (including hand-optimized assembly for
  x86_64, by Diederik Huys).\n    * Using 10 26-bit limbs.\n  * Field inverses and
  square roots using a sliding window over blocks of 1s (by Peter Dettman).\n* Scalar
  operations\n  * Optimized implementation without data-dependent branches of arithmetic
  modulo the curve's order.\n    * Using 4 64-bit limbs (relying on __int128 support
  in the compiler).\n    * Using 8 32-bit limbs.\n* Group operations\n  * Point addition
  formula specifically simplified for the curve equation (y^2 = x^3 + 7).\n  * Use
  addition between points in Jacobian and affine coordinates where possible.\n  *
  Use a unified addition/doubling formula where necessary to avoid data-dependent
  branches.\n  * Point/x comparison without a field inversion by comparison in the
  Jacobian coordinate space.\n* Point multiplication for verification (a*P + b*G).\n
  \ * Use wNAF notation for point multiplicands.\n  * Use a much larger window for
  multiples of G, using precomputed multiples.\n  * Use Shamir's trick to do the multiplication
  with the public key and the generator simultaneously.\n  * Optionally (off by default)
  use secp256k1's efficiently-computable endomorphism to split the P multiplicand
  into 2 half-sized ones.\n* Point multiplication for signing\n  * Use a precomputed
  table of multiples of powers of 16 multiplied with the generator, so general multiplication
  becomes a series of additions.\n  * Access the table with branch-free conditional
  moves so memory access is uniform.\n  * No data-dependent branches\n  * The precomputed
  tables add and eventually subtract points for which no known scalar (private key)
  is known, preventing even an attacker with control over the private key used to
  control the data internally.\n\nBuild steps\n-----------\n\nlibsecp256k1 is built
  using autotools:\n\n    $ ./autogen.sh\n    $ ./configure\n    $ make\n    $ ./tests\n
  \   $ sudo make install  # optional\n"
license-name: MIT
