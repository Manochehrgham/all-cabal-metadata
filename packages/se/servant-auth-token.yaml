homepage: https://github.com/ncrashed/servant-auth-token#readme
changelog-type: markdown
hash: 2ec7bcc359d7e5ec91abca8fed643d8944224698608ac5db1e682ecd75b21e7c
test-bench-deps: {}
maintainer: ncrashed@gmail.com
synopsis: Servant based API and server for token based authorisation
changelog: ! '0.2.0.1

  =======


  * Relax boundaries for ghc 8.0.1.


  0.2.0.0

  =======


  * Implement `servant-auth-token-0.2.0.0` API.


  0.1.2.0

  =======


  * Expose implementation of API for embedding in complex servers.


  0.1.1.0

  =======


  * Added `restoreCodeGenerator` to configuration


  0.1.0.0

  =======


  * Initial publication'
basic-deps:
  bytestring: ! '>=0.10 && <0.11'
  servant-auth-token-api: ! '>=0.2.0 && <0.3'
  base: ! '>=4.7 && <5'
  time: ! '>=1.5 && <1.7'
  persistent: ! '>=2.2 && <2.6'
  text: ! '>=1.2 && <1.3'
  uuid: ! '>=1.3 && <1.4'
  persistent-template: ! '>=2.1 && <2.6'
  persistent-postgresql: ! '>=2.2 && <2.6'
  servant-server: ! '>=0.7 && <0.9'
  aeson-injector: ! '>=1.0.4 && <1.1'
  containers: ! '>=0.5 && <0.6'
  mtl: ! '>=2.2 && <2.3'
  pwstore-fast: ! '>=2.4 && <2.5'
  transformers: ! '>=0.4 && <0.6'
all-versions:
- '0.1.0.0'
- '0.1.1.0'
- '0.1.2.0'
- '0.2.0.0'
- '0.2.0.1'
author: NCrashed
latest: '0.2.0.1'
description-type: markdown
description: ! "# servant-auth-token\n\n[![Build Status](https://travis-ci.org/NCrashed/servant-auth-token.svg?branch=master)](https://travis-ci.org/NCrashed/servant-auth-token)\n\nThe
  repo contains server implementation of [servant-auth-toke-api](https://github.com/NCrashed/servant-auth-token-api).\n\n#
  How to add to your server\n\nTo use the server as constituent part, you need to
  provide customised 'AuthConfig' for \n'authServer' function and implement 'AuthMonad'
  instance for your handler monad.\n\n``` haskell\nimport Servant.Server.Auth.Token
  as Auth\n\n-- | Example of user side configuration\ndata Config = Config {\n  --
  | Authorisation specific configuration\n  authConfig :: AuthConfig\n  -- other fields\n
  \ -- ...\n}\n\n-- | Example of user side handler monad\nnewtype App a = App { \n
  \   runApp :: ReaderT Config (ExceptT ServantErr IO) a\n  } deriving ( Functor,
  Applicative, Monad, MonadReader Config,\n               MonadError ServantErr, MonadIO)\n\n--
  | Now you can use authorisation API in your handler\ninstance AuthMonad App where
  \n  getAuthConfig = asks authConfig\n  liftAuthAction = App . lift\n\n-- | Include
  auth 'migrateAll' function into your migration code\ndoMigrations :: SqlPersistT
  IO ()\ndoMigrations = runMigrationUnsafe $ do \n  migrateAll -- other user migrations\n
  \ Auth.migrateAll -- creation of authorisation entities\n  -- optional creation
  of default admin if db is empty\n  ensureAdmin 17 \"admin\" \"123456\" \"admin@localhost\"
  \n```\n\nNow you can use 'guardAuthToken' to check authorisation headers in endpoints
  of your server:\n\n``` haskell\n-- | Read a single customer from DB\ncustomerGet
  :: CustomerId -- ^ Customer unique id\n  -> MToken '[\"customer-read\"] -- ^ Required
  permissions for auth token\n  -> App Customer -- ^ Customer data\ncustomerGet i
  token = do\n  guardAuthToken token \n  runDB404 \"customer\" $ getCustomer i \n```"
license-name: BSD3
