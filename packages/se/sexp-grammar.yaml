homepage: https://github.com/esmolanka/sexp-grammar
changelog-type: ''
hash: 8b784954439741edca5e517e6213c510fb9a8c3fcd4deb41f6e371246104a82c
test-bench-deps:
  base: -any
  stack-prism: -any
  semigroups: -any
  sexp-grammar: -any
  tasty-quickcheck: -any
  tasty-hunit: -any
  tasty: -any
  scientific: -any
  QuickCheck: -any
maintainer: Eugene Smolanka <esmolanka@gmail.com>, Sergey Vinokurov <serg.foo@gmail.com>
synopsis: Invertible parsers for S-expressions
changelog: ''
basic-deps:
  split: -any
  base: ! '>=4.7 && <5'
  text: -any
  stack-prism: -any
  semigroups: -any
  array: -any
  containers: -any
  wl-pprint-text: -any
  mtl: ! '>=2.1'
  scientific: -any
  template-haskell: -any
all-versions:
- '1.0.0'
- '1.1.0'
- '1.1.1'
author: Eugene Smolanka, Sergey Vinokurov
latest: '1.1.1'
description-type: markdown
description: ! "sexp-grammar\n============\n\nInvertible syntax library for serializing
  and deserializing Haskell\nstructures into S-expressions. Just write a grammar once
  and get\nboth parser and pretty-printer, for free.\n\nThe package is heavily inspired
  by the paper\n[Invertible syntax descriptions: Unifying parsing and pretty printing]\n(http://www.informatik.uni-marburg.de/~rendel/unparse/)
  and a similar\nimplementation of invertible grammar approach for JSON, library by\nMartijn
  van Steenbergen called\n[JsonGrammar2](https://github.com/MedeaMelana/JsonGrammar2).\n\nLet's
  take a look at example:\n\n```haskell\ndata Person = Person\n  { pName    :: String\n
  \ , pAddress :: String\n  , pAge     :: Maybe Int\n  } deriving (Show)\n\npersonGrammar
  :: SexpG Person\npersonGrammar =\n  $(grammarFor 'Person) .               -- construct
  Person from\n    list (                              -- a list with\n      el (sym
  \"person\") >>>             -- symbol \"person\",\n      el string'        >>>             --
  some string,\n      props (                           -- and properties\n        Kw
  \"address\" .: string' >>>     -- :address with string value,\n        Kw \"age\"
  .:? int))              -- and optional :age int proprety\n```\n\nSo now we can use
  `personGrammar` to parse S-expessions to `Person`\nrecord and pretty-print any `Person`
  back to S-expression:\n\n```haskell\nghci> :m Control.Category Language.SexpGrammar\nghci>
  parseFromString personGrammar <$> getLine\n(person \"John Doe\" :address \"42 Whatever
  str.\" :age 25)\nRight (Person {pName = \"John Doe\", pAddress = \"42 Whatever str.\",
  pAge = Just 25})\nghci> let (Right person) = it\nghci> prettyToText personGrammar
  person\n(person\n \"John Doe\"\n :address\n \"42 Whatever str.\"\n :age\n 25)\n```\n\nThe
  grammars are described in terms of isomorphisms and stack\nmanipulations.\n\nThe
  simplest primitive grammars are atom grammars, which match `Sexp`\natoms with Haskell
  counterparts:\n\n```haskell\n                             --               grammar
  type   | consumes     | produces\n                             --    --------------------------+--------------+-------------------\nbool
  \   :: SexpG Bool        -- or Grammar    SexpGrammar      (Sexp :- t)    (Bool
  \      :- t)\ninteger :: SexpG Integer     -- or Grammar    SexpGrammar      (Sexp
  :- t)    (Integer    :- t)\nint     :: SexpG Int         -- or Grammar    SexpGrammar
  \     (Sexp :- t)    (Int        :- t)\nreal    :: SexpG Scientific  -- or Grammar
  \   SexpGrammar      (Sexp :- t)    (Scientific :- t)\ndouble  :: SexpG Double      --
  or Grammar    SexpGrammar      (Sexp :- t)    (Double     :- t)\nstring  :: SexpG
  Text        -- or Grammar    SexpGrammar      (Sexp :- t)    (Text       :- t)\nstring'
  :: SexpG String      -- or Grammar    SexpGrammar      (Sexp :- t)    (String     :-
  t)\nsymbol  :: SexpG Text        -- or Grammar    SexpGrammar      (Sexp :- t)    (Text
  \      :- t)\nsymbol' :: SexpG String      -- or Grammar    SexpGrammar      (Sexp
  :- t)    (String     :- t)\nkeyword :: SexpG Kw          -- or Grammar    SexpGrammar
  \     (Sexp :- t)    (Kw         :- t)\nsym     :: Text -> SexpG_    -- or Grammar
  \   SexpGrammar      (Sexp :- t)    t\nkw      :: Kw   -> SexpG_    -- or Grammar
  \   SexpGrammar      (Sexp :- t)    t\n```\n\nGrammars matching lists and vectors
  can be defined using an auxiliary\ngrammar type `SeqGrammar`. The following primitives
  embed\n`SeqGrammar`s into main `SexpGrammar` context:\n\n```haskell\nlist  :: Grammar
  SeqGrammar t t' -> Grammar SexpGrammar (Sexp :- t) t'\nvect  :: Grammar SeqGrammar
  t t' -> Grammar SexpGrammar (Sexp :- t) t'\n```\n\nGrammar type `SeqGrammar` basically
  describes the sequence of elements\nin a `Sexp` list (or vector). Single element
  grammar is defined with\n`el`, \"match rest of the sequence as list\" grammar could
  be defined\nwith `rest` combinator. If the rest of the sequence is a property\nlist,
  `props` combinator should be used.\n\n```haskell\nel    :: Grammar SexpGrammar (Sexp
  :- a)  b       -> Grammar SeqGrammar a b\nrest  :: Grammar SexpGrammar (Sexp :-
  a) (b :- a) -> Grammar SeqGrammar a ([b] :- a)\nprops :: Grammar PropGrammar a b
  \                 -> Grammar SeqGrammar a b\n```\n\n`props` combinator embeds properties
  grammar `PropGrammar` into a\n`SeqGrammar` context. `PropGrammar` describes what
  keys and values to\nmatch.\n\n```haskell\n(.:)  :: Kw\n      -> Grammar SexpGrammar
  (Sexp :- t) (a :- t)\n      -> Grammar PropGrammar t (a :- t)\n\n(.:?) :: Kw\n      ->
  Grammar SexpGrammar (Sexp :- t) (a :- t)\n      -> Grammar PropGrammar t (Maybe
  a :- t)\n```\n\nPlease refer to Haddock on [Hackage](http://hackage.haskell.org/package/sexp-grammar)\nfor
  API documentation.\n\nDiagram of grammar contexts:\n\n```\n\n     --------------------------------------\n
  \    |              AtomGrammar           |\n     --------------------------------------\n
  \        ^\n         |  atomic grammar combinators\n         v\n ------------------------------------------------------\n
  |                      SexpGrammar                   |\n ------------------------------------------------------\n
  \        | list, vect     ^              ^\n         v                | el, rest
  \    |\n     ----------------------------------  |\n     |           SeqGrammar
  \          |  |\n     ----------------------------------  | (.:)\n              |
  props                    | (.:?)\n              v                          |\n          -------------------------------------\n
  \         |             PropGrammar           |\n          -------------------------------------\n\n```\n"
license-name: BSD3
