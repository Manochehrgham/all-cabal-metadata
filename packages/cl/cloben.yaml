homepage: http://github.com/sgraf812/cloben#readme
changelog-type: ''
hash: 8d246265654df4ab90ce9e5565851d08005d11829fd10b4357843aecc595e716
test-bench-deps: {}
maintainer: sgraf1337@gmail.com
synopsis: Clone and benchmark Haskell cabal projects
changelog: ''
basic-deps:
  base: ! '>=4.7 && <5'
  text: <1.3
  process: ! '>=1.1.0.0 && <1.5'
  turtle: ! '>=1.2 && <1.3'
  foldl: <2.0
  temporary: ! '>=1.1 && <1.3'
  system-filepath: ! '>=0.3.1 && <0.5'
all-versions:
- '0.1.0.0'
- '0.1.0.1'
author: Sebastian Graf
latest: '0.1.0.1'
description-type: markdown
description: ! "# `cloben` [![Build Status](https://travis-ci.org/sgraf812/cloben.svg?branch=master)](https://travis-ci.org/sgraf812/cloben)
  [![Hackage](https://img.shields.io/hackage/v/cloben.svg?flat=true)](https://hackage.haskell.org/package/cloben)\r\n\r\n`cloben`
  is a Haskell shell script transforms `cabal bench`/`stack bench` results into a
  CSV file readable by `gipeda` for visualization.\r\nPrior to that, it optionally
  clones a specific commit of a given git repository into a temporary folder in which
  it then performs the benchmarking.\r\n\r\nIt parses build warnings and timing data
  output in the standard `criterion` format.\r\n\r\n# Usage\r\n\r\nThere are two modes
  of operation:\r\n\r\n`cloben` will benchmark the cabal project in the current working
  directory and output the CSV data on `stdout`. It will try to use `stack` as an
  optimization, but the fall back mechanism (cabal sandboxing) takes 10 minutes on
  my laptop for even the simplest dependency tree, so stay calm :).\r\n\r\n`cloben
  <repo> <commit>` will also attempt to recursively clone a remote git `repo` at a
  specific `commit` into a temporary directory and `cd` into it prior to benchmarking.\r\n\r\nFor
  usage with `gipeda`, `stdout` should be redirected into a csv file.\r\n\r\nSee also
  `cloben --help`.\r\n\r\n# How to build\r\n\r\nSimplest way? Don't! Use [`stack`s
  excellent support for `runghc`](http://docs.haskellstack.org/en/stable/GUIDE.html#script-interpreter):\r\n```\r\n$
  stack cloben.hs\r\n```\r\nOr on unixoid systems:\r\n```\r\n$ chmod +x cloben.hs\r\n$
  ./cloben.hs\r\n```\r\n\r\nOf course, `cloben` can be built both in a `cabal` and
  in a `stack` environment.\r\n```\r\n$ stack build && stack exec cloben\r\n...\r\n$
  cabal install -j && cabal run\r\n...\r\n```\r\n\r\nOr even just through hackage:\r\n\r\n```\r\n$
  stack install cloben && cloben\r\n...\r\n$ cabal install cloben && cloben\r\n...\r\n```\r\n\r\n#
  Example\r\n\r\nWhat running `cloben` on the `Pipes` library yielded:\r\n\r\n```\r\n$
  ./cloben.hs https://github.com/Gabriel439/Haskell-Pipes-Library 930c834aacfa7bf8ec65d072e0d0a982aa7a2bc1
  > logs/930c834aacfa7bf8ec65d072e0d0a982aa7a2bc1.csv\r\n$ cat logs/930c834aacfa7bf8ec65d072e0d0a982aa7a2bc1.csv\r\nbuild/warnings;81.0\r\nbenchmark/prelude-benchmarks/Folds/all;152900.0\r\nbenchmark/prelude-benchmarks/Folds/any;163700.0\r\nbenchmark/prelude-benchmarks/Folds/find;170800.0\r\nbenchmark/prelude-benchmarks/Folds/findIndex;164500.0\r\nbenchmark/prelude-benchmarks/Folds/fold;68150.0\r\nbenchmark/prelude-benchmarks/Folds/foldM;67690.0\r\nbenchmark/prelude-benchmarks/Folds/head;10.84\r\nbenchmark/prelude-benchmarks/Folds/index;117000.0\r\nbenchmark/prelude-benchmarks/Folds/last;119600.0\r\nbenchmark/prelude-benchmarks/Folds/length;53960.0\r\nbenchmark/prelude-benchmarks/Folds/null;11.2\r\nbenchmark/prelude-benchmarks/Folds/toList;138100.0\r\nbenchmark/prelude-benchmarks/Pipes/chain;1351000.0\r\nbenchmark/prelude-benchmarks/Pipes/drop;110400.0\r\nbenchmark/prelude-benchmarks/Pipes/dropWhile;159000.0\r\nbenchmark/prelude-benchmarks/Pipes/filter;585100.0\r\nbenchmark/prelude-benchmarks/Pipes/findIndices;397900.0\r\nbenchmark/prelude-benchmarks/Pipes/map;324600.0\r\nbenchmark/prelude-benchmarks/Pipes/mapM;1276000.0\r\nbenchmark/prelude-benchmarks/Pipes/take;346500.0\r\nbenchmark/prelude-benchmarks/Pipes/takeWhile;332400.0\r\nbenchmark/prelude-benchmarks/Pipes/scan;370900.0\r\nbenchmark/prelude-benchmarks/Pipes/scanM;1177000.0\r\nbenchmark/prelude-benchmarks/Pipes/concat;159600.0\r\nbenchmark/prelude-benchmarks/Zips/zip;1218000.0\r\nbenchmark/prelude-benchmarks/Zips/zipWith;1318000.0\r\nbenchmark/prelude-benchmarks/enumFromTo.vs.each/enumFromTo;205700.0\r\nbenchmark/prelude-benchmarks/enumFromTo.vs.each/each;209000.0\r\nbenchmark/lift-benchmarks/ReaderT/runReaderP_B;4791000.0\r\nbenchmark/lift-benchmarks/ReaderT/runReaderP_A;266600.0\r\nbenchmark/lift-benchmarks/StateT/runStateP_B;4912000.0\r\nbenchmark/lift-benchmarks/StateT/runStateP_A;344800.0\r\nbenchmark/lift-benchmarks/StateT/evalStateP_B;5534000.0\r\nbenchmark/lift-benchmarks/StateT/evalStateP_A;349400.0\r\nbenchmark/lift-benchmarks/StateT/execStateP_B;5451000.0\r\nbenchmark/lift-benchmarks/StateT/execStateP_A;324300.0\r\n```\r\n\r\n#
  Which `cabal`, `stack` and `ghc` binaries are used?\r\n\r\nShort answer: That found
  on the path at the time of executing this script.\r\n\r\nIf `cloben` is compiled
  to an executable which is then called from your shell,\r\nit will use `cabal`, `stack`
  and `ghc` binaries found on your path.\r\n\r\nIf however you prefer to run this
  as a script through `stack` (see above),\r\nnote that `stack` modifies the environment,
  so it will use a 'stack-local' version\r\nof `cabal` when `stack install cabal-install`
  happened.\r\n\r\nFinally, note that the fallback mechanism (try `stack bench`, fall
  back to `cabal sandbox init && cabal bench`)\r\nmight fail if it can't find `ghc`
  on the path.\r\n"
license-name: BSD3
