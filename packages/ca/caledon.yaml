changelog-type: ''
hash: 06aa4abe080a1a6c8b3cb61d21c491bf03d289413b62c5db0007b50aa3402a54
test-bench-deps: {}
synopsis: a logic programming language based on the calculus of constructions
changelog: ''
basic-deps:
  base: ! '>=4.0 && <5.0'
  parsec: ! '>=3.0 && <4.0'
  containers: ! '>=0.4 && <1.0'
  lens: ! '>=3.0 && <4.0'
  mtl: ! '>=2.0 && <3.0'
  cpphs: ! '>=1.0 && <2.0'
  transformers: ! '>=0.3 && <1.0'
all-versions:
- '0.0.0.0'
- '2.0.0.0'
- '2.1.0.0'
- '2.1.1.0'
- '3.0.0.0'
- '3.1.0.0'
- '3.2.0.0'
- '3.2.1.0'
latest: '3.2.1.0'
description-type: markdown
description: ! "Caledon Language ![logo](https://raw.github.com/mmirman/caledon/hopa/media/logo.png)\n====================================================================================\n\nCaledon
  is a dependently typed, polymorphic, higher order logic programming language. ie,
  everything you need to have a conversation with your computer.\n\nBackground\n----------\n\n*
  This is part of my masters thesis.  Feedback would be appreciated. Considering this,
  it is still in the very early research stages.  Syntax is liable to change, there
  will be bugs, and it doesn't yet have IO (I'm still working out how to do IO cleanly,
  but this WILL come).\n\n* It's named caledon after the \"New Caledonian Crow\" -
  a crow which can make tools and meta tools.  Since this language supports meta programming
  with holes, implicits, polymorphism, and dependent types, I thought this crow might
  be a good mascot. Also, file extensions are \".ncc\"\n\n* This language was inspired
  by twelf, haskell and agda.\n\nGoals\n-----\n\n* Make logic programming less repetative\n\n*
  A logic programming language that is good at defining DSLs\n\n* A language/system
  for conversing with the machine in a manner less one sided and instructional than
  regular programming.\n\n* Make automated theorem proving intuitive.  \n\nPhilosophies\n------------\n\n*
  Metaprogramming should be easy and thus first class.\n\n* User facing code should
  not crash - runtime code should be type checked.\n\n* Metacode should be optionally
  typechecked, but well type checked.\n\n* Metaprogramming should not require AST
  traversal.\n\n* Your programming language should be turing complete - totality checking
  is annoying.\n\n* Syntax should be elegant.\n\n* Primitives should be minimal, libraries
  should be extensive.  Learning a culture is easy if you speak the language.  Learning
  a language by cultural immersion isn't as trivial.\n\nUsage\n-----\n\n* To install
  from hackage:\n\n```\n> cabal install caledon\n```\n\n* To install directly from
  source:\n\n```\n> git clone git://github.com/mmirman/caledon.git\n> cd caledon\n>
  cabal configure\n> cabal install\n```\n\n* To run:\n\n```\n> caledon file.ncc\n```\n\n*
  Unicode syntax is possible in emacs using: \n\n```\nM-x \\ TeX <ENTER>\n```\n\nFeatures\n--------\n\n*
  Logic programming:  Currently it uses a breadth first proof search. This is done
  for completeness, since the proof search is also used in type inference.  This could
  (and should) possibly change in the future for the running semantics of the language.\n\n```\ndefn
  num  : prop\n   | zero = num\n   | succ = num -> num\n\ndefn add  : num -> num ->
  num -> prop\n   | add_zero = add zero N N\n   | add_succ = add (succ N) M (succ
  R) <- add N M R\n\n-- we can define subtraction from addition!\ndefn subtract :
  num -> num -> num -> prop\n  as \\a b c : num . add b c a\n\n```\n\n* Some basic
  IO: Using unix pipes, this Caledon can be used more seriously.  Somebody plz write
  a wrapper?\n\n```\nquery main = run $ do \n                 , putStr \"hey!\\n\"\n\t
  \ \t , readLine (\\A . do \n   \t\t , putStr A\n                 , putStr \"\\nbye!\\n\")\n```\n\n*
  Higher order logic programming: like in twelf and lambda-prolog.  This makes HOAS
  much easier to do.\n\n```\ndefn trm : prop\n   | lam = (trm -> trm) -> trm\n   |
  app = trm -> trm -> trm\n\n-- we can check that a term is linear!\ndefn linear :
  (trm → trm) → prop\n   | linear_var = linear ( λ v . v )\n   | linear_lam = {N}
  linear (λ v . lam (λ x . N x v))\n                ← [x] linear (λ v . N x v)\n   |
  linear_app1 = {V}{F} linear (λ v . app (F v) V)\n                        ← linear
  F\n   | linear_app2 = ?∀ V . ?∀ F . linear (λ v . app F (V v))\n                               ←
  linear V\n```\n\n* Calculus of Constructions:  This is now consistent, and still
  has similar expressive power!  Now any term must be terminating. Although term/proof
  search might not be\nterminating, proof search can be used to search more intelligently
  for theorems in the term language.\n\n```\ndefn maybe   : prop → prop\n   | nothing
  = maybe A\n   | just    = A → maybe A\n\ninfix 1 =:=\ndefn =:= : A -> A -> prop\n
  \  | eq = (=:=) {A = A} V V\n\ninfix 0 /\\\ndefn /\\ : prop -> prop -> prop\n   |
  and = {a : prop}{b : prop} a -> b -> a /\\ b\n\ninfixr 0 |->\ndefn |-> : [a : prop]
  [b : prop] prop\n  as \\a : prop . \\b : prop . [ha : a] b\n```\n\n* Optional Unsound
  declarations:  Embedding certain terms has never been easier!  This way you can
  create recursive type definitions such as the well known \"prop : prop\".  \n\n```\nunsound
  tm : {S : tm ty} tm S → prop\n   | ty  = tm ty\n   | ♢   = tm ty -> tm ty\n   |
  Π   = [T : tm ty] (tm T → tm T) → tm $ ♢ T\n   | lam = [T : tm ty][F : tm T → tm
  T] tm {S = ♢ T} (Π A : T . F A)\n   | raise = {T : tm ty} tm T → tm $ ♢ T\n```\n\n*
  Indulgent type inferring nondeterminism:  The entire type checking process is a
  nondeterministic search for a type check proof.  This could be massively slow, but
  at least it is complete.  The size of this search is bounded by the size of the
  types and not the whole program, so this shouldn't be too slow in practice.  (function
  cases should be small).  I'm working on adding search control primitives to make
  this more efficient.\n\n* Holes:  types can have holes, terms can have holes.  The
  same proof search that is used in semantics is used in type inference, so you can
  use the same computational reasoning you use to program to reason about whether
  the type checker can infer types!  Holes get filled by a proof search on their type
  and the current context.  Since the entire type checking process is nondeterministic,
  if they get filled by a wrong term, they can always be filled again.\n\n```\ndefn
  fsum_maybe  : (A -> B -> prop) -> maybe A -> maybe B → prop\n   | fsum_nothing =
  [F : A -> B -> prop] maybe_fsum F nothing nothing\n   | fsum_just    = [F : _ ->
  _ -> prop][av : A][bv : B]\n                   maybe_fsum F (just av) (just bv)\n
  \                  <- F av bv\n```\n\n* Implicit arguments:  These are arguments
  that automagically get filled with holes when they need to be.  They form the basis
  for typeclasses (records to be added), although they are far more general. This
  is also where the language is most modern and interesting.  I'm curious to see what
  uses beyond typeclasses there are for these.\n\n```\ndefn functor : (prop → prop)
  → prop\n   | isFunctor = ∀ F . ({a}{b : _ } (a → b → prop) → F a → F b → prop) →
  functor F.\n\ndefn fsum : {F} functor F => {a}{b} (a → b → prop) → F a → F b → prop\n
  \  | get_fsum = [F] functor F -> [FSUM][Foo][Fa][Fb] FSUM Foo Fa Fb -> fsum Foo
  Fa Fb\n\ndefn functor_maybe : functor maybe -> prop.\n   | is_functor_maybe = functor_maybe
  (isFunctor fsum_maybe).\n\n-- this syntax is rather verbose for the moment.  I have
  yet to add typeclass syntax sugar.\n```\n\n* Nondeterminism control:  You can now
  control what patterns to match against sequentially versus in concurrently.  This
  gives you massive control over program execution, and in the future might be implemented
  with REAL threads!\n\n```\ndefn runBoth : bool -> prop\n  >| run0 = runBoth A \n
  \           <- putStr \"tttt \"\n            <- A =:= true\n\n   | run1 = runBoth
  A\n            <- putStr \"vvvv\"\n            <- A =:= true\n\n   | run2 = runBoth
  A\n            <- putStr \"qqqq\"\n            <- A =:= true\n\n  >| run3 = runBoth
  A\n            <- putStr \" jjjj\"\n            <- A =:= false\n\nquery main = runBoth
  false\n\n-- main should print out something along the lines of \"tttt vvqvqvqq jjjj\"\n```\n\n\n*
  Arbitrary operator fixities:  combined with the calculus of constructions, you can
  nearly do agda style syntax (with a bit of creativity)!\n\n```\ndefn bool : prop\n
  \  | true = bool\n   | false = bool\n\ndefn if : bool -> bool\n  as \\b . b\n\ninfix
  1 |:|\ndefn |:| : {a : prop} a -> a -> (a -> a -> a) -> a\n  as ?\\t : prop . \\a
  b. \\f : t -> t -> t. f a b\n\ninfix 0 ==>\ndefn ==> : {a : prop} bool -> ((a ->
  a -> a) -> a) -> a -> prop\n   | thentrue =  [f : _ -> A] (true ==> f)  (f (\\a
  b : A. a))\n   | thenfalse = [f : _ -> A] (false ==> f) (f (\\a b : A. b))\n\ndefn
  not : bool -> bool -> prop\n  as \\v . if v ==> false |:| true\n\n```\n\n* Optional
  unicode syntax: Monad m ⇒ ∀ t : goats . m (λ x : t . t → t).\n    * implication
  :  \"a -> b\"  or \"a → b\" or \"a <- b\"  or \"a ← b\"\n    * implicits:  \"a =>
  b\"  or \"a ⇒ b\" or \"a <= b\"  or \"a ⇐ b\"\n    * Quantification: \"[x:A] t\"
  \ or  \"∀ x:A . t\" or \"forall x:A . t\"\n    * abstraction: \"λ x . t\" or \"\\x.t\"\n
  \   * Quantified implicits: \"{x:A} t\"  or  \"?∀ x:A . t\" or \"?forall x:A . t\"\n
  \   * implicit abstraction: \"?λ x . t\" or \"?\\x.t\"\n\n\n\nPrimary Contributers\n--------------------\n\n*
  Author: Matthew Mirman\n\n* Advisor: Frank Pfenning\n\nSecondary Contributers\n----------------------\n\n*
  Samuel Gélineau (gelisam)\n\n* Devin Nusbaum (el-devo)\n\n\n"
