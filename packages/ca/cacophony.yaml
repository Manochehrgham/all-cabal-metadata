homepage: https://github.com/centromere/cacophony
changelog-type: markdown
hash: 9af4e79de2199a3e45536615e01fd13062540ddbd354edcce1fede39eb1bdc95
test-bench-deps:
  hlint: -any
  bytestring: -any
  base: ! '>=4.8 && <5'
  criterion: -any
  cacophony: -any
  async: -any
  tasty-quickcheck: -any
  mtl: -any
  tasty: -any
  deepseq: -any
  QuickCheck: -any
maintainer: jgalt@centromere.net
synopsis: A library implementing the Noise protocol.
changelog: ! "# 0.6.0\n\n* Added ability to abort handshakes based on the remote party's
  public key\n\n* Improved documentation\n\n* Factored out ScrubbedBytes utilities
  to separate module\n\n* Added echo-server and echo-client example\n\n* Renamed HandshakeStateParams
  to HandshakeOpts\n\n# 0.5.0\n\n* Added Curve448 support\n\n* Major refactoring and
  API changes\n  A DSL was created to represent handshake patterns.\n\n* Added GHC
  7.10.3 to unit tests\n\n# 0.4.0\n\n* Improved documentation\n\n* Added basic benchmarks\n\n*
  Added better exception handling\n\n* Improved handshakeState API\n\n* Added psk2
  functionality\n\n* Unit test cleanup\n\n* Renamed symmetricHandshake to symmetricState\n\n*
  Added BLAKE2, SHA512, AESGCM support\n\n# 0.3.0\n\n* Brought API up to date with
  current version of spec (17)\n\n# 0.2.0\n\n* Added support for one-way handshakes\n\n*
  Fixed Noise\\_IX\n\n* Added helper functions for ScrubbedBytes / ByteString conversion\n\n#
  0.1.0.0\n\n* First version.\n"
basic-deps:
  free: -any
  bytestring: -any
  base: ! '>=4.8 && <5'
  memory: -any
  lens: -any
  cryptonite: ! '>=0.13'
  mtl: -any
  deepseq: -any
all-versions:
- '0.5.0'
- '0.6.0'
author: John Galt
latest: '0.6.0'
description-type: markdown
description: ! "# cacophony\n\n[![Build Status](https://travis-ci.org/centromere/cacophony.svg?branch=master)](https://travis-ci.org/centromere/cacophony)\n[![Haskell](http://b.repl.ca/v1/language-haskell-blue.png)](http://www.haskell.org)\n\nThis
  library implements the [Noise](https://github.com/trevp/noise/blob/master/noise.md)
  protocol.\n\n## Basic usage\n\n1. Import the modules for the kind of handshake you'd
  like to use.\n\n   For example, if you want to use `Noise_IK_25519_AESGCM_SHA256`,
  your imports would be:\n   ```haskell\n   import Crypto.Noise.Cipher.AESGCM\n   import
  Crypto.Noise.Curve.Curve25519\n   import Crypto.Noise.Hash.SHA256\n   import Crypto.Noise.Handshake\n
  \  import Crypto.Noise.HandshakePatterns (noiseIK)\n   ```\n\n2. Define the functions
  that will be called during various stages of the handshake.\n   ```haskell\n   writeMsg
  \  :: ByteString -> IO ()\n   readMsg    :: IO ByteString\n   payloadIn  :: Plaintext
  -> IO ()\n   payloadOut :: IO Plaintext\n   staticIn   :: PublicKey d -> IO Bool\n
  \  ```\n\n   `writeMsg` and `readMsg` will typically be functions that write to
  and read from a socket.\n\n   The `payloadIn` and `payloadOut` functions are called
  when payloads are received and needed.\n\n   The `staticIn` function is called when
  a static key is received from the remote peer.\n   If this function returns `False`,
  the handshake is immediately aborted. Otherwise, it\n   continues normally. See
  the documentation of `HandshakeCallbacks` for details.\n\n   If you don't need to
  use payloads and want to accept all remote static keys, do the following:\n   ```haskell\n
  \  let hc = HandshakeCallbacks (writeMsg socket)\n                                (readMsg
  socket)\n                                (\\_ -> return ())\n                                (return
  \"\")\n                                (\\_ -> return True)\n   ```\n\n3. Create
  the handshake state.\n\n   Select a handshake pattern to use. Patterns are defined
  in the `Crypto.Noise.HandshakePatterns` module.\n   Ensure that you provide the
  keys which are required by the handshake pattern you choose. For example,\n   the
  `Noise_IK` pattern requires that the initiator provides a local static key and a
  remote static key.\n   Remote keys are communicated out-of-band.\n   ```haskell\n
  \  let initiatorState = handshakeState $ HandshakeOpts\n      noiseIK\n      \"prologue\"\n
  \     (Just \"pre-shared-key\")\n      (Just local_static_key)\n      Nothing                  --
  local ephemeral key\n      (Just remote_static_key) -- communicated out-of-band\n
  \     Nothing                  -- remote ephemeral key\n      True                     --
  we are the initiator\n   ```\n\n   ```haskell\n   let responderState = handshakeState
  $ HandshakeOpts\n      noiseIK\n      \"prologue\"\n      (Just \"pre-shared-key\")\n
  \     (Just local_static_key)\n      Nothing -- local ephemeral key\n      Nothing
  -- we don't know their static key yet\n      Nothing -- remote ephemeral key\n      False
  \  -- we are the responder\n   ```\n\n4. Run the handshake:\n   ```haskell\n   (encryptionCipherState,
  decryptionCipherState) <- runHandshake initiatorState hc\n   ```\n\n   ```haskell\n
  \  (encryptionCipherState, decryptionCipherState) <- runHandshake responderState
  hc\n   ```\n\n5. Send and receive transport messages:\n   ```haskell\n   let (cipherText,
  encryptionCipherState') = encryptPayload \"hello world\" encryptionCipherState\n
  \  ```\n\n   ```haskell\n   let (Plaintext pt, decryptionCipherState') = decryptPayload
  msg decryptionCipherState\n   ```\n\n   Ensure that you never re-use a cipher state.\n\n##
  Example code\n\nAn echo-server and echo-client are located within the `examples/`
  directory. The binary protocol is as follows:\n```\nC -> S: [pattern byte] [cipher
  byte] [curve byte] [hash byte]\nC -> S: [num bytes (uint16 big endian)] [message]\nS
  -> C: [num bytes (uint16 big endian)] [message]\n...\n```\n\n`message` is any raw
  Noise handshake or message data.\n\n### Byte definitions\n\n| byte | pattern | cipher
  \    | curve | hash    |\n|------|---------|------------|-------|---------|\n| 0
  \   | NN      | ChaChaPoly | 25519 | SHA256  |\n| 1    | KN      | AESGCM     |
  448   | SHA512  |\n| 2    | NK      |            |       | BLAKE2s |\n| 3    | KK
  \     |            |       | BLAKE2b |\n| 4    | NX      |            |       |
  \        |\n| 5    | KX      |            |       |         |\n| 6    | XN      |
  \           |       |         |\n| 7    | IN      |            |       |         |\n|
  8    | XK      |            |       |         |\n| 9    | IK      |            |
  \      |         |\n| a    | XX      |            |       |         |\n| b    |
  IX      |            |       |         |\n| c    | XR      |            |       |
  \        |\n"
license-name: PublicDomain
