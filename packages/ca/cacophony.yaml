homepage: https://github.com/centromere/cacophony
changelog-type: markdown
hash: 3e99fce03d24d0d1feb696dec7e5a1360f512a0e6d7334f5d1e97efee0594d0a
test-bench-deps:
  hlint: -any
  bytestring: -any
  base: ! '>=4.8 && <5'
  filepath: -any
  criterion: -any
  cacophony: -any
  async: -any
  doctest: -any
  tasty-quickcheck: -any
  mtl: -any
  tasty: -any
  deepseq: -any
  QuickCheck: -any
  directory: -any
maintainer: jgalt@centromere.net
synopsis: A library implementing the Noise protocol.
changelog: ! "# 0.5.0\n\n* Added Curve448 support\n\n* Major refactoring and API changes\n
  \ A DSL was created to represent handshake patterns.\n\n* Added GHC 7.10.3 to unit
  tests\n\n# 0.4.0\n\n* Improved documentation\n\n* Added basic benchmarks\n\n* Added
  better exception handling\n\n* Improved handshakeState API\n\n* Added psk2 functionality\n\n*
  Unit test cleanup\n\n* Renamed symmetricHandshake to symmetricState\n\n* Added BLAKE2,
  SHA512, AESGCM support\n\n# 0.3.0\n\n* Brought API up to date with current version
  of spec (17)\n\n# 0.2.0\n\n* Added support for one-way handshakes\n\n* Fixed Noise\\_IX\n\n*
  Added helper functions for ScrubbedBytes / ByteString conversion\n\n# 0.1.0.0\n\n*
  First version.\n"
basic-deps:
  free: -any
  bytestring: -any
  base: ! '>=4.8 && <5'
  memory: -any
  lens: -any
  cryptonite: ! '>=0.13'
  mtl: -any
all-versions:
- '0.5.0'
author: John Galt
latest: '0.5.0'
description-type: markdown
description: ! "# cacophony\n\n[![Build Status](https://travis-ci.org/centromere/cacophony.svg?branch=master)](https://travis-ci.org/centromere/cacophony)\n[![Haskell](http://b.repl.ca/v1/language-haskell-blue.png)](http://www.haskell.org)\n\nThis
  library implements the [Noise](https://github.com/trevp/noise/blob/master/noise.md)
  protocol.\n\n## Basic usage\n\n1. Define functions which will be called when protocol
  messages are to be read and written to the remote peer.\n   The payloadIn and payloadOut
  functions are called when payloads are received and needed.\n   ```haskell\n   writeMsg
  \  :: ByteString -> IO ()\n   readMsg    :: IO ByteString\n   payloadIn  :: Plaintext
  -> IO ()\n   payloadOut :: IO Plaintext\n   -- If you don't need to use payloads,
  do the following:\n   let hc = HandshakeCallbacks (writeMsg socket)\n                                (readMsg
  socket)\n                                (\\_ -> return ())\n                                (return
  \"\")\n   ```\n\n2. Create the handshake state:\n   Select a handshake pattern to
  use. Patterns are defined in the Crypto.Noise.HandshakePatterns module.\n   Ensure
  that you provide the keys which are required by the handshake pattern you choose.
  For example,\n   the Noise\\_IK pattern requires that the initiator provides a local
  static key and a remote static key.\n   Remote keys are communicated out-of-band.\n
  \  ```haskell\n   let hs = handshakeState $ HandshakeStateParams\n      noiseIK\n
  \     \"\"\n      -- ^ Prologue\n      (Just \"foo\")\n      -- ^ Pre-shared key\n
  \     (Just initStatic)\n      -- ^ Local static key\n      Nothing\n      -- ^
  Local ephemeral key\n      (Just (snd respStatic))\n      -- ^ Remote static key\n
  \     Nothing\n      -- ^ Remote ephemeral key\n      True\n      -- ^ True if we
  are initiator\n   ```\n\n3. Run the handshake:\n   ```haskell\n   (encryptionCipherState,
  decryptionCipherState) <- runHandshake hs hc\n   ```\n\n4. Send and receive transport
  messages:\n   ```haskell\n   let (cipherText, encryptionCipherState') = encryptPayload
  \"hello world\" encryptionCipherState\n   let (Plaintext pt, decryptionCipherState')
  = decryptPayload msg decryptionCipherState\n   ```\n   Ensure that you never re-use
  a cipher state with encryptPayload and decryptPayload.\n"
license-name: PublicDomain
