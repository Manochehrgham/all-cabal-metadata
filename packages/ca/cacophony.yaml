homepage: https://github.com/centromere/cacophony
changelog-type: markdown
hash: 8cb10a286961711010bc3c55f85041033fe59c23df906cee750361fd6c40caec
test-bench-deps:
  free: -any
  hlint: -any
  bytestring: -any
  base: ! '>=4.8 && <5'
  text: -any
  criterion: -any
  cacophony: -any
  async: -any
  lens: -any
  mtl: -any
  base16-bytestring: -any
  deepseq: -any
  aeson: -any
  directory: -any
maintainer: jgalt@centromere.net
synopsis: A library implementing the Noise protocol.
changelog: ! "# 0.8.0\n\n* Exceptions are now provided by the safe-exceptions package\n
  \ (breaking API change)\n\n* Added Noise\\_XXfallback pattern\n\n* Minor improvements
  to handshake pattern definition\n\n* Updated non-standard handshake patterns to
  conform with rev 30\n\n* Fixed bug which caused echo-server to read wrong public
  key\n\n# 0.7.0\n\n* Major API overhaul and refactoring\n\n* Added test vector support\n\n*
  Added secondary symmetric key support\n\n* Added GHC 8.0.2 to unit tests\n\n* Removed
  Noise\\_XR\n\n* General code cleanup and other minor tweaks\n\n# 0.6.0\n\n* Added
  ability to abort handshakes based on the remote party's public key\n\n* Improved
  documentation\n\n* Factored out ScrubbedBytes utilities to separate module\n\n*
  Added echo-server and echo-client example\n\n* Renamed HandshakeStateParams to HandshakeOpts\n\n#
  0.5.0\n\n* Added Curve448 support\n\n* Major refactoring and API changes\n  A DSL
  was created to represent handshake patterns.\n\n* Added GHC 7.10.3 to unit tests\n\n#
  0.4.0\n\n* Improved documentation\n\n* Added basic benchmarks\n\n* Added better
  exception handling\n\n* Improved handshakeState API\n\n* Added psk2 functionality\n\n*
  Unit test cleanup\n\n* Renamed symmetricHandshake to symmetricState\n\n* Added BLAKE2,
  SHA512, AESGCM support\n\n# 0.3.0\n\n* Brought API up to date with current version
  of spec (17)\n\n# 0.2.0\n\n* Added support for one-way handshakes\n\n* Fixed Noise\\_IX\n\n*
  Added helper functions for ScrubbedBytes / ByteString conversion\n\n# 0.1.0.0\n\n*
  First version.\n"
basic-deps:
  exceptions: ! '>=0.8.3'
  free: -any
  bytestring: -any
  base: ! '>=4.8 && <5'
  safe-exceptions: -any
  monad-coroutine: -any
  memory: -any
  lens: -any
  cryptonite: ! '>=0.16'
  mtl: -any
  transformers: -any
  deepseq: -any
all-versions:
- '0.7.0'
- '0.8.0'
author: John Galt
latest: '0.8.0'
description-type: markdown
description: ! "# cacophony\n\n[![Build Status](https://travis-ci.org/centromere/cacophony.svg?branch=master)](https://travis-ci.org/centromere/cacophony)\n[![Haskell](http://b.repl.ca/v1/language-haskell-blue.png)](http://www.haskell.org)\n\nThis
  library implements the [Noise](https://github.com/noiseprotocol/noise_spec/blob/master/noise.md)
  protocol.\n\n## Basic usage\n\n1. Import the modules for the kind of handshake you'd
  like to use.\n\n   For example, if you want to use `Noise_IK_25519_AESGCM_SHA256`,
  your imports would be:\n   ```haskell\n   import Control.Lens\n\n   import Crypto.Noise\n
  \  import Crypto.Noise.Cipher.AESGCM\n   import Crypto.Noise.DH\n   import Crypto.Noise.DH.Curve25519\n
  \  import Crypto.Noise.Hash.SHA256\n   import Crypto.Noise.HandshakePatterns (noiseIK)\n
  \  ```\n\n2. Set the handshake parameters.\n\n   Select a handshake pattern to use.
  Patterns are defined in the `Crypto.Noise.HandshakePatterns` module.\n   Ensure
  that you provide the keys which are required by the handshake pattern you choose.
  For example,\n   the `Noise_IK` pattern requires that the initiator provides a local
  static key and a remote static key,\n   while the responder is only responsible
  for a local static key. You can use `defaultHandshakeOpts` to\n   return a default
  set of options in which the prologue is an empty string, PSKs are disabled, and
  all\n   keys are set to `Nothing`. You must set the local ephemeral key for all
  handshake patterns, and it\n   should never be reused.\n\n   Functions for manipulating
  DH keys can be found in the `Crypto.Noise.DH` module.\n\n   ```haskell\n   -- Initiator\n
  \  local_ephemeral_key <- dhGenKey :: IO (KeyPair Curve25519)\n\n   let dho = defaultHandshakeOpts
  noiseIK InitiatorRole :: HandshakeOpts Curve25519\n        iho = dho & hoPrologue
  \      .~ \"prologue\"\n                  & hoPreSharedKey   .~ Just pre_shared_key\n
  \                 & hoLocalStatic    .~ Just local_static_key\n                  &
  hoLocalEphemeral .~ Just local_ephemeral_key\n                  & hoRemoteStatic
  \  .~ Just remote_static_key -- communicated out-of-band\n\n   -- Responder\n   local_ephemeral_key
  <- dhGenKey :: IO (KeyPair Curve25519)\n\n   let dho = defaultHandshakeOpts noiseIK
  ResponderRole :: HandshakeOpts Curve25519\n        rho = dho & hoPrologue       .~
  \"prologue\"\n                  & hoPreSharedKey   .~ Just pre_shared_key\n                  &
  hoLocalStatic    .~ Just local_static_key\n                  & hoLocalEphemeral
  .~ Just local_ephemeral_key\n   ```\n\n3. Create the Noise state.\n   ```haskell\n
  \  -- Initiator\n   let ins = noiseState iho :: NoiseState AESGCM Curve25519 SHA256\n\n
  \  -- Responder\n   let rns = noiseState rho :: NoiseState AESGCM Curve25519 SHA256\n
  \  ```\n\n4. Send and receive messages.\n   ```haskell\n   -- Initiator\n   let
  writeResult         = writeMessage ins \"They must find it difficult -- those who
  have taken authority as the truth, rather than truth as the authority.\"\n        (ciphertext,
  ins')  = either (error \"something terrible happened\") id writeResult\n\n   --
  Responder\n   let readResult          = readMessage rns ciphertext\n        (plaintext,
  rns')   = either (error \"something terrible happened\") id readResult\n   ```\n\n
  \  **Ensure that you never re-use a noise state to send more than one message.**\n\n
  \  Decrypted messages are stored internally as `ScrubbedBytes` and will be wiped
  from memory when they are\n   destroyed. Helper functions for dealing with `ScrubbedBytes`
  can be found in the `Data.ByteArray.Extend` module.\n\n### Helper functions\n\nThe
  following functions are found in `Crypto.Noise` and can be helpful when designing
  an application which uses\nNoise:\n\n  * `remoteStaticKey` -- For handshake patterns
  where the remote party's static key is transmitted, this function\n    can be used
  to retrieve it. This allows for the creation of public key-based access-control
  lists.\n\n  * `handshakeComplete` -- Returns `True` if the handshake is complete.\n\n
  \ * `handshakeHash` -- Retrieves the `h` value associated with the conversation's
  SymmetricState. This value is\n    intended to be used for channel binding. For
  example, the initiator might cryptographically sign this value\n    as part of some
  higher-level authentication scheme. See section 9.4 of the protocol for details.\n\n
  \ * `setSecondaryKey` -- Sets a secondary symmetric key as described in section
  9.5 of the protocol.\n\n## Vectors\n\nTest vectors can be generated and verified
  using the `vectors` program. It accepts no arguments. When run,\nit will check for
  the existence of `vectors/cacophony.txt` within the current working directory. If
  it is not\nfound, it is generated. If it is found, it is verified. All files within
  the `vectors/` directory (regardless\nof their name) are also verified.\n\nThe generated
  vectors are minified JSON. There is a small python script within the `tools/` directory
  that\nformats the JSON-blob in to something more readable.\n\n## Example code\n\nAn
  echo-server and echo-client are located within the `examples/` directory. The binary
  protocol they use to\ncommunicate is as follows:\n```\nC -> S: [psk byte] [pattern
  byte] [cipher byte] [dh byte] [hash byte]\nC -> S: [num message bytes (uint16 big
  endian)] [message]\nS -> C: [num message bytes (uint16 big endian)] [message]\n...\n```\n\nwhere
  `message` is any raw Noise handshake or message data.\n\nThe prologue is set to
  the 5 header bytes to prevent a MITM attack.\n\nFor these example programs, the
  server chooses the value of the PSK, and the client chooses whether or not\nto use
  a PSK-enabled handshake. Both the server and client expect the PSK file to be base64
  encoded. One\nway to generate the PSK file is as follows:\n```\nhead -c 32 /dev/random
  | base64 > psk\n```\n\nTo include these examples in your build, pass the `-fbuild-examples`
  flag to Cabal.\n\n### Byte definitions\n\n| byte | psk      | pattern | cipher     |
  dh    | hash    |\n|------|----------|---------|------------|-------|---------|\n|
  0x00 | disabled | NN      | ChaChaPoly | 25519 | SHA256  |\n| 0x01 | enabled  |
  KN      | AESGCM     | 448   | SHA512  |\n| 0x02 |          | NK      |            |
  \      | BLAKE2s |\n| 0x03 |          | KK      |            |       | BLAKE2b |\n|
  0x04 |          | NX      |            |       |         |\n| 0x05 |          |
  KX      |            |       |         |\n| 0x06 |          | XN      |            |
  \      |         |\n| 0x07 |          | IN      |            |       |         |\n|
  0x08 |          | XK      |            |       |         |\n| 0x09 |          |
  IK      |            |       |         |\n| 0x0a |          | XX      |            |
  \      |         |\n| 0x0b |          | IX      |            |       |         |\n"
license-name: PublicDomain
