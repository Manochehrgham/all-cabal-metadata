changelog-type: ''
hash: f022d9401bba3a5a924ba9caf820347f43ada40d4136f85c8d0ac74fc3e97ae4
synopsis: A template for building new GUI applications using GTK and Cairo.
changelog: ''
all-versions:
- '0.2'
- '0.3'
- '0.4'
latest: '0.4'
description-type: haddock
description: ! 'This template includes working callbacks to handle the File and Help

  menus and File Save/Open dialogs, with dummy handlers for selecting

  filenames and the Edit menu''s Cut, Copy, and Paste. The main canvas uses

  Cairo for graphics rendering, and includes example code from the cairo

  package.


  To build your own application on top of this, first grab the code. You

  can either grab it from hackage with @cabal unpack cairo-appbase@, or

  clone the git repo:


  >   git clone git://github.com/kfish/cairo-appbase.git


  To add widgets, install glade from your distro system and run

  @glade data/main.ui@. Save the resulting file in GtkBuilder format.


  Note that you must run @cabal install@ to put the UI file in the correct

  place for your application to pick it up. To modify the code, edit

  @src/cairo-appbase.hs@. Hooking up functions to widgets is very simple: get

  a widget by name (which you set in ui file), and hook one of its

  signals (which you found in the Signals tab in glade) to an @IO ()@ action:


  > cut1 <- get G.castToMenuItem "cut1"

  > G.onActivateLeaf cut1 $ myCut


  The template code includes a trivial definition of myCut:


  > myCut :: IO ()

  > myCut = putStrLn "Cut"


  A real application will want to pass data to the callback. In C, this is

  fairly tedious as you only have a single void * to pass to callbacks as

  @user_data@, and applications typically do lots of marshalling and

  unmarshalling to pass data around. In Haskell however, you can make

  yourself a more complex callback handler and use a curried version of it

  in each instance:


  > cut1 <- get G.castToMenuItem "cut1"

  > G.onActivateLeaf cut1 $ myComplexCut project phase 7

  >

  > ...

  >

  > myCut :: Project -> MoonPhase -> LuckyNumber -> IO ()

  > myCut project phase num = do

  >     let selection = currentSelection project

  >     when (phase == Full) howl

  >     when (num /= 7) fail

  >     doActualCut selection

'
