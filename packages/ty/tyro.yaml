homepage: https://github.com/rlupton20/tyro#readme
changelog-type: ''
hash: fc01e99d9126f8100b61838d74fbfeed75c3509cdeaa27b9ad6f93dac13443d9
test-bench-deps:
  test-framework-hunit: -any
  test-framework: -any
  base: -any
  text: -any
  tyro: -any
  protolude: ! '>=0.1.6 && <0.2'
  HUnit: -any
  aeson: -any
maintainer: example@example.com
synopsis: Type derived JSON parsing using Aeson
changelog: ''
basic-deps:
  bytestring: -any
  reflection: -any
  base: ! '>=4.9 && <5'
  text: -any
  protolude: ! '>=0.1.6 && <0.2'
  singletons: -any
  aeson: -any
all-versions:
- '0.1.1.0'
- '0.1.1.1'
- '0.2.0.0'
author: Richard Lupton
latest: '0.2.0.0'
description-type: markdown
description: ! '# tyro


  `tyro` is a dependently type JSON parsing library, that provides a quick way to
  create JSON parsers by deriving them from a type level description of the position
  of the value to be obtained.


  ## Examples


  ### Type driven interface


  ```Haskell

  {-# LANGUAGE OverloadedStrings #-}

  {-# LANGUAGE DataKinds #-}

  {-# LANGUAGE TypeOperators #-}


  import Data.Tyro

  import Data.Aeson (decode)

  import qualified Data.ByteString.Lazy as B


  json = "{\"key1\":[{\"key2\":41},{\"key2\":42}]}" :: B.ByteString


  -- Extract [41, 42] inside the Tyro types

  parsed = decode json :: Maybe ("key1" >%> List ("key2" >%> Extract Integer))


  -- We can dispose of the types using unwrap

  values :: Maybe [Integer]

  values = fmap unwrap parsed

  ```


  ### Value driven interface


  ```Haskell

  {-# LANGUAGE OverloadedStrings #-}

  import Data.Tyro


  json = "{\"key1\": {\"key2\" :  [41, 42]}}" :: B.ByteString


  -- Extract [41, 42] inside the JSON

  parsed = json %%> "key1" >%> "key2" >%> extract :: Maybe [Integer]

  ```'
license-name: BSD3
