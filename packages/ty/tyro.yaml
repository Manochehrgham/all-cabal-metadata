homepage: https://github.com/rlupton20/tyro#readme
changelog-type: ''
hash: d02b0cdc39a8c45e575b5ee06071f2230c457ef0c770dc161ef954c9c1f2c8fc
test-bench-deps:
  test-framework-hunit: -any
  test-framework: -any
  base: -any
  text: -any
  tyro: -any
  protolude: ! '>=0.1.6 && <0.2'
  HUnit: -any
  aeson: -any
maintainer: example@example.com
synopsis: Type derived JSON parsing using Aeson
changelog: ''
basic-deps:
  base: ! '>=4.9 && <5'
  text: -any
  protolude: ! '>=0.1.6 && <0.2'
  singletons: -any
  aeson: -any
all-versions:
- '0.1.1.0'
- '0.1.1.1'
author: Richard Lupton
latest: '0.1.1.1'
description-type: markdown
description: ! '# tyro


  `tyro` is a dependently type JSON parsing library, that provides a quick way to
  create JSON parsers by deriving them from a type level description of the position
  of the value to be obtained.


  ## Example


  ```Haskell

  {-# LANGUAGE OverloadedStrings #-}

  {-# LANGUAGE DataKinds #-}

  {-# LANGUAGE TypeOperators #-}


  import Data.Tyro

  import Data.Aeson (decode)

  import Data.Text (Text)


  json = "{\"key1\":[{\"key2\":41},{\"key2\":42}]}" :: Text


  -- Extract [41, 42] inside the Tyro types

  parsed = decode json :: Maybe ("key1" |>| List ("key2" |>| Parse Integer))


  -- We can dispose of the types using unwrap

  values :: Maybe [Integer]

  values = fmap unwrap parsed

  ```

'
license-name: BSD3
