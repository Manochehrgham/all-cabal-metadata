homepage: https://github.com/oisdk/type-indexed-queues
changelog-type: ''
hash: c4c2b693ffa6071f01f7df8d2ab8ba1e581c0c1f190534debb631951424a5753
test-bench-deps:
  base: ! '>=4.8'
  criterion: ! '>=0.6'
  doctest: -any
  pqueue: ! '>=1.3'
  containers: ! '>=0.5'
  type-indexed-queues: -any
  tasty-quickcheck: ! '>=0.8'
  random: ! '>=1.1'
  tasty: ! '>=0.11'
  QuickCheck: ! '>=2.8'
maintainer: mail@doisinkidney.com
synopsis: Queues with verified and unverified versions.
changelog: ''
basic-deps:
  base: ! '>=4.7 && <5'
  ghc-typelits-natnormalise: ! '>=0.5'
  containers: ! '>=0.5'
  deepseq: ! '>=1.4'
all-versions:
- '0.1.0.0'
author: Donnacha OisÃ­n Kidney
latest: '0.1.0.0'
description-type: markdown
description: ! "# type-indexed-heaps\n## Heaps with verified and unverified versions.\n\n[![Build
  Status](https://travis-ci.com/oisdk/type-indexed-heaps.svg?token=fXdGpZwjFQ87pr9zynKX&branch=master)](https://travis-ci.com/oisdk/type-indexed-heaps)\n\nThis
  library provides implementations of five different heaps\n(binomial, pairing, skew,
  leftist, and Braun), each in two\nflavours: one verified, and one not.\n\nAt the
  moment, only structural invariants are maintained.\n\n## Comparisons of verified
  and unverified heaps\nBoth versions of each heap are provided for comparison: for\ninstance,
  compare the standard leftist heap (in\nData.Heap.Leftist):\n\n```haskell\ndata Leftist
  a\n  = Leaf\n  | Node !Int\n        a\n        (Leftist a)\n        (Leftist a)\n```\n\nTo
  its size-indexed counterpart (in Data.Heap.Indexed.Leftist):\n\n```haskell\ndata
  Leftist n a where\n        Leaf :: Leftist 0 a\n        Node :: !(The Nat (n + m
  + 1))\n             -> a\n             -> Leftist n a\n             -> Leftist m
  a\n             -> !(m <= n)\n             -> Leftist (n + m + 1) a\n```\n\nThe
  invariant here (that the size of the left heap must\nalways be less than that of
  the right) is encoded in the\nproof `m <= n`.\n \nWith that in mind, compare the
  unverified and verified\nimplementatons of `merge`:\n\n```haskell\nmerge Leaf h2
  = h2\nmerge h1 Leaf = h1\nmerge h1@(Node w1 p1 l1 r1) h2@(Node w2 p2 l2 r2)\n  |
  p1 < p2 =\n      if ll <= lr\n          then Node (w1 + w2) p1 l1 (merge r1 h2)\n
  \         else Node (w1 + w2) p1 (merge r1 h2) l1\n  | otherwise =\n      if rl
  <= rr\n          then Node (w1 + w2) p2 l2 (merge r2 h1)\n          else Node (w1
  + w2) p2 (merge r2 h1) l2\n  where\n    ll = rank r1 + w2\n    lr = rank l1\n    rl
  = rank r2 + w1\n    rr = rank l2\n```\n\nVerified:\n\n```haskell\nmerge Leaf h2
  = h2\nmerge h1 Leaf = h1\nmerge h1@(Node w1 p1 l1 r1 _) h2@(Node w2 p2 l2 r2 _)\n
  \ | p1 < p2 =\n      if ll <=. lr\n        then Node (w1 +. w2) p1 l1 (merge r1
  h2)\n        else Node (w1 +. w2) p1 (merge r1 h2) l1 . totalOrder ll lr\n  | otherwise
  =\n      if rl <=. rr\n          then Node (w1 +. w2) p2 l2 (merge r2 h1)\n          else
  Node (w1 +. w2) p2 (merge r2 h1) l2 . totalOrder rl rr\n  where\n    ll = rank r1
  +. w2\n    lr = rank l1\n    rl = rank r2 +. w1\n    rr = rank l2\n```\n\n## Using
  type families and typechecker plugins to encode the invariants\nThe similarity is
  accomplished through overloading, and some\nhandy functions. For instance, the second
  if-then-else works\non boolean *singletons*, and the `<=.` function provides a\nproof
  of order along with its answer. The actual arithmetic\nis carried out at runtime
  on normal integers, rather than\nPeano numerals. These tricks are explained in more
  detail\nTypeLevel.Singletons and TypeLevel.Bool.\n\nA typechecker plugin does most
  of the heavy lifting, although\nthere are some (small) manual proofs.\n\n## Uses
  of verified heaps\nThe main interesting use of these sturctures is total traversable\nsorting
  ([sort-traversable](https://github.com/treeowl/sort-traversable)).\nAn implementation
  of this is provided in Data.Traversable.Sort. I'm\ninterested in finding out other
  uses for these kinds of structures.\n"
license-name: MIT
