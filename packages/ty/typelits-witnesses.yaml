homepage: https://github.com/mstksg/typelits-witnesses
changelog-type: ''
hash: 0453616d2d947af345493eb1d0c7b97d681c86d69d173cbe15f92f1b4f9829c5
test-bench-deps: {}
maintainer: justin@jle.im
synopsis: Existential witnesses, singletons, and classes for operations on GHC TypeLits
changelog: ''
basic-deps:
  reflection: -any
  base: ! '>=4.8 && <5'
  constraints: -any
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.1.1.0'
- '0.1.2.0'
author: Justin Le
latest: '0.1.2.0'
description-type: markdown
description: ! "typelits-witnesses\n==================\n\n[![typelits-witnesses on
  Stackage LTS 2](http://stackage.org/package/typelits-witnesses/badge/lts-2)](http://stackage.org/lts-2/package/typelits-witnesses)\n[![typelits-witnesses
  on Stackage LTS 3](http://stackage.org/package/typelits-witnesses/badge/lts-3)](http://stackage.org/lts-3/package/typelits-witnesses)\n[![typelits-witnesses
  on Stackage LTS 4](http://stackage.org/package/typelits-witnesses/badge/lts-4)](http://stackage.org/lts-4/package/typelits-witnesses)\n[![typelits-witnesses
  on Stackage LTS](http://stackage.org/package/typelits-witnesses/badge/lts)](http://stackage.org/lts/package/typelits-witnesses)\n[![typelits-witnesses
  on Stackage Nightly](http://stackage.org/package/typelits-witnesses/badge/nightly)](http://stackage.org/nightly/package/typelits-witnesses)\n\n\nProvides
  witnesses for `KnownNat` and `KnownSymbol` instances for various\noperations on
  GHC TypeLits --- in particular, the arithmetic operations\ndefined in `GHC.TypeLits`,
  and also for type-level lists of `KnownNat` and\n`KnownSymbol` instances.\n\nThis
  is useful for situations where you have `KnownNat n`, and you want to\nprove to
  GHC `KnownNat (n + 3)`, or `KnownNat (2*n + 4)`.\n\nIt's also useful for when you
  want to work with type level lists of\n`KnownNat`/`KnownSymbol` instances and singletons
  for traversing them, and be\nable to apply analogies of `natVal`/`symbolVal` to
  lists with analogies for\n`SomeNat` and `SomeSymbol`.\n\n`GHC.TypeLits.Witnesses`\n------------------------\n\nProvides
  witnesses for instances arising from the arithmetic operations\ndefined in `GHC.TypeLits`.\n\nIn
  general, if you have `KnownNat n`, GHC can't infer `KnownNat (n + 1)`;\nand if you
  have `KnownNat m`, as well, GHC can't infer `KnownNat (n + m)`.\n\nThis can be extremely
  annoying when dealing with libraries and applications\nwhere one regularly adds
  and subtracts type-level nats and expects `KnownNat`\ninstances to follow.  For
  example, vector concatenation of length-encoded\nvector types can be:\n\n~~~haskell\nconcat
  :: (KnownNat n, KnownNat m)\n       => Vector n       a\n       -> Vector m       a\n
  \      -> Vector (n + m) a\n~~~\n\nBut, `n + m` now does not have a `KnownNat` instance,
  which severely hinders\nwhat you can do with this!\n\nConsider this concrete (but
  silly) example:\n\n~~~haskell\ngetDoubled :: KnownNat n => Proxy n -> Integer\ngetDoubled
  p = natVal (Proxy :: Proxy (n * 2))\n~~~\n\nWhich is supposed to call `natVal` with
  `n * 2`.  However, this fails, because\nwhile `n` is a `KnownNat`, `n * 2` is not
  necessarily so.  This module lets\nyou re-assure GHC that this is okay.\n\nThe most
  straightforward/high-level usage is with `withNatOp`:\n\n~~~haskell\ngetDoubled
  :: forall n. KnownNat n => Proxy n -> Integer\ngetDoubled p = withNatOp (%*) p (Proxy
  :: Proxy 2) $\n    natVal (Proxy :: Proxy (n * 2))\n~~~\n\nWithin the scope of the
  argument of\n`withNatOp (%*) (Proxy :: Proxy n) (Proxy :: Proxy m)`, `n * m` is
  an instance\nof `KnownNat`, so you can use `natVal` on it, and get the expected
  result:\n\n~~~haskell\n> getDoubled (Proxy :: Proxy 12)\n24\n~~~\n\nThere are four
  \"nat operations\" defined here, corresponding to the four\ntype-level operations
  on `Nat` provided in `GHC.TypeLits`: `(%+)`, `(%-)`,\n`(%*)`, and `(%^)`, corresponding
  to addition, subtraction, multiplication,\nand exponentiation, respectively.\n\nNote
  that `(%-)` is implemented in a way that allows for the result to be a\n*negative*
  `Nat`.\n\nThere are more advanced operations dealing with low-level machinery, as
  well,\nin the module.  See module documentation for more detail.\n\n`GHC.TypeLits.List`\n-------------------\n\nProvides
  analogies of `KnownNat`, `SomeNat`, `natVal`, etc., to type-level\nlists of `KnownNat`
  instances, and also singletons for iterating over\ntype-level lists of `Nat`s and
  `Symbol`s.\n\nIf you had `KnownNats ns`, then you have two things you can do with
  it; first,\n`natsVal`, which is like `natVal` but for type-level lists of `KnownNats`:\n\n~~~haskell\n>
  natsVal (Proxy :: Proxy [1,2,3])\n[1,2,3]\n~~~\n\nAnd more importantly, `natsList`,
  which provides singletons that you can\npattern match on to \"reify\" the structure
  of the list, getting a `Proxy n` for\nevery item in the list with a `KnownNat`/`KnownSymbol`
  instance in scope for\nyou to use:\n\n~~~haskell\nprintNats :: NatList ns -> IO
  ()\nprintNats nl = case nl of\n                 ØNL       ->\n                   return
  ()\n                 p :># nl' -> do\n                   print $ natVal p\n                   printNats
  nl'\n~~~\n\n~~~haskell\n> printNats (natsList :: NatList [1,2,3])\n1\n2\n3\n~~~\n\nWithout
  this, there is no way to \"iterate over\" and \"access\" every `Nat` in a\nlist
  of `KnownNat`s.  You can't \"iterate\" over `[1,2,3]` in `Proxy [1,2,3]`,\nbut you
  can iterate over them in `NatList [1,2,3]`.\n\nThis module also lets you \"reify\"
  lists of `Integer`s or `String`s into\n`NatList`s and `SymbolList`s, so you can
  access them at the type level for\nsome dependent types fun.\n\n~~~haskell\n> reifyNats
  [1,2,3] $ \\nl -> do\n    print nl\n    printNats nl\nProxy :<# Proxy :<# Proxy
  :<# ØNL\n1\n2\n3\n~~~\n\nAnother thing you can do is provide witneses that two `[Nat]`s
  or `[Symbol]`s\nare the same/were instantiated with the same numbers/symbols.\n\n~~~haskell\n>
  reifyNats [1,2,3] $ \\ns -> do\n  reifyNats [1,2,3] $ \\ms -> do\n    case sameNats
  ns ms of\n      Just Refl -> -- in this branch, ns and ms are the same.\n      Nothing
  \  -> -- in this branch, they aren't\n~~~\n\nThe above would match on the `Just
  Refl` branch.\n\nSee module documentation for more details and variations.\n\n"
license-name: MIT
