homepage: https://github.com/mstksg/typelits-witnesses
changelog-type: ''
hash: 3691837637e7785b2d94cf94e7ac494b21b8de948241803c89a556ad3c2c69ab
test-bench-deps: {}
maintainer: justin@jle.im
synopsis: Existential witnesses, singletons, and classes for operations on GHC TypeLits
changelog: ''
basic-deps:
  reflection: -any
  base: ! '>=4.8 && <4.9'
  constraints: -any
all-versions:
- '0.1.0.0'
- '0.1.0.1'
author: Justin Le
latest: '0.1.0.1'
description-type: markdown
description: ! "typelits-witnesses\n==================\n\nProvides witnesses for `KnownNat`
  and `KnownSymbol` instances for various\noperations on GHC TypeLits --- in particular,
  the arithmetic operations\ndefined in `GHC.TypeLits`, and also for type-level lists
  of `KnownNat` and\n`KnownSymbol` instances.\n\nThis is useful for situations where
  you have `KnownNat n`, and you want to\nprove to GHC `KnownNat (n + 3)`, or `KnownNat
  (2*n + 4)`.\n\nIt's also useful for when you want to work with type level lists
  of\n`KnownNat`/`KnownSymbol` instances and singletons for traversing them, and be\nable
  to apply analogies of `natVal`/`symbolVal` to lists with analogies for\n`SomeNat`
  and `SomeSymbol`.\n\n`GHC.TypeLits.Witnesses`\n------------------------\n\nProvides
  witnesses for instances arising from the arithmetic operations\ndefined in `GHC.TypeLits`.\n\nIn
  general, if you have `KnownNat n`, GHC can't infer `KnownNat (n + 1)`;\nand if you
  have `KnownNat m`, as well, GHC can't infer `KnownNat (n + m)`.\n\nThis can be extremely
  annoying when dealing with libraries and applications\nwhere one regularly adds
  and subtracts type-level nats and expects `KnownNat`\ninstances to follow.  For
  example, vector concatenation of length-encoded\nvector types can be:\n\n~~~haskell\nconcat
  :: (KnownNat n, KnownNat m)\n       => Vector n       a\n       -> Vector m       a\n
  \      -> Vector (n + m) a\n~~~\n\nBut, `n + m` now does not have a `KnownNat` instance,
  which severely hinders\nwhat you can do with this!\n\nConsider this concrete (but
  silly) example:\n\n~~~haskell\ngetDoubled :: KnownNat n => Proxy n -> Integer\ngetDoubled
  p = natVal (Proxy :: Proxy (n * 2))\n~~~\n\nWhich is supposed to call `natVal` with
  `n * 2`.  However, this fails, because\nwhile `n` is a `KnownNat`, `n * 2` is not
  necessarily so.  This module lets\nyou re-assure GHC that this is okay.\n\nThe most
  straightforward/high-level usage is with `withNatOp`:\n\n~~~haskell\ngetDoubled
  :: forall n. KnownNat n => Proxy n -> Integer\ngetDoubled p = withNatOp (%*) p (Proxy
  :: Proxy 2) $\n    natVal (Proxy :: Proxy (n * 2))\n~~~\n\nWithin the scope of the
  argument of\n`withNatOp (%*) (Proxy :: Proxy n) (Proxy :: Proxy m)`, `n * m` is
  an instance\nof `KnownNat`, so you can use `natVal` on it, and get the expected
  result:\n\n~~~haskell\n> getDoubled (Proxy :: Proxy 12)\n24\n~~~\n\nThere are four
  \"nat operations\" defined here, corresponding to the four\ntype-level operations
  on `Nat` provided in `GHC.TypeLits`: `(%+)`, `(%-)`,\n`(%*)`, and `(%^)`, corresponding
  to addition, subtraction, multiplication,\nand exponentiation, respectively.\n\nNote
  that `(%-)` is implemented in a way that allows for the result to be a\n*negative*
  `Nat`.\n\nThere are more advanced operations dealing with low-level machinery, as
  well,\nin the module.  See module documentation for more detail.\n\n`GHC.TypeLits.List`\n-------------------\n\nProvides
  analogies of `KnownNat`, `SomeNat`, `natVal`, etc., to type-level\nlists of `KnownNat`
  instances, and also singletons for iterating over\ntype-level lists of `Nat`s and
  `Symbol`s.\n\nIf you had `KnownNats ns`, then you have two things you can do with
  it; first,\n`natsVal`, which is like `natVal` but for type-level lists of `KnownNats`:\n\n~~~haskell\n>
  natsVal (Proxy :: Proxy [1,2,3])\n[1,2,3]\n~~~\n\nAnd more importantly, `natsList`,
  which provides singletons that you can\npattern match on to \"reify\" the structure
  of the list, getting a `Proxy n` for\nevery item in the list with a `KnownNat`/`KnownSymbol`
  instance in scope for\nyou to use:\n\n~~~haskell\nprintNats :: NatList ns -> IO
  ()\nprintNats nl = case nl of\n                 ØNL       ->\n                   return
  ()\n                 p :># nl' -> do\n                   print $ natVal p\n                   printNats
  nl'\n~~~\n\n~~~haskell\n> printNats (natsList :: NatList [1,2,3])\n1\n2\n3\n~~~\n\nWithout
  this, there is no way to \"iterate over\" and \"access\" every `Nat` in a\nlist
  of `KnownNat`s.  You can't \"iterate\" over `[1,2,3]` in `Proxy [1,2,3]`,\nbut you
  can iterate over them in `NatList [1,2,3]`.\n\nThis module also lets you \"reify\"
  lists of `Integer`s or `String`s into\n`NatList`s and `SymbolList`s, so you can
  access them at the type level for\nsome dependent types fun.\n\n~~~haskell\n> reifyNats
  [1,2,3] $ \\nl -> do\n    print nl\n    printNats nl\nProxy :<# Proxy :<# Proxy
  :<# ØNL\n1\n2\n3\n~~~\n\nSee module documentation for more details and variations.\n\n"
license-name: MIT
