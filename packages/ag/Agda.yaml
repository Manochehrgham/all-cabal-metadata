changelog-type: text
hash: b604adb3c6609d27384834ce1d9483841245ac3d59e07571bc1ec114a080dcf3
test-bench-deps: {}
synopsis: A dependently typed functional programming language and proof assistant
changelog: ! "------------------------------------------------------------------------\n--
  Release notes for Agda version 2.4.2.2\n------------------------------------------------------------------------\n\nImportant
  changes since 2.4.2.1:\n\nBug fixes\n=========\n\n* Compilation on Windows fixed.\n\n*
  Other issues fixed ( see https://code.google.com/p/agda/issues )\n  1332\n  1353\n
  \ 1360\n  1366\n  1369\n\n------------------------------------------------------------------------\n--
  Release notes for Agda version 2.4.2.1\n------------------------------------------------------------------------\n\nImportant
  changes since 2.4.2:\n\nPragmas and options\n===================\n\n* New pragma
  {-# TERMINATING #-} replacing {-# NO_TERMINATION_CHECK #-}\n\n  Complements the
  existing pragma {-# NON_TERMINATING #-}.\n  Skips termination check for the associated
  definitions and marks\n  them as terminating.  Thus, it is a replacement for\n  {-#
  NO_TERMINATION_CHECK #-} with the same semantics.\n\n  You can no longer use pragma
  {-# NO_TERMINATION_CHECK #-} to skip\n  the termination check, but must label your
  definitions as either\n  {-# TERMINATING #-} or {-# NON_TERMINATING #-} instead.\n\n
  \ Note: {-# OPTION --no-termination-check #-} labels all your\n  definitions as
  {-# TERMINATING #-}, putting you in the danger zone\n  of a loop in the type checker.\n\nLanguage\n========\n\n*
  Referring to a local variable shadowed by module opening is now\n  an error.  Previous
  behavior was preferring the local over the\n  imported definitions. [Issue 1266]\n\n
  \ Note that module parameters are locals as well as variables bound by\n  λ, dependent
  function type, patterns, and let.\n\n  Example:\n\n    module M where\n      A =
  Set1\n\n    test : (A : Set) → let open M in A\n\n  The last A produces an error,
  since it could refer to the local\n  variable A or to the definition imported from
  module M.\n\n* `with` on a variable bound by a module telescope or a pattern of
  a\n  parent function is now forbidden.  [Issue 1342]\n\n    data Unit : Set where\n
  \     unit : Unit\n\n    id : (A : Set) → A → A\n    id A a = a\n\n    module M
  (x : Unit) where\n\n      dx : Unit → Unit\n      dx unit = x\n\n      g : ∀ u →
  x ≡ dx u\n      g with x\n      g | unit  = id (∀ u → unit ≡ dx u) ?\n\n  Even though
  this code looks right, Agda complains about the type\n  expression `∀ u → unit ≡
  dx u`.  If you ask Agda what should go\n  there instead, it happily tells you that
  it wants\n  `∀ u → unit ≡ dx u`. In fact what you do not see and Agda\n  will never
  show you is that the two expressions actually differ in\n  the invisible first argument
  to `dx`, which is visible only outside\n  module `M`.  What Agda wants is an invisible
  `unit` after `dx`, but all\n  you can write is an invisible `x` (which is inserted
  behind the\n  scenes).\n\n  To avoid those kinds of paradoxes, `with` is now outlawed
  on module\n  parameters.  This should ensure that the invisible arguments are\n
  \ always exactly the module parameters.\n\n  Since a `where` block is desugared
  as module with pattern variables\n  of the parent clause as module parameters, the
  same strikes you for\n  uses of `with` on pattern variables of the parent function.\n\n
  \   f : Unit → Unit\n    f x = unit\n      where\n        dx : Unit → Unit\n        dx
  unit = x\n\n        g : ∀ u → x ≡ dx u\n        g with x\n        g | unit  = id
  ((u : Unit) → unit ≡ dx u) ?\n\n  The `with` on pattern variable `x` of the parent
  clause `f x = unit`\n  is outlawed now.\n\nType checking\n=============\n\n* Termination
  check failure is now a proper error.\n\n  We no longer continue type checking after
  termination check failures.\n  Use pragmas {-# NON_TERMINATING #-} and {-# NO_TERMINATION_CHECK
  #-}\n  near the offending definitions if you want to do so.\n  Or switch off the
  termination checker altogether with\n  {-# OPTIONS --no-termination-check #-} (at
  your own risk!).\n\n* (Since Agda 2.4.2:) Termination checking --without-K restricts\n
  \ structural descent to arguments ending in data types or `Size`.\n  Likewise, guardedness
  is only tracked when result type is data or\n  record type.\n\n    mutual\n      data
  WOne : Set where wrap : FOne → WOne\n      FOne = ⊥ → WOne\n\n    noo : (X : Set)
  → (WOne ≡ X) → X → ⊥\n    noo .WOne refl (wrap f) = noo FOne iso f\n\n  `noo` is
  rejected since at type `X` the structural descent\n  `f < wrap f` is discounted
  --without-K.\n\n    data Pandora : Set where\n      C : ∞ ⊥ → Pandora\n\n    loop
  : (A : Set) → A ≡ Pandora → A\n    loop .Pandora refl = C (♯ (loop ⊥ foo))\n\n  `loop`
  is rejected since guardedness is not tracked at type `A`\n  --without-K.\n\n  See
  issues 1023, 1264, 1292.\n\nTermination checking\n====================\n\n* The
  termination checker can now recognize simple subterms in dot\n  patterns.\n\n    data
  Subst : (d : Nat) → Set where\n      c₁ : ∀ {d} → Subst d → Subst d\n      c₂ :
  ∀ {d₁ d₂} → Subst d₁ → Subst d₂ → Subst (suc d₁ + d₂)\n\n    postulate\n      comp
  : ∀ {d₁ d₂} → Subst d₁ → Subst d₂ → Subst (d₁ + d₂)\n\n    lookup : ∀ d → Nat →
  Subst d → Set₁\n    lookup d             zero    (c₁ ρ)             = Set\n    lookup
  d             (suc v) (c₁ ρ)             = lookup d v ρ\n    lookup .(suc d₁ + d₂)
  v      (c₂ {d₁} {d₂} ρ σ) = lookup (d₁ + d₂) v (comp ρ σ)\n\n  The dot pattern here
  is actually normalized, so it is\n\n    suc (d₁ + d₂)\n\n  and the corresponding
  recursive call argument is (d₁ + d₂).\n  In such simple cases, Agda can now recognize
  that the pattern is\n  constructor applied to call argument, which is valid descent.\n\n
  \ Note however, that Agda only looks for syntactic equality when\n  identifying
  subterms, since it is not allowed to normalize terms on\n  the rhs during termination
  checking.\n\n  Actually writing the dot pattern has no effect, this works as well,\n
  \ and looks pretty magical... ;-)\n\n    hidden : ∀{d} → Nat → Subst d → Set₁\n
  \   hidden zero    (c₁ ρ)   = Set\n    hidden (suc v) (c₁ ρ)   = hidden v ρ\n    hidden
  v       (c₂ ρ σ) = hidden v (comp ρ σ)\n\nTools\n=====\n\nLaTeX-backend\n-------------\n\n*
  Fixed the issue of identifiers containing operators being typeset with\n  excessive
  math spacing.\n\nBug fixes\n=========\n\n* Issue 1194\n\n* Issue 836:  Fields and
  constructors can be qualified by the\n  record/data *type* as well as by their record/data
  module.\n  This now works also for record/data type imported from\n  parametrized
  modules:\n\n    module M (_ : Set₁) where\n\n      record R : Set₁ where\n        field\n
  \         X : Set\n\n    open M Set using (R)  -- rather than using (module R)\n\n
  \   X : R → Set\n    X = R.X\n\n------------------------------------------------------------------------\n--
  Release notes for Agda version 2.4.2\n------------------------------------------------------------------------\n\nImportant
  changes since 2.4.0.2:\n\nPragmas and options\n===================\n\n* New option:
  --with-K.\n\n  This can be used to override a global --without-K in a file, by\n
  \ adding a pragma {-# OPTIONS --with-K #-}.\n\n* New pragma {-# NON_TERMINATING
  #-}\n\n  This is a safer version of NO_TERMINATION_CHECK which doesn't treat the\n
  \ affected functions as terminating. This means that NON_TERMINATING functions\n
  \ do not reduce during type checking. They do reduce at run-time and when\n  invoking
  C-c C-n at top-level (but not in a hole).\n\nLanguage\n========\n\n* Instance search
  is now more efficient and recursive (see issue 938)\n  (but without termination
  check yet).\n\n  A new keyword `instance' has been introduced (in the style of\n
  \ `abstract' and  `private') which must now be used for every\n  definition/postulate
  that has to be taken into account during instance\n  resolution. For example:\n\n
  \   record RawMonoid (A : Set) : Set where\n      field\n        nil  : A\n        _++_
  : A -> A -> A\n\n    open RawMonoid {{...}}\n\n    instance\n      rawMonoidList
  : {A : Set} -> RawMonoid (List A)\n      rawMonoidList = record { nil = []; _++_
  = List._++_ }\n\n      rawMonoidMaybe : {A : Set} {{m : RawMonoid A}} -> RawMonoid
  (Maybe A)\n      rawMonoidMaybe {A} = record { nil = nothing ; _++_ = catMaybe }\n
  \       where\n          catMaybe : Maybe A -> Maybe A -> Maybe A\n          catMaybe
  nothing mb = mb\n          catMaybe ma nothing = ma\n          catMaybe (just a)
  (just b) = just (a ++ b)\n\n  Moreover, each type of an instance must end in (something
  that reduces\n  to) a named type (e.g. a record, a datatype or a postulate). This\n
  \ allows us to build a simple index structure\n\n    data/record name  -->  possible
  instances\n\n  that speeds up instance search.\n\n  Instance search takes into account
  all local bindings and all global\n  'instance' bindings and the search is recursive.
  For instance,\n  searching for\n\n    ? : RawMonoid (Maybe (List A))\n\n  will consider
  the candidates {rawMonoidList, rawMonoidMaybe}, fail to\n  unify the first one,
  succeeding with the second one\n\n    ? = rawMonoidMaybe {A = List A} {{m = ?m}}
  : RawMonoid (Maybe (List A))\n\n  and continue with goal\n\n    ?m : RawMonoid (List
  A)\n\n  This will then find\n\n    ?m = rawMonoidList {A = A}\n\n  and putting together
  we have the solution.\n\n  Be careful that there is no termination check for now,
  you can easily\n  make Agda loop by declaring the identity function as an instance.
  But\n  it shouldn’t be possible to make Agda loop by only declaring\n  structurally
  recursive instances (whatever that means).\n\n  Additionally:\n\n  * Uniqueness
  of instances is up to definitional equality (see issue 899).\n\n  * Instances of
  the following form are allowed:\n\n        EqSigma : {A : Set} {B : A → Set} {{EqA
  : Eq A}}\n                  {{EqB : {a : A} → Eq (B a)}}\n                  → Eq
  (Σ A B)\n\n    When searching recursively for an instance of type\n    `{a : A}
  → Eq (B a)', a lambda will automatically be introduced and\n    instance search
  will search for something of type `Eq (B a)' in\n    the context extended by `a
  : A'. When searching for an instance, the\n    `a' argument does not have to be
  implicit, but in the definition of\n    EqSigma, instance search will only be able
  to use EqB if `a' is implicit.\n\n  * There is no longer any attempt to solve irrelevant
  metas by instance\n    search.\n\n  * Constructors of records and datatypes are
  automatically added to the\n    instance table.\n\n* You can now use 'quote' in
  patterns.\n\n  For instance, here is a function that unquotes a (closed) natural
  number\n  term.\n\n    unquoteNat : Term → Maybe Nat\n    unquoteNat (con (quote
  Nat.zero) [])            = just zero\n    unquoteNat (con (quote Nat.suc) (arg _
  n ∷ [])) = fmap suc (unquoteNat n)\n    unquoteNat _                                    =
  nothing\n\n* The builtin constructors AGDATERMUNSUPPORTED and AGDASORTUNSUPPORTED
  are now\n  translated to meta variables when unquoting.\n\n* New syntactic sugar
  'tactic e' and 'tactic e | e1 | .. | en'.\n\n  It desugars as follows and makes
  it less unwieldy to call reflection-based\n  tactics.\n\n    tactic e                -->
  quoteGoal g in unquote (e g)\n    tactic e | e1 | .. | en --> quoteGoal g in unquote
  (e g) e1 .. en\n\n  Note that in the second form the tactic function should generate
  a function\n  from a number of new subgoals to the original goal. The type of e
  should be\n  Term -> Term in both cases.\n\n* New reflection builtins for literals.\n\n
  \ The Term data type AGDATERM now needs an additional constructor AGDATERMLIT\n
  \ taking a reflected literal defined as follows (with appropriate builtin\n  bindings
  for the types Nat, Float, etc).\n\n    data Literal : Set where\n      nat    :
  Nat    → Literal\n      float  : Float  → Literal\n      char   : Char   → Literal\n
  \     string : String → Literal\n      qname  : QName  → Literal\n\n    {-# BUILTIN
  AGDALITERAL   Literal #-}\n    {-# BUILTIN AGDALITNAT    nat     #-}\n    {-# BUILTIN
  AGDALITFLOAT  float   #-}\n    {-# BUILTIN AGDALITCHAR   char    #-}\n    {-# BUILTIN
  AGDALITSTRING string  #-}\n    {-# BUILTIN AGDALITQNAME  qname   #-}\n\n  When quoting
  (quoteGoal or quoteTerm) literals will be mapped to the\n  AGDATERMLIT constructor.
  Previously natural number literals were quoted\n  to suc/zero application and other
  literals were quoted to\n  AGDATERMUNSUPPORTED.\n\n* New reflection builtins for
  function definitions.\n\n  AGDAFUNDEF should now map to a data type defined as follows\n
  \ (with {-# BUILTIN QNAME       QName   #-}\n        {-# BUILTIN ARG         Arg
  \    #-}\n        {-# BUILTIN AGDATERM    Term    #-}\n        {-# BUILTIN AGDATYPE
  \   Type    #-}\n        {-# BUILTIN AGDALITERAL Literal #-}).\n\n    data Pattern
  : Set where\n      con    : QName → List (Arg Pattern) → Pattern\n      dot    :
  Pattern\n      var    : Pattern\n      lit    : Literal → Pattern\n      proj   :
  QName → Pattern\n      absurd : Pattern\n\n    {-# BUILTIN AGDAPATTERN   Pattern
  #-}\n    {-# BUILTIN AGDAPATCON    con     #-}\n    {-# BUILTIN AGDAPATDOT    dot
  \    #-}\n    {-# BUILTIN AGDAPATVAR    var     #-}\n    {-# BUILTIN AGDAPATLIT
  \   lit     #-}\n    {-# BUILTIN AGDAPATPROJ   proj    #-}\n    {-# BUILTIN AGDAPATABSURD
  absurd  #-}\n\n    data Clause : Set where\n      clause        : List (Arg Pattern)
  → Term → Clause\n      absurd-clause : List (Arg Pattern) → Clause\n\n    {-# BUILTIN
  AGDACLAUSE       Clause        #-}\n    {-# BUILTIN AGDACLAUSECLAUSE clause        #-}\n
  \   {-# BUILTIN AGDACLAUSEABSURD absurd-clause #-}\n\n    data FunDef : Set where\n
  \     fun-def : Type → List Clause → FunDef\n\n    {-# BUILTIN AGDAFUNDEF    FunDef
  \ #-}\n    {-# BUILTIN AGDAFUNDEFCON fun-def #-}\n\n* New reflection builtins for
  extended (pattern-matching) lambda.\n\n  The AGDATERM data type has been augmented
  with a constructor\n\n    AGDATERMEXTLAM : List AGDACLAUSE → List (ARG AGDATERM)
  → AGDATERM\n\n  Absurd lambdas (λ ()) are quoted to extended lambdas with an absurd
  clause.\n\n* Unquoting declarations.\n\n  You can now define (recursive) functions
  by reflection using the new\n  unquoteDecl declaration\n\n    unquoteDecl x = e\n\n
  \ Here e should have type AGDAFUNDEF and evaluate to a closed value. This value\n
  \ is then spliced in as the definition of x. In the body e, x has type QNAME\n  which
  lets you splice in recursive definitions.\n\n  Standard modifiers, such as fixity
  declarations, can be applied to x as\n  expected.\n\n* Quoted levels\n\n  Universe
  levels are now quoted properly instead of being quoted to\n  AGDASORTUNSUPPORTED.
  Setω  still gets an unsupported sort, however.\n\n* Module applicants can now be
  operator applications. Example:\n\n    postulate\n      [_] : A -> B\n\n    module
  M (b : B) where\n\n    module N (a : A) = M [ a ]\n\n  [See Issue 1245.]\n\n* Minor
  change in module application semantics. [Issue 892]\n\n  Previously re-exported
  functions were not redefined when instantiating a\n  module. For instance\n\n    module
  A where f = ...\n    module B (X : Set) where\n      open A public\n    module C
  = B Nat\n\n  In this example C.f would be an alias for A.f, so if both A and C were
  opened\n  f would not be ambiguous. However, this behaviour is not correct when
  A and B\n  share some module parameters (issue 892). To fix this C now defines its
  own\n  copy of f (which evaluates to A.f), which means that opening A and C results\n
  \ in an ambiguous f.\n\nType checking\n=============\n\n* Recursive records need
  to be declared as either inductive or coinductive.\n  'inductive' is no longer default
  for recursive records.\n  Examples:\n\n    record _×_ (A B : Set) : Set where\n
  \     constructor _,_\n      field\n        fst : A\n        snd : B\n\n    record
  Tree (A : Set) : Set where\n      inductive\n      constructor tree\n      field\n
  \       elem     : A\n        subtrees : List (Tree A)\n\n    record Stream (A :
  Set) : Set where\n      coinductive\n      constructor _::_\n      field\n        head
  : A\n        tail : Stream A\n\n  If you are using old-style (musical) coinduction,
  a record may have\n  to be declared as inductive, paradoxically.\n\n    record Stream
  (A : Set) : Set where\n      inductive -- YES, THIS IS INTENDED !\n      constructor
  _∷_\n      field\n        head : A\n        tail : ∞ (Stream A)\n\n  This is because
  the ``coinduction'' happens in the use of `∞' and not\n  in the use of `record'.\n\nTools\n=====\n\nEmacs
  mode\n----------\n\n* A new menu option \"Display\" can be used to display the version
  of\n  the running Agda process.\n\nLaTeX-backend\n-------------\n\n* New experimental
  option ``references'' has been added. When specified,\n  i.e.:\n\n      \\usepackage[references]{agda}\n\n
  \ a new command called \\AgdaRef is provided, which lets you reference\n  previously
  typeset commands, e.g.:\n\n      Let us postulate \\AgdaRef{apa}.\n\n      \\begin{code}\n
  \     postulate\n        apa : Set\n      \\end{code}\n\n  Above ``apa'' will be
  typeset (highlighted) the same in the text as in\n  the code, provided that the
  LaTeX output is post-processed using\n  src/data/postprocess-latex.pl, e.g.:\n\n
  \   cp $(dirname $(dirname $(agda-mode locate)))/postprocess-latex.pl .\n    agda
  -i. --latex Example.lagda\n    cd latex/\n    perl ../postprocess-latex.pl Example.tex
  > Example.processed\n    mv Example.processed Example.tex\n    xelatex Example.tex\n\n
  \ Mix-fix and unicode should work as expected (unicode requires\n  XeLaTeX/LuaLaTeX),
  but there are limitations:\n\n    + Overloading identifiers should be avoided, if
  multiples exist\n      \\AgdaRef will typeset according to the first it finds.\n\n
  \   + Only the current module is used, should you need to reference\n      identifiers
  in other modules then you need to specify which other\n      module manually, i.e.
  \\AgdaRef[module]{identifier}.\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.4.0.2\n------------------------------------------------------------------------\n\nImportant
  changes since 2.4.0.1:\n\n* The Agda input mode now supports alphabetical super
  and subscripts,\n  in addition to the numerical ones that were already present.\n
  \ [Issue 1240]\n\n* New feature: Interactively split result.\n\n  Make case (C-c
  C-c) with no variables given tries to split on the\n  result to introduce projection
  patterns.  The hole needs to be of\n  record type, of course.\n\n    test : {A B
  : Set} (a : A) (b : B) → A × B\n    test a b = ?\n\n  Result-splitting ? will produce
  the new clauses:\n\n    proj₁ (test a b) = ?\n    proj₂ (test a b) = ?\n\n  If hole
  is of function type ending in a record type, the necessary\n  pattern variables
  will be introduced before the split.  Thus, the\n  same result can be obtained by
  starting from:\n\n    test : {A B : Set} (a : A) (b : B) → A × B\n    test = ?\n\n*
  The so far undocumented ETA pragma now throws an error if applied to\n  definitions
  that are not records.\n\n  ETA can be used to force eta-equality at recursive record
  types,\n  for which eta is not enabled automatically by Agda.\n  Here is such an
  example:\n\n    mutual\n      data Colist (A : Set) : Set where\n        [] : Colist
  A\n        _∷_ : A → ∞Colist A → Colist A\n\n      record ∞Colist (A : Set) : Set
  where\n        coinductive\n        constructor delay\n        field       force
  : Colist A\n\n    open ∞Colist\n\n    {-# ETA ∞Colist #-}\n\n    test : {A : Set}
  (x : ∞Colist A) → x ≡ delay (force x)\n    test x = refl\n\n  Note:  Unsafe use
  of ETA can make Agda loop, e.g. by triggering\n  infinite eta expansion!\n\n* Bugs
  fixed (see https://code.google.com/p/agda/issues):\n  1203\n  1205\n  1209\n  1213\n
  \ 1214\n  1216\n  1225\n  1226\n  1231\n  1233\n  1239\n  1241\n  1243\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.4.0.1\n------------------------------------------------------------------------\n\nImportant
  changes since 2.4.0:\n\n* The option --compile-no-main has been renamed to --no-main.\n\n*
  COMPILED_DATA pragmas can now be given for records.\n\n* Various bug fixes.\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.4.0\n------------------------------------------------------------------------\n\nImportant
  changes since 2.3.2.2:\n\nInstallation and infrastructure\n===============================\n\n*
  A new module called Agda.Primitive has been introduced. This module\n  is available
  to all users, even if the standard library is not used.\n  Currently the module
  contains level primitives and their\n  representation in Haskell when compiling
  with MAlonzo:\n\n    infixl 6 _⊔_\n\n    postulate\n      Level : Set\n      lzero
  : Level\n      lsuc  : (ℓ : Level) → Level\n      _⊔_   : (ℓ₁ ℓ₂ : Level) → Level\n\n
  \   {-# COMPILED_TYPE Level ()      #-}\n    {-# COMPILED lzero ()           #-}\n
  \   {-# COMPILED lsuc  (\\_ -> ())   #-}\n    {-# COMPILED _⊔_   (\\_ _ -> ()) #-}\n\n
  \   {-# BUILTIN LEVEL     Level  #-}\n    {-# BUILTIN LEVELZERO lzero  #-}\n    {-#
  BUILTIN LEVELSUC  lsuc   #-}\n    {-# BUILTIN LEVELMAX  _⊔_    #-}\n\n  To bring
  these declarations into scope you can use a declaration\n  like the following one:\n\n
  \   open import Agda.Primitive using (Level; lzero; lsuc; _⊔_)\n\n  The standard
  library reexports these primitives (using the names\n  zero and suc instead of lzero
  and lsuc) from the Level module.\n\n  Existing developments using universe polymorphism
  might now trigger\n  the following error message:\n\n    Duplicate binding for built-in
  thing LEVEL, previous binding to\n    .Agda.Primitive.Level\n\n  To fix this problem,
  please remove the duplicate bindings.\n\n  Technical details (perhaps relevant to
  those who build Agda\n  packages):\n\n  The include path now always contains a directory
  <DATADIR>/lib/prim,\n  and this directory is supposed to contain a subdirectory
  Agda\n  containing a file Primitive.agda.\n\n  The standard location of <DATADIR>
  is system- and\n  installation-specific.  E.g., in a cabal --user installation of\n
  \ Agda-2.3.4 on a standard single-ghc Linux system it would be\n  $HOME/.cabal/share/Agda-2.3.4
  or something similar.\n\n  The location of the <DATADIR> directory can be configured
  at\n  compile-time using Cabal flags (--datadir and --datasubdir).\n  The location
  can also be set at run-time, using the Agda_datadir\n  environment variable.\n\nPragmas
  and options\n===================\n\n* Pragma NO_TERMINATION_CHECK placed within
  a mutual block is now\n  applied to the whole mutual block (rather than being discarded\n
  \ silently).  Adding to the uses 1.-4. outlined in the release notes\n  for 2.3.2
  we allow:\n\n  3a. Skipping an old-style mutual block: Somewhere within 'mutual'\n
  \     block before a type signature or first function clause.\n\n       mutual\n
  \        {-# NO_TERMINATION_CHECK #-}\n         c : A\n         c = d\n\n         d
  : A\n         d = c\n\n* New option --no-pattern-matching\n\n  Disables all forms
  of pattern matching (for the current file).\n  You can still import files that use
  pattern matching.\n\n* New option -v profile:7\n\n  Prints some stats on which phases
  Agda spends how much time.\n  (Number might not be very reliable, due to garbage
  collection\n  interruptions, and maybe due to laziness of Haskell.)\n\n* New option
  --no-sized-types\n\n  Option --sized-types is now default.\n  --no-sized-types will
  turn off an extra (inexpensive) analysis on\n  data types used for subtyping of
  sized types.\n\nLanguage\n========\n\n* Experimental feature: quoteContext\n\n  There
  is a new keyword 'quoteContext' that gives users access to the\n  list of names
  in the current local context. For instance:\n\n    open import Data.Nat\n    open
  import Data.List\n    open import Reflection\n\n    foo : ℕ → ℕ → ℕ\n    foo 0 m
  = 0\n    foo (suc n) m = quoteContext xs in ?\n\n  In the remaining goal, the list
  xs will consist of two names, n and\n  m, corresponding to the two local variables.
  At the moment it is not\n  possible to access let bound variables -- this feature
  may be added\n  in the future.\n\n* Experimental feature: Varying arity.\n  Function
  clauses may now have different arity, e.g.,\n\n    Sum : ℕ → Set\n    Sum 0       =
  ℕ\n    Sum (suc n) = ℕ → Sum n\n\n    sum : (n : ℕ) → ℕ → Sum n\n    sum 0       acc
  \  = acc\n    sum (suc n) acc m = sum n (m + acc)\n\n  or,\n\n    T : Bool → Set\n
  \   T true  = Bool\n    T false = Bool → Bool\n\n    f : (b : Bool) → T b\n    f
  false true  = false\n    f false false = true\n    f true = true\n\n  This feature
  is experimental.  Yet unsupported:\n  * Varying arity and 'with'.\n  * Compilation
  of functions with varying arity to Haskell, JS, or Epic.\n\n* Experimental feature:
  copatterns.  (Activated with option --copatterns)\n\n  We can now define a record
  by explaining what happens if you project\n  the record.  For instance:\n\n    {-#
  OPTIONS --copatterns #-}\n\n    record _×_ (A B : Set) : Set where\n      constructor
  _,_\n      field\n        fst : A\n        snd : B\n    open _×_\n\n    pair : {A
  B : Set} → A → B → A × B\n    fst (pair a b) = a\n    snd (pair a b) = b\n\n    swap
  : {A B : Set} → A × B → B × A\n    fst (swap p) = snd p\n    snd (swap p) = fst
  p\n\n    swap3 : {A B C : Set} → A × (B × C) → C × (B × A)\n    fst (swap3 t)       =
  snd (snd t)\n    fst (snd (swap3 t)) = fst (snd t)\n    snd (snd (swap3 t)) = fst
  t\n\n  Taking a projection on the left hand side (lhs) is called a\n  projection
  pattern, applying to a pattern is called an application\n  pattern.  (Alternative
  terms: projection/application copattern.)\n\n  In the first example, the symbol
  'pair', if applied to variable\n  patterns a and b and then projected via fst, reduces
  to a.\n  'pair' by itself does not reduce.\n\n  A typical application are coinductive
  records such as streams:\n\n    record Stream (A : Set) : Set where\n      coinductive\n
  \     field\n        head : A\n        tail : Stream A\n    open Stream\n\n    repeat
  : {A : Set} (a : A) -> Stream A\n    head (repeat a) = a\n    tail (repeat a) =
  repeat a\n\n  Again, 'repeat a' by itself will not reduce, but you can take\n  a
  projection (head or tail) and then it will reduce to the\n  respective rhs.  This
  way, we get the lazy reduction behavior\n  necessary to avoid looping corecursive
  programs.\n\n  Application patterns do not need to be trivial (i.e., variable\n
  \ patterns), if we mix with projection patterns.  E.g., we can have\n\n    nats
  : Nat -> Stream Nat\n    head (nats zero) = zero\n    tail (nats zero) = nats zero\n
  \   head (nats (suc x)) = x\n    tail (nats (suc x)) = nats x\n\n  Here is an example
  (not involving coinduction) which demostrates\n  records with fields of function
  type:\n\n    -- The State monad\n\n    record State (S A : Set) : Set where\n      constructor
  state\n      field\n        runState : S → A × S\n    open State\n\n    -- The Monad
  type class\n\n    record Monad (M : Set → Set) : Set1 where\n      constructor monad\n
  \     field\n        return : {A : Set}   → A → M A\n        _>>=_  : {A B : Set}
  → M A → (A → M B) → M B\n\n\n    -- State is an instance of Monad\n    -- Demonstrates
  the interleaving of projection and application patterns\n\n    stateMonad : {S :
  Set} → Monad (State S)\n    runState (Monad.return stateMonad a  ) s  = a , s\n
  \   runState (Monad._>>=_  stateMonad m k) s₀ =\n      let a , s₁ = runState m s₀\n
  \     in  runState (k a) s₁\n\n    module MonadLawsForState {S : Set} where\n\n
  \     open Monad (stateMonad {S})\n\n      leftId : {A B : Set}(a : A)(k : A → State
  S B) →\n        (return a >>= k) ≡ k a\n      leftId a k = refl\n\n      rightId
  : {A B : Set}(m : State S A) →\n        (m >>= return) ≡ m\n      rightId m = refl\n\n
  \     assoc : {A B C : Set}(m : State S A)(k : A → State S B)(l : B → State S C)
  →\n        ((m >>= k) >>= l) ≡ (m >>= λ a → (k a >>= l))\n      assoc m k l = refl\n\n
  \ Copatterns are yet experimental and the following does not work:\n\n  * Copatterns
  and 'with' clauses.\n\n  * Compilation of copatterns to Haskell, JS, or Epic.\n\n
  \ * Projections generated by\n      open R {{...}}\n    are not handled properly
  on lhss yet.\n\n  * Conversion checking is slower in the presence of copatterns,\n
  \   since stuck definitions of record type do no longer count\n    as neutral, since
  they can become unstuck by applying a projection.\n    Thus, comparing two neutrals
  currently requires comparing all\n    they projections, which repeats a lot of work.\n\n*
  Top-level module no longer required.\n\n  The top-level module can be omitted from
  an Agda file. The module name is\n  then inferred from the file name by dropping
  the path and the .agda\n  extension. So, a module defined in /A/B/C.agda would get
  the name C.\n\n  You can also suppress only the module name of the top-level module
  by writing\n\n    module _ where\n\n  This works also for parameterised modules.\n\n*
  Module parameters are now always hidden arguments in projections.\n  For instance:\n\n
  \   module M (A : Set) where\n\n      record Prod (B : Set) : Set where\n        constructor
  _,_\n        field\n          fst : A\n          snd : B\n      open Prod public\n\n
  \   open M\n\n  Now, the types of fst and snd are\n\n    fst : {A : Set}{B : Set}
  → Prod A B → A\n    snd : {A : Set}{B : Set} → Prod A B → B\n\n  Until 2.3.2, they
  were\n\n    fst : (A : Set){B : Set} → Prod A B → A\n    snd : (A : Set){B : Set}
  → Prod A B → B\n\n  This change is a step towards symmetry of constructors and projections.\n
  \ (Constructors always took the module parameters as hidden arguments).\n\n* Telescoping
  lets: Local bindings are now accepted in telescopes\n  of modules, function types,
  and lambda-abstractions.\n\n  The syntax of telescopes as been extended to support
  'let':\n\n    id : (let ★ = Set) (A : ★) → A → A\n    id A x = x\n\n  In particular
  one can now 'open' modules inside telescopes:\n\n   module Star where\n     ★ :
  Set₁\n     ★ = Set\n\n   module MEndo (let open Star) (A : ★) where\n     Endo :
  ★\n     Endo = A → A\n\n  Finally a shortcut is provided for opening modules:\n\n
  \   module N (open Star) (A : ★) (open MEndo A) (f : Endo) where\n      ...\n\n
  \ The semantics of the latter is\n\n    module _ where\n      open Star\n      module
  _ (A : ★) where\n        open MEndo A\n        module N (f : Endo) where\n          ...\n\n
  \ The semantics of telescoping lets in function types and lambda\n  abstractions
  is just expanding them into ordinary lets.\n\n* More liberal left-hand sides in
  lets [Issue 1028]:\n\n    You can now write left-hand sides with arguments also
  for let bindings\n    without a type signature. For instance,\n\n      let f x =
  suc x in f zero\n\n    Let bound functions still can't do pattern matching though.\n\n*
  Ambiguous names in patterns are now optimistically resolved in favor\n  of constructors.
  [Issue 822] In particular, the following succeeds now:\n\n    module M where\n\n
  \     data D : Set₁ where\n        [_] : Set → D\n\n    postulate [_] : Set → Set\n\n
  \   open M\n\n    Foo : _ → Set\n    Foo [ A ] = A\n\n* Anonymous where-modules
  are opened public. [Issue 848]\n\n    <clauses>\n    f args = rhs\n      module
  _ telescope where\n        body\n    <more clauses>\n\n  means the following (not
  proper Agda code, since you cannot put a\n  module in-between clauses)\n\n    <clauses>\n
  \   module _ {arg-telescope} telescope where\n      body\n\n    f args = rhs\n    <more
  clauses>\n\n  Example:\n\n    A : Set1\n    A = B module _ where\n      B : Set1\n
  \     B = Set\n\n    C : Set1\n    C = B\n\n* Builtin ZERO and SUC have been merged
  with NATURAL.\n\n  When binding the NATURAL builtin, ZERO and SUC are bound to the
  appropriate\n  constructors automatically. This means that instead of writing\n\n
  \   {-# BUILTIN NATURAL Nat #-}\n    {-# BUILTIN ZERO zero #-}\n    {-# BUILTIN
  SUC suc #-}\n\n  you just write\n\n    {-# BUILTIN NATURAL Nat #-}\n\n* Pattern
  synonym can now have implicit arguments. [Issue 860]\n\n  For example,\n\n    pattern
  tail=_ {x} xs = x ∷ xs\n\n    len : ∀ {A} → List A → Nat\n    len []         = 0\n
  \   len (tail= xs) = 1 + len xs\n\n* Syntax declarations can now have implicit arguments.
  [Issue 400]\n\n  For example\n\n    id : ∀ {a}{A : Set a} -> A -> A\n    id x =
  x\n\n    syntax id {A} x = x ∈ A\n\n* Minor syntax changes\n\n  * -} is now parsed
  as end-comment even if no comment was begun.\n    As a consequence, the following
  definition gives a parse error\n\n      f : {A- : Set} -> Set\n      f {A-} = A-\n\n
  \   because Agda now sees ID(f) LBRACE ID(A) END-COMMENT, and no\n    longer ID(f)
  LBRACE ID(A-) RBRACE.\n\n    The rational is that the previous lexing was to context-sensitive,\n
  \   attempting to comment-out f using {- and -} lead to a parse error.\n\n  * Fixities
  (binding strengths) can now be negative numbers as\n    well. [Issue 1109]\n\n      infix
  -1 _myop_\n\n  * Postulates are now allowed in mutual blocks. [Issue 977]\n\n  *
  Empty where blocks are now allowed. [Issue 947]\n\n  * Pattern synonyms are now
  allowed in parameterised modules. [Issue 941]\n\n  * Empty hiding and renaming lists
  in module directives are now allowed.\n\n  * Module directives using, hiding, renaming
  and public can now appear in\n    arbitrary order. Multiple using/hiding/renaming
  directives are allowed, but\n    you still cannot have both using and hiding (because
  that doesn't make\n    sense). [Issue 493]\n\nGoal and error display\n======================\n\n*
  The error message \"Refuse to construct infinite term\" has been\n  removed, instead
  one gets unsolved meta variables.  Reason: the\n  error was thrown over-eagerly.
  [Issue 795]\n\n* If an interactive case split fails with message\n\n    Since goal
  is solved, further case distinction is not supported;\n    try `Solve constraints'
  instead\n\n  then the associated interaction meta is assigned to a solution.\n  Press
  C-c C-= (Show constraints) to view the solution and C-c C-s\n  (Solve constraints)
  to apply it. [Issue 289]\n\nType checking\n=============\n\n* [ issue 376 ] Implemented
  expansion of bound record variables during meta assignment.\n  Now Agda can solve
  for metas X that are applied to projected variables, e.g.:\n\n    X (fst z) (snd
  z) = z\n\n    X (fst z)         = fst z\n\n  Technically, this is realized by substituting
  (x , y) for z with fresh\n  bound variables x and y.  Here the full code for the
  examples:\n\n    record Sigma (A : Set)(B : A -> Set) : Set where\n      constructor
  _,_\n      field\n        fst : A\n        snd : B fst\n    open Sigma\n\n    test
  : (A : Set) (B : A -> Set) ->\n      let X : (x : A) (y : B x) -> Sigma A B\n          X
  = _\n      in  (z : Sigma A B) -> X (fst z) (snd z) ≡ z\n    test A B z = refl\n\n
  \   test' : (A : Set) (B : A -> Set) ->\n      let X : A -> A\n          X = _\n
  \     in  (z : Sigma A B) -> X (fst z) ≡ fst z\n    test' A B z = refl\n\n  The
  fresh bound variables are named fst(z) and snd(z) and can appear\n  in error messages,
  e.g.:\n\n    fail : (A : Set) (B : A -> Set) ->\n      let X : A -> Sigma A B\n
  \         X = _\n      in  (z : Sigma A B) -> X (fst z) ≡ z\n    fail A B z = refl\n\n
  \ results in error:\n\n    Cannot instantiate the metavariable _7 to solution fst(z)
  , snd(z)\n    since it contains the variable snd(z) which is not in scope of the\n
  \   metavariable or irrelevant in the metavariable but relevant in the\n    solution\n
  \   when checking that the expression refl has type _7 A B (fst z) ≡ z\n\n* Dependent
  record types and definitions by copatterns require\n  reduction with previous function
  clauses while checking the\n  current clause. [Issue 907]\n\n  For a simple example,
  consider\n\n    test : ∀ {A} → Σ Nat λ n → Vec A n\n    proj₁ test = zero\n    proj₂
  test = []\n\n  For the second clause, the lhs and rhs are typed as\n\n    proj₂
  test : Vec A (proj₁ test)\n    []         : Vec A zero\n\n  In order for these types
  to match, we have to reduce the lhs type\n  with the first function clause.\n\n
  \ Note that termination checking comes after type checking, so be\n  careful to
  avoid non-termination!  Otherwise, the type checker\n  might get into an infinite
  loop.\n\n* The implementation of the primitive primTrustMe has changed.\n  It now
  only reduces to REFL if the two arguments x and y have\n  the same computational
  normal form.  Before, it reduced when\n  x and y were definitionally equal, which
  included type-directed\n  equality laws such as eta-equality.  Yet because reduction
  is\n  untyped, calling conversion from reduction lead to Agda crashes\n  [Issue
  882].\n\n  The amended description of primTrustMe is (cf. release notes for 2.2.6):\n\n
  \   primTrustMe : {A : Set} {x y : A} → x ≡ y\n\n  Here _≡_ is the builtin equality
  (see BUILTIN hooks for equality,\n  above).\n\n  If x and y have the same computational
  normal form, then\n  primTrustMe {x = x} {y = y} reduces to refl.\n\n  A note on
  primTrustMe's runtime behavior:\n  The MAlonzo compiler replaces all uses of primTrustMe
  with the\n  REFL builtin, without any check for definitional equality. Incorrect\n
  \ uses of primTrustMe can potentially lead to segfaults or similar\n  problems of
  the compiled code.\n\n* Implicit patterns of record type are now only eta-expanded
  if there\n  is a record constructor. [Issues 473, 635]\n\n    data D : Set where\n
  \     d : D\n\n    data P : D → Set where\n      p : P d\n\n    record Rc : Set
  where\n      constructor c\n      field f : D\n\n    works : {r : Rc} → P (Rc.f
  r) → Set\n    works p = D\n\n  This works since the implicit pattern {r} is eta-expanded
  to\n  {c x} which allows the type of p to reduce to P x and x to be\n  unified with
  d.  The corresponding explicit version is:\n\n    works' : (r : Rc) → P (Rc.f r)
  → Set\n    works' (c .d) p = D\n\n  However, if the record constructor is removed,
  the same example will\n  fail:\n\n    record R : Set where\n      field f : D\n\n
  \   fails : {r : R} → P (R.f r) → Set\n    fails p = D\n\n    -- d != R.f r of type
  D\n    -- when checking that the pattern p has type P (R.f r)\n\n  The error is
  justified since there is no pattern we could write down\n  for r.  It would have
  to look like\n\n    record { f = .d }\n\n  but anonymous record patterns are not
  part of the language.\n\n* Absurd lambdas at different source locations are no longer\n
  \ different. [Issue 857]\n  In particular, the following code type-checks now:\n\n
  \   absurd-equality : _≡_ {A = ⊥ → ⊥} (λ()) λ()\n    absurd-equality = refl\n\n
  \ Which is a good thing!\n\n* Printing of named implicit function types.\n\n  When
  printing terms in a context with bound variables Agda renames new\n  bindings to
  avoid clashes with the previously bound names. For instance, if A\n  is in scope,
  the type (A : Set) → A is printed as (A₁ : Set) → A₁. However,\n  for implicit function
  types the name of the binding matters, since it can be\n  used when giving implicit
  arguments.\n\n  For this situation, the following new syntax has been introduced:\n
  \ {x = y : A} → B is an implicit function type whose bound variable (in scope\n
  \ in B) is y, but where the name of the argument is x for the purposes of\n  giving
  it explicitly. For instance, with A in scope, the type {A : Set} → A\n  is now printed
  as {A = A₁ : Set} → A₁.\n\n  This syntax is only used when printing and is currently
  not being parsed.\n\n* Changed the semantics of --without-K. [Issue 712, Issue 865,
  Issue 1025]\n\n  New specification of --without-K:\n\n  When --without-K is enabled,
  the unification of indices for pattern matching\n  is restricted in two ways:\n\n
  \ 1. Reflexive equations of the form x == x are no longer solved, instead Agda\n
  \    gives an error when such an equation is encountered.\n\n  2. When unifying
  two same-headed constructor forms 'c us' and 'c vs' of type\n     'D pars ixs',
  the datatype indices ixs (but not the parameters) have to\n     be *self-unifiable*,
  i.e. unification of ixs with itself should succeed\n     positively. This is a nontrivial
  requirement because of point 1.\n\n  Examples:\n\n  * The J rule is accepted.\n\n
  \     J : {A : Set} (P : {x y : A} → x ≡ y → Set) →\n          (∀ x → P (refl x))
  →\n          ∀ {x y} (x≡y : x ≡ y) → P x≡y\n      J P p (refl x) = p x\n\n    This
  definition is accepted since unification of x with y doesn't require\n    deletion
  or injectivity.\n\n  * The K rule is rejected.\n\n      K : {A : Set} (P : {x :
  A} → x ≡ x → Set) →\n          (∀ x → P (refl {x = x})) →\n         ∀ {x} (x≡x :
  x ≡ x) → P x≡x\n      K P p refl = p _\n\n    Definition is rejected with the following
  error:\n\n      Cannot eliminate reflexive equation x = x of type A because K has\n
  \     been disabled.\n      when checking that the pattern refl has type x ≡ x\n\n
  \ * Symmetry of the new criterion.\n\n      test₁ : {k l m : ℕ} → k + l ≡ m → ℕ\n
  \     test₁ refl = zero\n\n      test₂ : {k l m : ℕ} → k ≡ l + m → ℕ\n      test₂
  refl = zero\n\n    Both versions are now accepted (previously only the first one
  was).\n\n  * Handling of parameters.\n\n      cons-injective : {A : Set} (x y :
  A) → (x ∷ []) ≡ (y ∷ []) → x ≡ y\n      cons-injective x .x refl = refl\n\n    Parameters
  are not unified, so they are ignored by the new criterion.\n\n  * A larger example:
  antisymmetry of ≤.\n\n      data _≤_ : ℕ → ℕ → Set where\n        lz : (n : ℕ) →
  zero ≤ n\n        ls : (m n : ℕ) → m ≤ n → suc m ≤ suc n\n\n      ≤-antisym : (m
  n : ℕ) → m ≤ n → n ≤ m → m ≡ n\n      ≤-antisym .zero    .zero    (lz .zero) (lz
  .zero)   = refl\n      ≤-antisym .(suc m) .(suc n) (ls m n p) (ls .n .m q) =\n                   cong
  suc (≤-antisym m n p q)\n\n  * [ Issue 1025 ]\n\n      postulate mySpace : Set\n
  \     postulate myPoint : mySpace\n\n      data Foo : myPoint ≡ myPoint → Set where\n
  \       foo : Foo refl\n\n      test : (i : foo ≡ foo) → i ≡ refl\n      test refl
  = {!!}\n\n    When applying injectivity to the equation \"foo ≡ foo\" of type \"Foo
  refl\",\n    it is checked that the index refl of type \"myPoint ≡ myPoint\" is\n
  \   self-unifiable. The equation \"refl ≡ refl\" again requires injectivity, so\n
  \   now the index myPoint is checked for self-unifiability, hence the error:\n\n
  \     Cannot eliminate reflexive equation myPoint = myPoint of type\n      mySpace
  because K has been disabled.\n      when checking that the pattern refl has type
  foo ≡ foo\n\nTermination checking\n====================\n\n* A buggy facility coined
  \"matrix-shaped orders\" that supported\n  uncurried functions (which take tuples
  of arguments instead of one\n  argument after another) has been removed from the
  termination\n  checker. [Issue 787]\n\n* Definitions which fail the termination
  checker are not unfolded any\n  longer to avoid loops or stack overflows in Agda.
  \ However, the\n  termination checker for a mutual block is only invoked after\n
  \ type-checking, so there can still be loops if you define a\n  non-terminating
  function.  But termination checking now happens\n  before the other supplementary
  checks: positivity, polarity,\n  injectivity and projection-likeness.\n  Note that
  with the pragma {-# NO_TERMINATION_CHECK #-} you can make\n  Agda treat any function
  as terminating.\n\n* Termination checking of functions defined by 'with' has been
  improved.\n\n  Cases which previously required --termination-depth\n  to pass the
  termination checker (due to use of 'with') no longer\n  need the flag. For example\n\n
  \   merge : List A → List A → List A\n    merge [] ys = ys\n    merge xs [] = xs\n
  \   merge (x ∷ xs) (y ∷ ys) with x ≤ y\n    merge (x ∷ xs) (y ∷ ys)    | false =
  y ∷ merge (x ∷ xs) ys\n    merge (x ∷ xs) (y ∷ ys)    | true  = x ∷ merge xs (y
  ∷ ys)\n\n  This failed to termination check previously, since the 'with' expands
  to an\n  auxiliary function merge-aux:\n\n    merge-aux x y xs ys false = y ∷ merge
  (x ∷ xs) ys\n    merge-aux x y xs ys true  = x ∷ merge xs (y ∷ ys)\n\n  This function
  makes a call to merge in which the size of one of the arguments\n  is increasing.
  To make this pass the termination checker now inlines the\n  definition of merge-aux
  before checking, thus effectively termination\n  checking the original source program.\n\n
  \ As a result of this transformation doing 'with' on a variable no longer\n  preserves
  termination. For instance, this does not termination check:\n\n    bad : Nat → Nat\n
  \   bad n with n\n    ... | zero  = zero\n    ... | suc m = bad m\n\n* The performance
  of the termination checker has been improved.  For\n  higher --termination-depth
  the improvement is significant.\n  While the default --termination-depth is still
  1, checking with\n  higher --termination-depth should now be feasible.\n\nCompiler
  backends\n=================\n\n* The MAlonzo compiler backend now has support for
  compiling modules\n  that are not full programs (i.e. don't have a main function).
  The\n  goal is that you can write part of a program in Agda and the rest in\n  Haskell,
  and invoke the Agda functions from the Haskell code. The\n  following features were
  added for this reason:\n\n  * A new command-line option --compile-no-main: the command\n\n
  \     agda --compile-no-main Test.agda\n\n    will compile Test.agda and all its
  dependencies to Haskell and\n    compile the resulting Haskell files with --make,
  but (unlike\n    --compile) not tell GHC to treat Test.hs as the main module. This\n
  \   type of compilation can be invoked from emacs by customizing the\n    agda2-backend
  variable to value MAlonzoNoMain and then calling\n    \"C-c C-x C-c\" as before.\n\n
  \ * A new pragma COMPILED_EXPORT was added as part of the MAlonzo FFI.\n    If we
  have an Agda file containing the following:\n\n       module A.B where\n\n       test
  : SomeType\n       test = someImplementation\n\n       {-# COMPILED_EXPORT test
  someHaskellId #-}\n\n    then test will be compiled to a Haskell function called\n
  \   someHaskellId in module MAlonzo.Code.A.B that can be invoked from\n    other
  Haskell code. Its type will be translated according to the\n    normal MAlonzo rules.\n\nTools\n=====\n\nEmacs
  mode\n----------\n\n* A new goal command \"Helper Function Type\" (C-c C-h) has
  been added.\n\n  If you write an application of an undefined function in a goal,
  the Helper\n  Function Type command will print the type that the function needs
  to have in\n  order for it to fit the goal. The type is also added to the Emacs
  kill-ring\n  and can be pasted into the buffer using C-y.\n\n  The application must
  be of the form \"f args\" where f is the name of the\n  helper function you want
  to create. The arguments can use all the normal\n  features like named implicits
  or instance arguments.\n\n  Example:\n\n    Here's a start on a naive reverse on
  vectors:\n\n      reverse : ∀ {A n} → Vec A n → Vec A n\n      reverse [] = []\n
  \     reverse (x ∷ xs) = {!snoc (reverse xs) x!}\n\n    Calling C-c C-h in the goal
  prints\n\n      snoc : ∀ {A} {n} → Vec A n → A → Vec A (suc n)\n\n* A new command
  \"Explain why a particular name is in scope\" (C-c C-w) has been\n  added. [Issue207]\n\n
  \ This command can be called from a goal or from the top-level and will as the\n
  \ name suggests explain why a particular name is in scope.\n\n  For each definition
  or module that the given name can refer to a trace is\n  printed of all open statements
  and module applications leading back to the\n  original definition of the name.\n\n
  \ For example, given\n\n    module A (X : Set₁) where\n      data Foo : Set where\n
  \       mkFoo : Foo\n    module B (Y : Set₁) where\n      open A Y public\n    module
  C = B Set\n    open C\n\n  Calling C-c C-w on mkFoo at the top-level prints\n\n
  \   mkFoo is in scope as\n    * a constructor Issue207.C._.Foo.mkFoo brought into
  scope by\n      - the opening of C at Issue207.agda:13,6-7\n      - the application
  of B at Issue207.agda:11,12-13\n      - the application of A at Issue207.agda:9,8-9\n
  \     - its definition at Issue207.agda:6,5-10\n\n  This command is useful if Agda
  complains about an ambiguous name and you need\n  to figure out how to hide the
  undesired interpretations.\n\n* Improvements to the \"make case\" command (C-c C-c)\n\n
  \ - One can now also split on hidden variables, using the name\n    (starting with
  .) with which they are printed.\n    Use C-c C-, to see all variables in context.\n\n
  \ - Concerning the printing of generated clauses:\n\n  * Uses named implicit arguments
  to improve readability.\n\n  * Picks explicit occurrences over implicit ones when
  there is a choice of\n    binding site for a variable.\n\n  * Avoids binding variables
  in implicit positions by replacing dot patterns\n    that uses them by wildcards
  (._).\n\n* Key bindings for lots of \"mathematical\" characters (examples: \U0001D434\U0001D468\U0001D49C\U0001D4D0\U0001D504)\n
  \ have been added to the Agda input method.\n  Example: type \\MiA\\MIA\\McA\\MCA\\MfA
  to get \U0001D434\U0001D468\U0001D49C\U0001D4D0\U0001D504.\n\n  Note: \\McB does
  not exist in unicode (as well as others in that style),\n  but the \\MC (bold) alphabet
  is complete.\n\n* Key bindings for \"blackboard bold\" B (\U0001D539) and 0-9 (\U0001D7D8-\U0001D7E1)
  have been added\n  to the Agda input method (\\bb and \\b[0-9]).\n\n* Key bindings
  for controlling simplification/normalisation:\n\n  [TODO: Simplification should
  be explained somewhere.]\n\n  Commands like \"Goal type and context\" (C-c C-,)
  could previously be\n  invoked in two ways. By default the output was normalised,
  but if a\n  prefix argument was used (for instance via C-u C-c C-,), then no\n  explicit
  normalisation was performed. Now there are three options:\n\n  * By default (C-c C-,)
  the output is simplified.\n\n  * If C-u is used exactly once (C-u C-c C-,), then
  the result is\n    neither (explicitly) normalised nor simplified.\n\n  * If C-u
  is used twice (C-u C-u C-c C-,), then the result is\n    normalised.\n\n  [TODO:
  As part of the release of Agda 2.3.4 the key binding page on\n  the wiki should
  be updated.]\n\nLaTeX-backend\n-------------\n\n* Two new color scheme options were
  added to agda.sty:\n\n  \\usepackage[bw]{agda}, which highlights in black and white;\n
  \ \\usepackage[conor]{agda}, which highlights using Conor's colors.\n\n  The default
  (no options passed) is to use the standard colors.\n\n* If agda.sty cannot be found
  by the latex environment, it is now\n  copied into the latex output directory ('latex'
  by default) instead\n  of the working directory. This means that the commands needed
  to\n  produce a PDF now is\n\n    agda --latex -i . <file>.lagda\n    cd latex\n
  \   pdflatex <file>.tex\n\n* The LaTeX-backend has been made more tool agnostic,
  in particular\n  XeLaTeX and LuaLaTeX should now work. Here is a small example\n
  \ (test/latex-backend/succeed/UnicodeInput.lagda):\n\n    \\documentclass{article}\n
  \   \\usepackage{agda}\n    \\begin{document}\n\n    \\begin{code}\n    data αβγδεζθικλμνξρστυφχψω
  : Set₁ where\n\n    postulate\n      →⇒⇛⇉⇄↦⇨↠⇀⇁ : Set\n    \\end{code}\n\n    \\[\n
  \   ∀X [ ∅ ∉ X ⇒ ∃f:X ⟶  ⋃ X\\ ∀A ∈ X (f(A) ∈ A) ]\n    \\]\n    \\end{document}\n\n
  \ Compiled as follows, it should produce a nice looking PDF (tested with\n  TeX
  Live 2012):\n\n    agda --latex <file>.lagda\n    cd latex\n    xelatex <file>.tex
  (or lualatex <file>.tex)\n\n  If symbols are missing or xelatex/lualatex complains
  about the font\n  missing, try setting a different font using:\n\n    \\setmathfont{<math-font>}\n\n
  \ Use the fc-list tool to list available fonts.\n\n* Add experimental support for
  hyperlinks to identifiers\n\n  If the hyperref latex package is loaded before the
  agda package and\n  the links option is passed to the agda package, then the agda
  package\n  provides a function called \\AgdaTarget. Identifiers which have been\n
  \ declared targets, by the user, will become clickable hyperlinks in the\n  rest
  of the document. Here is a small example\n  (test/latex-backend/succeed/Links.lagda):\n\n
  \   \\documentclass{article}\n    \\usepackage{hyperref}\n    \\usepackage[links]{agda}\n
  \   \\begin{document}\n\n    \\AgdaTarget{ℕ}\n    \\AgdaTarget{zero}\n    \\begin{code}\n
  \   data ℕ : Set where\n      zero  : ℕ\n      suc   : ℕ → ℕ\n    \\end{code}\n\n
  \   See next page for how to define \\AgdaFunction{two} (doesn't turn into a\n    link
  because the target hasn't been defined yet). We could do it\n    manually though;
  \\hyperlink{two}{\\AgdaDatatype{two}}.\n\n    \\newpage\n\n    \\AgdaTarget{two}\n
  \   \\hypertarget{two}{}\n    \\begin{code}\n    two : ℕ\n    two = suc (suc zero)\n
  \   \\end{code}\n\n    \\AgdaInductiveConstructor{zero} is of type\n    \\AgdaDatatype{ℕ}.
  \\AgdaInductiveConstructor{suc} has not been defined to\n    be a target so it doesn't
  turn into a link.\n\n    \\newpage\n\n    Now that the target for \\AgdaFunction{two}
  has been defined the link\n    works automatically.\n\n    \\begin{code}\n    data
  Bool : Set where\n      true false : Bool\n    \\end{code}\n\n    The AgdaTarget
  command takes a list as input, enabling several\n    targets to be specified as
  follows:\n\n    \\AgdaTarget{if, then, else, if\\_then\\_else\\_}\n    \\begin{code}\n
  \   if_then_else_ : {A : Set} → Bool → A → A → A\n    if true  then t else f = t\n
  \   if false then t else f = f\n    \\end{code}\n\n    \\newpage\n\n    Mixfix identifier
  need their underscores escaped:\n    \\AgdaFunction{if\\_then\\_else\\_}.\n\n    \\end{document}\n\n
  \ The boarders around the links can be suppressed using hyperref's\n  hidelinks
  option:\n\n    \\usepackage[hidelinks]{hyperref}\n\n  Note that the current approach
  to links does not keep track of scoping\n  or types, and hence overloaded names
  might create links which point to\n  the wrong place. Therefore it is recommended
  to not overload names\n  when using the links option at the moment, this might get
  fixed in the\n  future.\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.3.2.2\n------------------------------------------------------------------------\n\nImportant
  changes since 2.3.2.1:\n\n* Fixed a bug that sometimes made it tricky to use the
  Emacs mode on\n  Windows [issue 757].\n\n* Made Agda build with newer versions of
  some libraries.\n\n* Fixed a bug that caused ambiguous parse error messages [issue
  147].\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.3.2.1\n------------------------------------------------------------------------\n\nImportant
  changes since 2.3.2:\n\nInstallation\n============\n\n* Made it possible to compile
  Agda with more recent versions of\n  hashable, QuickCheck and Win32.\n\n* Excluded
  mtl-2.1.\n\nType checking\n=============\n\n* Fixed bug in the termination checker
  (issue 754).\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.3.2\n------------------------------------------------------------------------\n\nImportant
  changes since 2.3.0:\n\nInstallation\n============\n\n* The Agda-executable package
  has been removed.\n\n  The executable is now provided as part of the Agda package.\n\n*
  The Emacs mode no longer depends on haskell-mode or GHCi.\n\n* Compilation of Emacs
  mode Lisp files.\n\n  You can now compile the Emacs mode Lisp files by running \"agda-mode\n
  \ compile\". This command is run by \"make install\".\n\n  Compilation can, in some
  cases, give a noticeable speedup.\n\n  WARNING: If you reinstall the Agda mode without
  recompiling the\n  Emacs Lisp files, then Emacs may continue using the old, compiled\n
  \ files.\n\nPragmas and options\n===================\n\n* The --without-K check
  now reconstructs constructor parameters.\n\n  New specification of --without-K:\n\n
  \ If the flag is activated, then Agda only accepts certain\n  case-splits. If the
  type of the variable to be split is D pars ixs,\n  where D is a data (or record)
  type, pars stands for the parameters,\n  and ixs the indices, then the following
  requirements must be\n  satisfied:\n\n  * The indices ixs must be applications of
  constructors (or literals)\n    to distinct variables. Constructors are usually
  not applied to\n    parameters, but for the purposes of this check constructor\n
  \   parameters are treated as other arguments.\n\n  * These distinct variables must
  not be free in pars.\n\n* Irrelevant arguments are printed as _ by default now.
  \ To turn on\n  printing of irrelevant arguments, use option\n\n    --show-irrelevant\n\n*
  New: Pragma NO_TERMINATION_CHECK to switch off termination checker\n  for individual
  function definitions and mutual blocks.\n\n  The pragma must precede a function
  definition or a mutual block.\n  Examples (see test/succeed/NoTerminationCheck.agda):\n\n
  \ 1. Skipping a single definition: before type signature.\n\n       {-# NO_TERMINATION_CHECK
  #-}\n       a : A\n       a = a\n\n  2. Skipping a single definition: before first
  clause.\n\n       b : A\n       {-# NO_TERMINATION_CHECK #-}\n       b = b\n\n  3.
  Skipping an old-style mutual block: Before 'mutual' keyword.\n\n       {-# NO_TERMINATION_CHECK
  #-}\n       mutual\n         c : A\n         c = d\n\n         d : A\n         d
  = c\n\n  4. Skipping a new-style mutual block: Anywhere before a type\n     signature
  or first function clause in the block\n\n       i : A\n       j : A\n\n       i
  = j\n       {-# NO_TERMINATION_CHECK #-}\n       j = i\n\n  The pragma cannot be
  used in --safe mode.\n\nLanguage\n========\n\n* Let binding record patterns\n\n
  \   record _×_ (A B : Set) : Set where\n      constructor _,_\n      field\n        fst
  : A\n        snd : B\n    open _×_\n\n    let (x , (y , z)) = t\n    in  u\n\n  will
  now be interpreted as\n\n    let x = fst t\n        y = fst (snd t)\n        z =
  snd (snd t)\n    in  u\n\n  Note that the type of t needs to be inferable.  If you
  need to provide\n  a type signature, you can write the following:\n\n    let a :
  ...\n        a = t\n        (x , (y , z)) = a\n    in  u\n\n* Pattern synonyms\n\n
  \ A pattern synonym is a declaration that can be used on the left hand\n  side (when
  pattern matching) as well as the right hand side (in\n  expressions). For example:\n\n
  \ pattern z    = zero\n  pattern ss x = suc (suc x)\n\n  f : ℕ -> ℕ\n  f z       =
  z\n  f (suc z) = ss z\n  f (ss n)  = n\n\n  Pattern synonyms are implemented by
  substitution on the abstract\n  syntax, so definitions are scope-checked but not
  type-checked. They\n  are particularly useful for universe constructions.\n\n* Qualified
  mixfix operators\n\n  It is now possible to use a qualified mixfix operator by qualifying
  the first\n  part of the name. For instance\n\n    import Data.Nat as Nat\n    import
  Data.Bool as Bool\n\n    two = Bool.if true then 1 Nat.+ 1 else 0\n\n* Sections
  [Issue 735].  Agda now parses anonymous modules as sections:\n\n    module _ {a}
  (A : Set a) where\n\n      data List : Set a where\n        []  : List\n        _∷_
  : (x : A) (xs : List) → List\n\n    module _ {a} {A : Set a} where\n\n      _++_
  : List A → List A → List A\n      []       ++ ys = ys\n      (x ∷ xs) ++ ys = x
  ∷ (xs ++ ys)\n\n    test : List Nat\n    test = (5 ∷ []) ++ (3 ∷ [])\n\n  In general,
  now the syntax\n\n    module _ parameters where\n      declarations\n\n  is accepted
  and has the same effect as\n\n    private\n      module M parameters where\n        declarations\n
  \   open M public\n\n  for a fresh name M.\n\n* Instantiating a module in an open
  import statement [Issue 481].  Now accepted:\n\n    open import Path.Module args
  [using/hiding/renaming (...)]\n\n  This only brings the imported identifiers from
  Path.Module into scope,\n  not the module itself!  Consequently, the following is
  pointless, and raises\n  an error:\n\n    import Path.Module args [using/hiding/renaming
  (...)]\n\n  You can give a private name M to the instantiated module via\n\n    import
  Path.Module args as M [using/hiding/renaming (...)]\n    open import Path.Module
  args as M [using/hiding/renaming (...)]\n\n  Try to avoid 'as' as part of the arguments.
  \ 'as' is not a keyword;\n  the following can be legal, although slightly obfuscated
  Agda code:\n\n    open import as as as as as as\n\n* Implicit module parameters
  can be given by name. E.g.\n\n    open M {namedArg = bla}\n\n  This feature has
  been introduced in Agda 2.3.0 already.\n\n* Multiple type signatures sharing a same
  type can now be written as a single\n  type signature.\n\n    one two : ℕ\n    one
  = suc zero\n    two = suc one\n\nGoal and error display\n======================\n\n*
  Meta-variables that were introduced by hidden argument `arg' are now\n  printed
  as _arg_number instead of just _number.  [Issue 526]\n\n* Agda expands identifiers
  in anonymous modules when printing.\n  Should make some goals nicer to read. [Issue
  721]\n\n* When a module identifier is ambiguous, Agda tells you if one\n  of them
  is a data type module.  [Issues 318, 705]\n\nType checking\n=============\n\n* Improved
  coverage checker.  The coverage checker splits on\n  arguments that have constructor
  or literal pattern, committing\n  to the left-most split that makes progress.\n
  \ Consider the lookup function for vectors:\n\n    data Fin : Nat → Set where\n
  \     zero : {n : Nat} → Fin (suc n)\n      suc  : {n : Nat} → Fin n → Fin (suc
  n)\n\n    data Vec (A : Set) : Nat → Set where\n      []  : Vec A zero\n      _∷_
  : {n : Nat} → A → Vec A n → Vec A (suc n)\n\n    _!!_ : {A : Set}{n : Nat} → Vec
  A n → Fin n → A\n    (x ∷ xs) !! zero  = x\n    (x ∷ xs) !! suc i = xs !! i\n\n
  \ In Agda up to 2.3.0, this definition is rejected unless we add\n  an absurd clause\n\n
  \   [] !! ()\n\n  This is because the coverage checker committed on splitting\n
  \ on the vector argument, even though this inevitably lead to\n  failed coverage,
  because a case for the empty vector [] is missing.\n\n  The improvement to the coverage
  checker consists on committing\n  only on splits that have a chance of covering,
  since all possible\n  constructor patterns are present.  Thus, Agda will now split\n
  \ first on the Fin argument, since cases for both zero and suc are\n  present.  Then,
  it can split on the Vec argument, since the\n  empty vector is already ruled out
  by instantiating n to a suc _.\n\n* Instance arguments resolution will now consider
  candidates which\n  still expect hidden arguments. For example:\n\n    record Eq
  (A : Set) : Set where\n      field eq : A → A → Bool\n\n    open Eq {{...}}\n\n
  \   eqFin : {n : ℕ} → Eq (Fin n)\n    eqFin = record { eq = primEqFin }\n\n    testFin
  : Bool\n    testFin = eq fin1 fin2\n\n  The type-checker will now resolve the instance
  argument of the eq\n  function to eqFin {_}. This is only done for hidden arguments,
  not\n  instance arguments, so that the instance search stays non-recursive.\n\n*
  Constraint solving: Upgraded Miller patterns to record patterns. [Issue 456]\n\n
  \ Agda now solves meta-variables that are applied to record patterns.\n  A typical
  (but here, artificial) case is:\n\n    record Sigma (A : Set)(B : A -> Set) : Set
  where\n      constructor _,_\n      field\n        fst : A\n        snd : B fst\n\n
  \   test : (A : Set)(B : A -> Set) ->\n      let X : Sigma A B -> Sigma A B\n          X
  = _\n      in  (x : A)(y : B x) -> X (x , y) ≡ (x , y)\n    test A B x y = refl\n\n
  \ This yields a constraint of the form\n\n    _X A B (x , y) := t[x,y]\n\n  (with
  t[x,y] = (x, y)) which is not a Miller pattern.\n  However, Agda now solves this
  as\n\n    _X A B z := t[fst z,snd z].\n\n* Changed: solving recursive constraints.
  \ [Issue 585]\n\n  Until 2.3.0, Agda sometimes inferred values that did not pass
  the\n  termination checker later, or would even make Agda loop.  To prevent this,\n
  \ the occurs check now also looks into the definitions of the current mutual\n  block,
  to avoid constructing recursive solutions.  As a consequence, also\n  terminating
  recursive solutions are no longer found automatically.\n\n  This effects a programming
  pattern where the recursively computed\n  type of a recursive function is left to
  Agda to solve.\n\n    mutual\n\n      T : D -> Set\n      T pattern1 = _\n      T
  pattern2 = _\n\n      f : (d : D) -> T d\n      f pattern1 = rhs1\n      f pattern2
  = rhs2\n\n  This might no longer work from now on.\n  See examples test/fail/Issue585*.agda\n\n*
  Less eager introduction of implicit parameters.  [Issue 679]\n\n  Until Agda 2.3.0,
  trailing hidden parameters were introduced eagerly\n  on the left hand side of a
  definition.  For instance, one could not\n  write\n\n    test : {A : Set} -> Set\n
  \   test = \\ {A} -> A\n\n  because internally, the hidden argument {A : Set} was
  added to the\n  left-hand side, yielding\n\n    test {_} = \\ {A} -> A\n\n  which
  raised a type error.  Now, Agda only introduces the trailing\n  implicit parameters
  it has to, in order to maintain uniform function\n  arity.  For instance, in\n\n
  \   test : Bool -> {A B C : Set} -> Set\n    test true {A}      = A\n    test false
  {B = B} = B\n\n  Agda will introduce parameters A and B in all clauses, but not
  C,\n  resulting in\n\n    test : Bool -> {A B C : Set} -> Set\n    test true  {A}
  {_}     = A\n    test false {_} {B = B} = B\n\n  Note that for checking where-clauses,
  still all hidden trailing\n  parameters are in scope.  For instance:\n\n    id :
  {i : Level}{A : Set i} -> A -> A\n    id = myId\n      where myId : forall {A} ->
  A -> A\n            myId x = x\n\n  To be able to fill in the meta variable _1 in\n\n
  \   myId : {A : Set _1} -> A -> A\n\n  the hidden parameter {i : Level} needs to
  be in scope.\n\n  As a result of this more lazy introduction of implicit parameters,\n
  \ the following code now passes.\n\n    data Unit : Set where\n      unit : Unit\n\n
  \   T : Unit → Set\n    T unit = {u : Unit} → Unit\n\n    test : (u : Unit) → T
  u\n    test unit with unit\n    ... | _ = λ {v} → v\n\n  Before, Agda would eagerly
  introduce the hidden parameter {v} as\n  unnamed left-hand side parameter, leaving
  no way to refer to it.\n\n  The related issue 655 has also been addressed.  It is
  now possible\n  to make `synonym' definitions\n\n    name = expression\n\n  even
  when the type of expression begins with a hidden quantifier.\n  Simple example:\n\n
  \   id2 = id\n\n  That resulted in unsolved metas until 2.3.0.\n\n* Agda detects
  unused arguments and ignores them during equality\n  checking. [Issue 691, solves
  also issue 44.]\n\n  Agda's polarity checker now assigns 'Nonvariant' to arguments\n
  \ that are not actually used (except for absurd matches).  If\n  f's first argument
  is Nonvariant, then f x is definitionally equal\n  to f y regardless of x and y.
  \ It is similar to irrelevance, but\n  does not require user annotation.\n\n  For
  instance, unused module parameters do no longer get in the way:\n\n    module M
  (x : Bool) where\n\n      not : Bool → Bool\n      not true  = false\n      not
  false = true\n\n    open M true\n    open M false renaming (not to not′)\n\n    test
  : (y : Bool) → not y ≡ not′ y\n    test y = refl\n\n  Matching against record or
  absurd patterns does not count as `use',\n  so we get some form of proof irrelevance:\n\n
  \   data ⊥ : Set where\n    record ⊤ : Set where\n      constructor trivial\n\n
  \   data Bool : Set where\n      true false : Bool\n\n    True : Bool → Set\n    True
  true  = ⊤\n    True false = ⊥\n\n    fun : (b : Bool) → True b → Bool\n    fun true
  \ trivial = true\n    fun false ()\n\n    test : (b : Bool) → (x y : True b) → fun
  b x ≡ fun b y\n    test b x y = refl\n\n  More examples in test/succeed/NonvariantPolarity.agda.\n\n
  \ Phantom arguments:  Parameters of record and data types are considered\n  `used'
  even if they are not actually used.  Consider:\n\n    False : Nat → Set\n    False
  zero    = ⊥\n    False (suc n) = False n\n\n    module Invariant where\n      record
  Bla (n : Nat)(p : False n) : Set where\n\n    module Nonvariant where\n      Bla
  : (n : Nat) → False n → Set\n      Bla n p = ⊤\n\n  Even though record `Bla' does
  not use its parameters n and p, they\n  are considered as used, allowing \"phantom
  type\" techniques.\n\n  In contrast, the arguments of function `Bla' are recognized
  as unused.\n  The following code type-checks if we open Invariant but leaves unsolved\n
  \ metas if we open Nonvariant.\n\n    drop-suc : {n : Nat}{p : False n} → Bla (suc
  n) p → Bla n p\n    drop-suc _ = _\n\n    bla : (n : Nat) → {p : False n} → Bla
  n p → ⊥\n    bla zero {()} b\n    bla (suc n) b = bla n (drop-suc b)\n\n  If `Bla'
  is considered invariant, the hidden argument in the recursive\n  call can be inferred
  to be `p'.  If it is considered non-variant, then\n  `Bla n X = Bla n p' does not
  entail `X = p' and the hidden argument\n  remains unsolved.  Since `bla' does not
  actually use its hidden argument,\n  its value is not important and it could be
  searched for.\n  Unfortunately, polarity analysis of `bla' happens only after type\n
  \ checking, thus, the information that `bla' is non-variant in `p' is\n  not available
  yet when meta-variables are solved.\n  (See test/fail/BrokenInferenceDueToNonvariantPolarity.agda)\n\n*
  Agda now expands simple definitions (one clause, terminating)\n  to check whether
  a function is constructor headed. [Issue 747]\n  For instance, the following now
  also works:\n\n    MyPair : Set -> Set -> Set\n    MyPair A B = Pair A B\n\n    Vec
  : Set -> Nat -> Set\n    Vec A zero    = Unit\n    Vec A (suc n) = MyPair A (Vec
  A n)\n\n  Here, Unit and Pair are data or record types.\n\nCompiler backends\n=================\n\n*
  -Werror is now overridable.\n\n  To enable compilation of Haskell modules containing
  warnings, the\n  -Werror flag for the MAlonzo backend has been made overridable.
  If,\n  for example, --ghc-flag=-Wwarn is passed when compiling, one can get\n  away
  with things like:\n\n    data PartialBool : Set where\n      true : PartialBool\n\n
  \   {-# COMPILED_DATA PartialBool Bool True #-}\n\n  The default behavior remains
  as it used to be and rejects the above\n  program.\n\nTools\n=====\n\nEmacs mode\n----------\n\n*
  Asynchronous Emacs mode.\n\n  One can now use Emacs while a buffer is type-checked.
  If the buffer\n  is edited while the type-checker runs, then syntax highlighting
  will\n  not be updated when type-checking is complete.\n\n* Interactive syntax highlighting.\n\n
  \ The syntax highlighting is updated while a buffer is type-checked:\n\n  • At first
  the buffer is highlighted in a somewhat crude way\n    (without go-to-definition
  information for overloaded\n    constructors).\n\n  • If the highlighting level
  is \"interactive\", then the piece of code\n    that is currently being type-checked
  is highlighted as such. (The\n    default is \"non-interactive\".)\n\n  • When a
  mutual block has been type-checked it is highlighted\n    properly (this highlighting
  includes warnings for potential\n    non-termination).\n\n  The highlighting level
  can be controlled via the new configuration\n  variable agda2-highlight-level.\n\n*
  Multiple case-splits can now be performed in one go.\n\n  Consider the following
  example:\n\n    _==_ : Bool → Bool → Bool\n    b₁ == b₂ = {!!}\n\n  If you split
  on \"b₁ b₂\", then you get the following code:\n\n    _==_ : Bool → Bool → Bool\n
  \   true == true = {!!}\n    true == false = {!!}\n    false == true = {!!}\n    false
  == false = {!!}\n\n  The order of the variables matters. Consider the following
  code:\n\n    lookup : ∀ {a n} {A : Set a} → Vec A n → Fin n → A\n    lookup xs i
  = {!!}\n\n  If you split on \"xs i\", then you get the following code:\n\n    lookup
  : ∀ {a n} {A : Set a} → Vec A n → Fin n → A\n    lookup [] ()\n    lookup (x ∷ xs)
  zero = {!!}\n    lookup (x ∷ xs) (suc i) = {!!}\n\n  However, if you split on \"i
  xs\", then you get the following code\n  instead:\n\n    lookup : ∀ {a n} {A : Set
  a} → Vec A n → Fin n → A\n    lookup (x ∷ xs) zero = ?\n    lookup (x ∷ xs) (suc
  i) = ?\n\n  This code is rejected by Agda 2.3.0, but accepted by 2.3.2 thanks\n
  \ to improved coverage checking (see above).\n\n* The Emacs mode now presents information
  about which module is\n  currently being type-checked.\n\n* New global menu entry:
  Information about the character at point.\n\n  If this entry is selected, then information
  about the character at\n  point is displayed, including (in many cases) information
  about how\n  to type the character.\n\n* Commenting/uncommenting the rest of the
  buffer.\n\n  One can now comment or uncomment the rest of the buffer by typing\n
  \ C-c C-x M-; or by selecting the menu entry \"Comment/uncomment the\n  rest of
  the buffer\".\n\n* The Emacs mode now uses the Agda executable instead of GHCi.\n\n
  \ The *ghci* buffer has been renamed to *agda2*.\n\n  A new configuration variable
  has been introduced:\n  agda2-program-name, the name of the Agda executable (by
  default\n  agda).\n\n  The variable agda2-ghci-options has been replaced by\n  agda2-program-args:
  extra arguments given to the Agda executable (by\n  default none).\n\n  If you want
  to limit Agda's memory consumption you can add some\n  arguments to agda2-program-args,
  for instance +RTS -M1.5G -RTS.\n\n* The Emacs mode no longer depends on haskell-mode.\n\n
  \ Users who have customised certain haskell-mode variables (such as\n  haskell-ghci-program-args)
  may want to update their configuration.\n\nLaTeX-backend\n-------------\n\nAn experimental
  LaTeX-backend which does precise highlighting a la the\nHTML-backend and code alignment
  a la lhs2TeX has been added.\n\nHere is a sample input literate Agda file:\n\n  \\documentclass{article}\n\n
  \ \\usepackage{agda}\n\n  \\begin{document}\n\n  The following module declaration
  will be hidden in the output.\n\n  \\AgdaHide{\n  \\begin{code}\n  module M where\n
  \ \\end{code}\n  }\n\n  Two or more spaces can be used to make the backend align
  stuff.\n\n  \\begin{code}\n  data ℕ : Set where\n    zero  : ℕ\n    suc   : ℕ →
  ℕ\n\n  _+_ : ℕ → ℕ → ℕ\n  zero   + n = n\n  suc m  + n = suc (m + n)\n  \\end{code}\n\n
  \ \\end{document}\n\nTo produce an output PDF issue the following commands:\n\n
  \ agda --latex -i . <file>.lagda\n  pdflatex latex/<file>.tex\n\nOnly the top-most
  module is processed, like with lhs2tex and unlike with\nthe HTML-backend. If you
  want to process imported modules you have to\ncall agda --latex manually on each
  of those modules.\n\nThere are still issues related to formatting, see the bug tracker
  for\nmore information:\n\n  https://code.google.com/p/agda/issues/detail?id=697\n\nThe
  default agda.sty might therefore change in backwards-incompatible\nways, as work
  proceeds in trying to resolve those problems.\n\n\nImplemented features:\n\n  *
  Two or more spaces can be used to force alignment of things, like\n    with lhs2tex.
  See example above.\n\n  * The highlighting information produced by the type checker
  is used to\n    generate the output. For example, the data declaration in the example\n
  \   above, produces:\n\n      \\AgdaKeyword{data} \\AgdaDatatype{ℕ} \\AgdaSymbol{:}\n
  \         \\AgdaPrimitiveType{Set} \\AgdaKeyword{where}\n\n    These latex commands
  are defined in agda.sty (which is imported by\n    \\usepackage{agda}) and cause
  the highlighting.\n\n  * The latex-backend checks if agda.sty is found by the latex\n
  \   environment, if it isn't a default agda.sty is copied from Agda's\n    data-dir
  into the working directory (and thus made available to the\n    latex environment).\n\n
  \   If the default agda.sty isn't satisfactory (colors, fonts, spacing,\n    etc)
  then the user can modify it and make put it somewhere where the\n    latex environment
  can find it. Hopefully most aspects should be\n    modifiable via agda.sty rather
  than having to tweak the\n    implementation.\n\n  * --latex-dir can be used to
  change the default output directory.\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.3.0\n------------------------------------------------------------------------\n\nImportant
  changes since 2.2.10:\n\nLanguage\n========\n\n* New more liberal syntax for mutually
  recursive definitions.\n\n  It is no longer necessary to use the 'mutual' keyword
  to define\n  mutually recursive functions or datatypes. Instead, it is enough to\n
  \ declare things before they are used. Instead of\n\n    mutual\n      f : A\n      f
  = a[f, g]\n\n      g : B[f]\n      g = b[f, g]\n\n  you can now write\n\n    f :
  A\n    g : B[f]\n    f = a[f, g]\n    g = b[f, g].\n\n  With the new style you have
  more freedom in choosing the order in\n  which things are type checked (previously
  type signatures were\n  always checked before definitions). Furthermore you can
  mix\n  arbitrary declarations, such as modules and postulates, with\n  mutually
  recursive definitions.\n\n  For data types and records the following new syntax
  is used to\n  separate the declaration from the definition:\n\n    -- Declaration.\n
  \   data Vec (A : Set) : Nat → Set  -- Note the absence of 'where'.\n\n    -- Definition.\n
  \   data Vec A where\n      []   : Vec A zero\n      _::_ : {n : Nat} → A → Vec
  A n → Vec A (suc n)\n\n    -- Declaration.\n    record Sigma (A : Set) (B : A →
  Set) : Set\n\n    -- Definition.\n    record Sigma A B where\n      constructor
  _,_\n      field fst : A\n            snd : B fst\n\n  When making separated declarations/definitions
  private or abstract\n  you should attach the 'private' keyword to the declaration
  and the\n  'abstract' keyword to the definition. For instance, a private,\n  abstract
  function can be defined as\n\n    private\n      f : A\n    abstract\n      f =
  e\n\n  Finally it may be worth noting that the old style of mutually\n  recursive
  definitions is still supported (it basically desugars into\n  the new style).\n\n*
  Pattern matching lambdas.\n\n  Anonymous pattern matching functions can be defined
  using the syntax\n\n    \\ { p11 .. p1n -> e1 ; ... ; pm1 .. pmn -> em }\n\n  (where,
  as usual, \\ and -> can be replaced by λ and →). Internally\n  this is translated
  into a function definition of the following form:\n\n    .extlam p11 .. p1n = e1\n
  \   ...\n    .extlam pm1 .. pmn = em\n\n  This means that anonymous pattern matching
  functions are generative.\n  For instance, refl will not be accepted as an inhabitant
  of the type\n\n    (λ { true → true ; false → false }) ≡\n    (λ { true → true ;
  false → false }),\n\n  because this is equivalent to extlam1 ≡ extlam2 for some
  distinct\n  fresh names extlam1 and extlam2.\n\n  Currently the 'where' and 'with'
  constructions are not allowed in\n  (the top-level clauses of) anonymous pattern
  matching functions.\n\n  Examples:\n\n    and : Bool → Bool → Bool\n    and = λ
  { true x → x ; false _ → false }\n\n    xor : Bool → Bool → Bool\n    xor = λ {
  true  true  → false\n            ; false false → false\n            ; _     _     →
  true\n            }\n\n    fst : {A : Set} {B : A → Set} → Σ A B → A\n    fst =
  λ { (a , b) → a }\n\n    snd : {A : Set} {B : A → Set} (p : Σ A B) → B (fst p)\n
  \   snd = λ { (a , b) → b }\n\n* Record update syntax.\n\n  Assume that we have
  a record type and a corresponding value:\n\n    record MyRecord : Set where\n      field\n
  \       a b c : ℕ\n\n    old : MyRecord\n    old = record { a = 1; b = 2; c = 3
  }\n\n  Then we can update (some of) the record value's fields in the\n  following
  way:\n\n    new : MyRecord\n    new = record old { a = 0; c = 5 }\n\n  Here new
  normalises to record { a = 0; b = 2; c = 5 }. Any\n  expression yielding a value
  of type MyRecord can be used instead of\n  old.\n\n  Record updating is not allowed
  to change types: the resulting value\n  must have the same type as the original
  one, including the record\n  parameters. Thus, the type of a record update can be
  inferred if the type\n  of the original record can be inferred.\n\n  The record
  update syntax is expanded before type checking. When the\n  expression\n\n    record
  old { upd-fields }\n\n  is checked against a record type R, it is expanded to\n\n
  \   let r = old in record { new-fields },\n\n  where old is required to have type
  R and new-fields is defined as\n  follows: for each field x in R,\n\n    - if x
  = e is contained in upd-fields then x = e is included in\n      new-fields, and
  otherwise\n    - if x is an explicit field then x = R.x r is included in\n      new-fields,
  and\n    - if x is an implicit or instance field, then it is omitted from\n      new-fields.\n\n
  \ (Instance arguments are explained below.) The reason for treating\n  implicit
  and instance fields specially is to allow code like the\n  following:\n\n    record
  R : Set where\n      field\n        {length} : ℕ\n        vec      : Vec ℕ length\n
  \       -- More fields…\n\n    xs : R\n    xs = record { vec = 0 ∷ 1 ∷ 2 ∷ [] }\n\n
  \   ys = record xs { vec = 0 ∷ [] }\n\n  Without the special treatment the last
  expression would need to\n  include a new binding for length (for instance \"length
  = _\").\n\n* Record patterns which do not contain data type patterns, but which\n
  \ do contain dot patterns, are no longer rejected.\n\n* When the --without-K flag
  is used literals are now treated as\n  constructors.\n\n* Under-applied functions
  can now reduce.\n\n  Consider the following definition:\n\n    id : {A : Set} →
  A → A\n    id x = x\n\n  Previously the expression id would not reduce. This has
  been changed\n  so that it now reduces to λ x → x. Usually this makes little\n  difference,
  but it can be important in conjunction with 'with'. See\n  issue 365 for an example.\n\n*
  Unused AgdaLight legacy syntax (x y : A; z v : B) for telescopes has\n  been removed.\n\nUniverse
  polymorphism\n---------------------\n\n* Universe polymorphism is now enabled by
  default.\n  Use --no-universe-polymorphism to disable it.\n\n* Universe levels are
  no longer defined as a data type.\n\n  The basic level combinators can be introduced
  in the following way:\n\n  postulate\n    Level : Set\n    zero  : Level\n    suc
  \  : Level → Level\n    max   : Level → Level → Level\n\n  {-# BUILTIN LEVEL     Level
  #-}\n  {-# BUILTIN LEVELZERO zero  #-}\n  {-# BUILTIN LEVELSUC  suc   #-}\n  {-#
  BUILTIN LEVELMAX  max   #-}\n\n* The BUILTIN equality is now required to be universe-polymorphic.\n\n*
  trustMe is now universe-polymorphic.\n\nMeta-variables and unification\n------------------------------\n\n*
  Unsolved meta-variables are now frozen after every mutual block.\n  This means that
  they cannot be instantiated by subsequent code. For\n  instance,\n\n    one : Nat\n
  \   one = _\n\n    bla : one ≡ suc zero\n    bla = refl\n\n  leads to an error now,
  whereas previously it lead to the\n  instantiation of _ with \"suc zero\". If you
  want to make use of the\n  old behaviour, put the two definitions in a mutual block.\n\n
  \ All meta-variables are unfrozen during interactive editing, so that\n  the user
  can fill holes interactively. Note that type-checking of\n  interactively given
  terms is not perfect: Agda sometimes refuses to\n  load a file, even though no complaints
  were raised during the\n  interactive construction of the file. This is because
  certain checks\n  (for instance, positivity) are only invoked when a file is loaded.\n\n*
  Record types can now be inferred.\n\n  If there is a unique known record type with
  fields matching the\n  fields in a record expression, then the type of the expression
  will\n  be inferred to be the record type applied to unknown parameters.\n\n  If
  there is no known record type with the given fields the type\n  checker will give
  an error instead of producing lots of unsolved\n  meta-variables.\n\n  Note that
  \"known record type\" refers to any record type in any\n  imported module, not just
  types which are in scope.\n\n* The occurrence checker distinguishes rigid and strongly
  rigid\n  occurrences [Reed, LFMTP 2009; Abel & Pientka, TLCA 2011].\n\n  The completeness
  checker now accepts the following code:\n\n    h : (n : Nat) → n ≡ suc n → Nat\n
  \   h n ()\n\n  Internally this generates a constraint _n = suc _n where the\n  meta-variable
  _n occurs strongly rigidly, i.e. on a constructor path\n  from the root, in its
  own defining term tree. This is never\n  solvable.\n\n  Weakly rigid recursive occurrences
  may have a solution [Jason Reed's\n  PhD thesis, page 106]:\n\n    test : (k : Nat)
  →\n           let X : (Nat → Nat) → Nat\n               X = _\n           in\n           (f
  : Nat → Nat) → X f ≡ suc (f (X (λ x → k)))\n    test k f = refl\n\n  The constraint
  _X k f = suc (f (_X k (λ x → k))) has the solution\n  _X k f = suc (f (suc k)),
  despite the recursive occurrence of _X.\n  Here _X is not strongly rigid, because
  it occurs under the bound\n  variable f. Previously Agda rejected this code; now
  it instead\n  complains about an unsolved meta-variable.\n\n* Equation constraints
  involving the same meta-variable in the head\n  now trigger pruning [Pientka, PhD,
  Sec. 3.1.2; Abel & Pientka, TLCA\n  2011]. Example:\n\n    same : let X : A → A
  → A → A × A\n               X = _\n           in {x y z : A} → X x y y ≡ (x , y)\n
  \                         × X x x y ≡ X x y y\n    same = refl , refl\n\n  The second
  equation implies that X cannot depend on its second\n  argument. After pruning the
  first equation is linear and can be\n  solved.\n\n* Instance arguments.\n\n  A new
  type of hidden function arguments has been added: instance\n  arguments. This new
  feature is based on influences from Scala's\n  implicits and Agda's existing implicit
  arguments.\n\n  Plain implicit arguments are marked by single braces: {…}. Instance\n
  \ arguments are instead marked by double braces: {{…}}. Example:\n\n    postulate\n
  \     A : Set\n      B : A → Set\n      a : A\n      f : {{a : A}} → B a\n\n  Instead
  of the double braces you can use the symbols ⦃ and ⦄, but\n  these symbols must
  in many cases be surrounded by whitespace. (If\n  you are using Emacs and the Agda
  input method, then you can conjure\n  up the symbols by typing \"\\{{\" and \"\\}}\",
  respectively.)\n\n  Instance arguments behave as ordinary implicit arguments, except
  for\n  one important aspect: resolution of arguments which are not provided\n  explicitly.
  For instance, consider the following code:\n\n    test = f\n\n  Here Agda will notice
  that f's instance argument was not provided\n  explicitly, and try to infer it.
  All definitions in scope at f's\n  call site, as well as all variables in the context,
  are considered.\n  If exactly one of these names has the required type (A), then
  the\n  instance argument will be instantiated to this name.\n\n  This feature can
  be used as an alternative to Haskell type classes.\n  If we define\n\n    record
  Eq (A : Set) : Set where\n      field equal : A → A → Bool,\n\n  then we can define
  the following projection:\n\n    equal : {A : Set} {{eq : Eq A}} → A → A → Bool\n
  \   equal {{eq}} = Eq.equal eq\n\n  Now consider the following expression:\n\n    equal
  false false ∨ equal 3 4\n\n  If the following Eq \"instances\" for Bool and ℕ are
  in scope, and no\n  others, then the expression is accepted:\n\n    eq-Bool : Eq
  Bool\n    eq-Bool = record { equal = … }\n\n    eq-ℕ : Eq ℕ\n    eq-ℕ = record {
  equal = … }\n\n  A shorthand notation is provided to avoid the need to define\n
  \ projection functions manually:\n\n    module Eq-with-implicits = Eq {{...}}\n\n
  \ This notation creates a variant of Eq's record module, where the\n  main Eq argument
  is an instance argument instead of an explicit one.\n  It is equivalent to the following
  definition:\n\n    module Eq-with-implicits {A : Set} {{eq : Eq A}} = Eq eq\n\n
  \ Note that the short-hand notation allows you to avoid naming the\n  \"-with-implicits\"
  module:\n\n    open Eq {{...}}\n\n  Instance argument resolution is not recursive.
  As an example,\n  consider the following \"parametrised instance\":\n\n    eq-List
  : {A : Set} → Eq A → Eq (List A)\n    eq-List {A} eq = record { equal = eq-List-A
  }\n      where\n      eq-List-A : List A → List A → Bool\n      eq-List-A []       []
  \      = true\n      eq-List-A (a ∷ as) (b ∷ bs) = equal a b ∧ eq-List-A as bs\n
  \     eq-List-A _        _        = false\n\n  Assume that the only Eq instances
  in scope are eq-List and eq-ℕ.\n  Then the following code does not type-check:\n\n
  \   test = equal (1 ∷ 2 ∷ []) (3 ∷ 4 ∷ [])\n\n  However, we can make the code work
  by constructing a suitable\n  instance manually:\n\n    test′ = equal (1 ∷ 2 ∷ [])
  (3 ∷ 4 ∷ [])\n      where eq-List-ℕ = eq-List eq-ℕ\n\n  By restricting the \"instance
  search\" to be non-recursive we avoid\n  introducing a new, compile-time-only evaluation
  model to Agda.\n\n  For more information about instance arguments, see Devriese
  &\n  Piessens [ICFP 2011]. Some examples are also available in the\n  examples/instance-arguments
  subdirectory of the Agda distribution.\n\nIrrelevance\n-----------\n\n* Dependent
  irrelevant function types.\n\n  Some examples illustrating the syntax of dependent
  irrelevant\n  function types:\n\n    .(x y : A) → B    .{x y z : A} → B\n    ∀ x
  .y → B        ∀ x .{y} {z} .v → B\n\n  The declaration\n\n    f : .(x : A) → B[x]\n
  \   f x = t[x]\n\n  requires that x is irrelevant both in t[x] and in B[x]. This
  is\n  possible if, for instance, B[x] = B′ x, with B′ : .A → Set.\n\n  Dependent
  irrelevance allows us to define the eliminator for the\n  Squash type:\n\n    record
  Squash (A : Set) : Set where\n      constructor squash\n      field\n        .proof
  : A\n\n    elim-Squash : {A : Set} (P : Squash A → Set)\n                  (ih :
  .(a : A) → P (squash a)) →\n                  (a⁻ : Squash A) → P a⁻\n    elim-Squash
  P ih (squash a) = ih a\n\n  Note that this would not type-check with\n  (ih : (a : A) -> P (squash a)).\n\n*
  Records with only irrelevant fields.\n\n  The following now works:\n\n    record
  IsEquivalence {A : Set} (_≈_ : A → A → Set) : Set where\n      field\n        .refl
  \ : Reflexive _≈_\n        .sym   : Symmetric _≈_\n        .trans : Transitive _≈_\n\n
  \   record Setoid : Set₁ where\n      infix 4 _≈_\n      field\n        Carrier
  \       : Set\n        _≈_            : Carrier → Carrier → Set\n        .isEquivalence
  : IsEquivalence _≈_\n\n      open IsEquivalence isEquivalence public\n\n  Previously
  Agda complained about the application\n  IsEquivalence isEquivalence, because isEquivalence
  is irrelevant and\n  the IsEquivalence module expected a relevant argument. Now,
  when\n  record modules are generated for records consisting solely of\n  irrelevant
  arguments, the record parameter is made irrelevant:\n\n    module IsEquivalence
  {A : Set} {_≈_ : A → A → Set}\n                         .(r : IsEquivalence {A =
  A} _≈_) where\n      …\n\n* Irrelevant things are no longer erased internally. This
  means that\n  they are printed as ordinary terms, not as \"_\" as before.\n\n* The
  new flag --experimental-irrelevance enables irrelevant universe\n  levels and matching
  on irrelevant data when only one constructor is\n  available. These features are
  very experimental and likely to change\n  or disappear.\n\nReflection\n----------\n\n*
  The reflection API has been extended to mirror features like\n  irrelevance, instance
  arguments and universe polymorphism, and to\n  give (limited) access to definitions.
  For completeness all the\n  builtins and primitives are listed below:\n\n    --
  Names.\n\n    postulate Name : Set\n\n    {-# BUILTIN QNAME Name #-}\n\n    primitive\n
  \     -- Equality of names.\n      primQNameEquality : Name → Name → Bool\n\n    --
  Is the argument visible (explicit), hidden (implicit), or an\n    -- instance argument?\n\n
  \   data Visibility : Set where\n      visible hidden instance : Visibility\n\n
  \   {-# BUILTIN HIDING   Visibility #-}\n    {-# BUILTIN VISIBLE  visible    #-}\n
  \   {-# BUILTIN HIDDEN   hidden     #-}\n    {-# BUILTIN INSTANCE instance   #-}\n\n
  \   -- Arguments can be relevant or irrelevant.\n\n    data Relevance : Set where\n
  \     relevant irrelevant : Relevance\n\n    {-# BUILTIN RELEVANCE  Relevance  #-}\n
  \   {-# BUILTIN RELEVANT   relevant   #-}\n    {-# BUILTIN IRRELEVANT irrelevant
  #-}\n\n    -- Arguments.\n\n    data Arg A : Set where\n      arg : (v : Visibility)
  (r : Relevance) (x : A) → Arg A\n\n    {-# BUILTIN ARG    Arg #-}\n    {-# BUILTIN
  ARGARG arg #-}\n\n    -- Terms.\n\n    mutual\n      data Term : Set where\n        --
  Variable applied to arguments.\n        var     : (x : ℕ) (args : List (Arg Term))
  → Term\n        -- Constructor applied to arguments.\n        con     : (c : Name)
  (args : List (Arg Term)) → Term\n        -- Identifier applied to arguments.\n        def
  \    : (f : Name) (args : List (Arg Term)) → Term\n        -- Different kinds of
  λ-abstraction.\n        lam     : (v : Visibility) (t : Term) → Term\n        --
  Pi-type.\n        pi      : (t₁ : Arg Type) (t₂ : Type) → Term\n        -- A sort.\n
  \       sort    : Sort → Term\n        -- Anything else.\n        unknown : Term\n\n
  \     data Type : Set where\n        el : (s : Sort) (t : Term) → Type\n\n      data
  Sort : Set where\n        -- A Set of a given (possibly neutral) level.\n        set
  \    : (t : Term) → Sort\n        -- A Set of a given concrete level.\n        lit
  \    : (n : ℕ) → Sort\n        -- Anything else.\n        unknown : Sort\n\n    {-#
  BUILTIN AGDASORT            Sort    #-}\n    {-# BUILTIN AGDATYPE            Type
  \   #-}\n    {-# BUILTIN AGDATERM            Term    #-}\n    {-# BUILTIN AGDATERMVAR
  \        var     #-}\n    {-# BUILTIN AGDATERMCON         con     #-}\n    {-# BUILTIN
  AGDATERMDEF         def     #-}\n    {-# BUILTIN AGDATERMLAM         lam     #-}\n
  \   {-# BUILTIN AGDATERMPI          pi      #-}\n    {-# BUILTIN AGDATERMSORT        sort
  \   #-}\n    {-# BUILTIN AGDATERMUNSUPPORTED unknown #-}\n    {-# BUILTIN AGDATYPEEL
  \         el      #-}\n    {-# BUILTIN AGDASORTSET         set     #-}\n    {-#
  BUILTIN AGDASORTLIT         lit     #-}\n    {-# BUILTIN AGDASORTUNSUPPORTED unknown
  #-}\n\n    postulate\n      -- Function definition.\n      Function  : Set\n      --
  Data type definition.\n      Data-type : Set\n      -- Record type definition.\n
  \     Record    : Set\n\n    {-# BUILTIN AGDAFUNDEF    Function  #-}\n    {-# BUILTIN
  AGDADATADEF   Data-type #-}\n    {-# BUILTIN AGDARECORDDEF Record    #-}\n\n    --
  Definitions.\n\n    data Definition : Set where\n      function     : Function  →
  Definition\n      data-type    : Data-type → Definition\n      record′      : Record
  \   → Definition\n      constructor′ : Definition\n      axiom        : Definition\n
  \     primitive′   : Definition\n\n    {-# BUILTIN AGDADEFINITION                Definition
  \  #-}\n    {-# BUILTIN AGDADEFINITIONFUNDEF          function     #-}\n    {-#
  BUILTIN AGDADEFINITIONDATADEF         data-type    #-}\n    {-# BUILTIN AGDADEFINITIONRECORDDEF
  \      record′      #-}\n    {-# BUILTIN AGDADEFINITIONDATACONSTRUCTOR constructor′
  #-}\n    {-# BUILTIN AGDADEFINITIONPOSTULATE       axiom        #-}\n    {-# BUILTIN
  AGDADEFINITIONPRIMITIVE       primitive′   #-}\n\n    primitive\n      -- The type
  of the thing with the given name.\n      primQNameType        : Name → Type\n      --
  The definition of the thing with the given name.\n      primQNameDefinition  : Name
  → Definition\n      -- The constructors of the given data type.\n      primDataConstructors
  : Data-type → List Name\n\n  As an example the expression\n\n    primQNameType (quote
  zero)\n\n  is definitionally equal to\n\n    el (lit 0) (def (quote ℕ) [])\n\n  (if
  zero is a constructor of the data type ℕ).\n\n* New keyword: unquote.\n\n  The construction
  \"unquote t\" converts a representation of an Agda term\n  to actual Agda code in
  the following way:\n\n  1. The argument t must have type Term (see the reflection
  API above).\n\n  2. The argument is normalised.\n\n  3. The entire construction
  is replaced by the normal form, which is\n     treated as syntax written by the
  user and type-checked in the\n     usual way.\n\n  Examples:\n\n    test : unquote
  (def (quote ℕ) []) ≡ ℕ\n    test = refl\n\n    id : (A : Set) → A → A\n    id =
  unquote (lam visible (lam visible (var 0 [])))\n\n    id-ok : id ≡ (λ A (x : A)
  → x)\n    id-ok = refl\n\n* New keyword: quoteTerm.\n\n  The construction \"quoteTerm t\"
  is similar to \"quote n\", but whereas\n  quote is restricted to names n, quoteTerm
  accepts terms t. The\n  construction is handled in the following way:\n\n  1. The
  type of t is inferred. The term t must be type-correct.\n\n  2. The term t is normalised.\n\n
  \ 3. The construction is replaced by the Term representation (see the\n     reflection
  API above) of the normal form. Any unsolved metavariables\n     in the term are
  represented by the \"unknown\" term constructor.\n\n  Examples:\n\n    test₁ : quoteTerm
  (λ {A : Set} (x : A) → x) ≡\n            lam hidden (lam visible (var 0 []))\n    test₁
  = refl\n\n    -- Local variables are represented as de Bruijn indices.\n    test₂
  : (λ {A : Set} (x : A) → quoteTerm x) ≡ (λ x → var 0 [])\n    test₂ = refl\n\n    --
  Terms are normalised before being quoted.\n    test₃ : quoteTerm (0 + 0) ≡ con (quote
  zero) []\n    test₃ = refl\n\nCompiler backends\n=================\n\nMAlonzo\n-------\n\n*
  The MAlonzo backend's FFI now handles universe polymorphism in a\n  better way.\n\n
  \ The translation of Agda types and kinds into Haskell now supports\n  universe-polymorphic
  postulates. The core changes are that the\n  translation of function types has been
  changed from\n\n    T[[ Pi (x : A) B ]] =\n      if A has a Haskell kind then\n
  \       forall x. () -> T[[ B ]]\n      else if x in fv B then\n        undef\n
  \     else\n        T[[ A ]] -> T[[ B ]]\n\n  into\n\n    T[[ Pi (x : A) B ]] =\n
  \     if x in fv B then\n        forall x. T[[ A ]] -> T[[ B ]]  -- Note: T[[A]]
  not Unit.\n      else\n        T[[ A ]] -> T[[ B ]],\n\n  and that the translation
  of constants (postulates, constructors and\n  literals) has been changed from\n\n
  \   T[[ k As ]] =\n      if COMPILED_TYPE k T then\n        T T[[ As ]]\n      else\n
  \       undef\n\n  into\n\n    T[[ k As ]] =\n      if COMPILED_TYPE k T then\n
  \       T T[[ As ]]\n      else if COMPILED k E then\n        ()\n      else\n        undef.\n\n
  \ For instance, assuming a Haskell definition\n\n    type AgdaIO a b = IO b,\n\n
  \ we can set up universe-polymorphic IO in the following way:\n\n    postulate\n
  \     IO     : ∀ {ℓ} → Set ℓ → Set ℓ\n      return : ∀ {a} {A : Set a} → A → IO
  A\n      _>>=_  : ∀ {a b} {A : Set a} {B : Set b} →\n               IO A → (A →
  IO B) → IO B\n\n    {-# COMPILED_TYPE IO AgdaIO              #-}\n    {-# COMPILED
  return  (\\_ _ -> return)    #-}\n    {-# COMPILED _>>=_   (\\_ _ _ _ -> (>>=))
  #-}\n\n  This is accepted because (assuming that the universe level type is\n  translated
  to the Haskell unit type \"()\")\n\n    (\\_ _ -> return)\n      : forall a. ()
  -> forall b. () -> b -> AgdaIO a b\n      = T [[ ∀ {a} {A : Set a} → A → IO A ]]\n\n
  \ and\n\n    (\\_ _ _ _ -> (>>=))\n      : forall a. () -> forall b. () ->\n          forall
  c. () -> forall d. () ->\n            AgdaIO a c -> (c -> AgdaIO b d) -> AgdaIO
  b d\n      = T [[ ∀ {a b} {A : Set a} {B : Set b} →\n               IO A → (A →
  IO B) → IO B ]].\n\nEpic\n----\n\n* New Epic backend pragma: STATIC.\n\n  In the
  Epic backend, functions marked with the STATIC pragma will be\n  normalised before
  compilation. Example usage:\n\n    {-# STATIC power #-}\n\n    power : ℕ → ℕ → ℕ\n
  \   power 0       x = 1\n    power 1       x = x\n    power (suc n) x = power n
  x * x\n\n  Occurrences of \"power 4 x\" will be replaced by \"((x * x) * x) * x\".\n\n*
  Some new optimisations have been implemented in the Epic backend:\n\n  - Removal
  of unused arguments.\n\n  A worker/wrapper transformation is performed so that unused\n
  \ arguments can be removed by Epic's inliner. For instance, the map\n  function
  is transformed in the following way:\n\n    map_wrap : (A B : Set) → (A → B) → List
  A → List B\n    map_wrap A B f xs = map_work f xs\n\n    map_work f []       = []\n
  \   map_work f (x ∷ xs) = f x ∷ map_work f xs\n\n  If map_wrap is inlined (which
  it will be in any saturated call),\n  then A and B disappear in the generated code.\n\n
  \ Unused arguments are found using abstract interpretation. The bodies\n  of all
  functions in a module are inspected to decide which variables\n  are used. The behaviour
  of postulates is approximated based on their\n  types. Consider return, for instance:\n\n
  \   postulate return : {A : Set} → A → IO A\n\n  The first argument of return can
  be removed, because it is of type\n  Set and thus cannot affect the outcome of a
  program at runtime.\n\n  - Injection detection.\n\n  At runtime many functions may
  turn out to be inefficient variants of\n  the identity function. This is especially
  true after forcing.\n  Injection detection replaces some of these functions with
  more\n  efficient versions. Example:\n\n    inject : {n : ℕ} → Fin n → Fin (1 +
  n)\n    inject {suc n} zero    = zero\n    inject {suc n} (suc i) = suc (inject
  {n} i)\n\n  Forcing removes the Fin constructors' ℕ arguments, so this function\n
  \ is an inefficient identity function that can be replaced by the\n  following one:\n\n
  \   inject {_} x = x\n\n  To actually find this function, we make the induction
  hypothesis\n  that inject is an identity function in its second argument and look\n
  \ at the branches of the function to decide if this holds.\n\n  Injection detection
  also works over data type barriers. Example:\n\n    forget : {A : Set} {n : ℕ} →
  Vec A n → List A\n    forget []       = []\n    forget (x ∷ xs) = x ∷ forget xs\n\n
  \ Given that the constructor tags (in the compiled Epic code) for\n  Vec.[] and
  List.[] are the same, and that the tags for Vec._∷_ and\n  List._∷_ are also the
  same, this is also an identity function. We\n  can hence replace the definition
  with the following one:\n\n    forget {_} xs = xs\n\n  To get this to apply as often
  as possible, constructor tags are\n  chosen /after/ injection detection has been
  run, in a way to make as\n  many functions as possible injections.\n\n  Constructor
  tags are chosen once per source file, so it may be\n  advantageous to define conversion
  functions like forget in the same\n  module as one of the data types. For instance,
  if Vec.agda imports\n  List.agda, then the forget function should be put in Vec.agda
  to\n  ensure that vectors and lists get the same tags (unless some other\n  injection
  function, which puts different constraints on the tags, is\n  prioritised).\n\n
  \ - Smashing.\n\n  This optimisation finds types whose values are inferable at runtime:\n\n
  \   * A data type with only one constructor where all fields are\n      inferable
  is itself inferable.\n    * Set ℓ is inferable (as it has no runtime representation).\n\n
  \ A function returning an inferable data type can be smashed, which\n  means that
  it is replaced by a function which simply returns the\n  inferred value.\n\n  An
  important example of an inferable type is the usual propositional\n  equality type
  (_≡_). Any function returning a propositional equality\n  can simply return the
  reflexivity constructor directly without\n  computing anything.\n\n  This optimisation
  makes more arguments unused. It also makes the\n  Epic code size smaller, which
  in turn speeds up compilation.\n\nJavaScript\n----------\n\n* ECMAScript compiler
  backend.\n\n  A new compiler backend is being implemented, targetting ECMAScript\n
  \ (also known as JavaScript), with the goal of allowing Agda programs\n  to be run
  in browsers or other ECMAScript environments.\n\n  The backend is still at an experimental
  stage: the core language is\n  implemented, but many features are still missing.\n\n
  \ The ECMAScript compiler can be invoked from the command line using\n  the flag
  --js:\n\n    agda --js --compile-dir=<DIR> <FILE>.agda\n\n  Each source <FILE>.agda
  is compiled into an ECMAScript target\n  <DIR>/jAgda.<TOP-LEVEL MODULE NAME>.js.
  The compiler can also be\n  invoked using the Emacs mode (the variable agda2-backend
  controls\n  which backend is used).\n\n  Note that ECMAScript is a strict rather
  than lazy language. Since\n  Agda programs are total, this should not impact program
  semantics,\n  but it may impact their space or time usage.\n\n  ECMAScript does
  not support algebraic datatypes or pattern-matching.\n  These features are translated
  to a use of the visitor pattern. For\n  instance, the standard library's List data
  type and null function\n  are translated into the following code:\n\n    exports[\"List\"]
  = {};\n    exports[\"List\"][\"[]\"] = function (x0) {\n        return x0[\"[]\"]();\n
  \     };\n    exports[\"List\"][\"_∷_\"] = function (x0) {\n        return function
  (x1) {\n          return function (x2) {\n            return x2[\"_∷_\"](x0, x1);\n
  \         };\n        };\n      };\n\n    exports[\"null\"] = function (x0) {\n
  \       return function (x1) {\n          return function (x2) {\n            return
  x2({\n              \"[]\": function () {\n                return jAgda_Data_Bool[\"Bool\"][\"true\"];\n
  \             },\n              \"_∷_\": function (x3, x4) {\n                return
  jAgda_Data_Bool[\"Bool\"][\"false\"];\n              }\n            });\n          };\n
  \       };\n      };\n\n  Agda records are translated to ECMAScript objects, preserving
  field\n  names.\n\n  Top-level Agda modules are translated to ECMAScript modules,\n
  \ following the common.js module specification. A top-level Agda\n  module \"Foo.Bar\"
  is translated to an ECMAScript module\n  \"jAgda.Foo.Bar\".\n\n  The ECMAScript
  compiler does not compile to Haskell, so the pragmas\n  related to the Haskell FFI
  (IMPORT, COMPILED_DATA and COMPILED) are\n  not used by the ECMAScript backend.
  Instead, there is a COMPILED_JS\n  pragma which may be applied to any declaration.
  For postulates,\n  primitives, functions and values, it gives the ECMAScript code
  to be\n  emitted by the compiler. For data types, it gives a function which\n  is
  applied to a value of that type, and a visitor object. For\n  instance, a binding
  of natural numbers to ECMAScript integers\n  (ignoring overflow errors) is:\n\n
  \   data ℕ : Set where\n      zero : ℕ\n      suc  : ℕ → ℕ\n\n    {-# COMPILED_JS
  ℕ function (x,v) {\n        if (x < 1) { return v.zero(); } else { return v.suc(x-1);
  }\n      } #-}\n    {-# COMPILED_JS zero 0 #-}\n    {-# COMPILED_JS suc function
  (x) { return x+1; } #-}\n\n    _+_ : ℕ → ℕ → ℕ\n    zero  + n = n\n    suc m + n
  = suc (m + n)\n\n    {-# COMPILED_JS _+_ function (x) { return function (y) {\n
  \                         return x+y; };\n      } #-}\n\n  To allow FFI code to
  be optimised, the ECMAScript in a COMPILED_JS\n  declaration is parsed, using a
  simple parser that recognises a pure\n  functional subset of ECMAScript, consisting
  of functions, function\n  applications, return, if-statements, if-expressions,\n
  \ side-effect-free binary operators (no precedence, left associative),\n  side-effect-free
  prefix operators, objects (where all member names\n  are quoted), field accesses,
  and string and integer literals.\n  Modules may be imported using the require(\"<module-id>\")
  syntax: any\n  impure code, or code outside the supported fragment, can be placed\n
  \ in a module and imported.\n\nTools\n=====\n\n* New flag --safe, which can be used
  to type-check untrusted code.\n\n  This flag disables postulates, primTrustMe, and
  \"unsafe\" OPTION\n  pragmas, some of which are known to make Agda inconsistent.\n\n
  \ Rejected pragmas:\n\n    --allow-unsolved-metas\n    --experimental-irrelevance\n
  \   --guardedness-preserving-type-construtors\n    --injective-type-constructors\n
  \   --no-coverage-check\n    --no-positivity-check\n    --no-termination-check\n
  \   --sized-types\n    --type-in-type\n\n  Note that, at the moment, it is not possible
  to define the universe\n  level or coinduction primitives when --safe is used (because
  they\n  must be introduced as postulates). This can be worked around by\n  type-checking
  trusted files in a first pass, without using --safe,\n  and then using --safe in
  a second pass. Modules which have already\n  been type-checked are not re-type-checked
  just because --safe is\n  used.\n\n* Dependency graphs.\n\n  The new flag --dependency-graph=FILE
  can be used to generate a DOT\n  file containing a module dependency graph. The
  generated file (FILE)\n  can be rendered using a tool like dot.\n\n* The --no-unreachable-check
  flag has been removed.\n\n* Projection functions are highlighted as functions instead
  of as\n  fields. Field names (in record definitions and record values) are\n  still
  highlighted as fields.\n\n* Support for jumping to positions mentioned in the information\n
  \ buffer has been added.\n\n* The \"make install\" command no longer installs Agda
  globally (by\n  default).\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.2.10\n------------------------------------------------------------------------\n\nImportant
  changes since 2.2.8:\n\nLanguage\n--------\n\n* New flag: --without-K.\n\n  This
  flag makes pattern matching more restricted. If the flag is\n  activated, then Agda
  only accepts certain case-splits. If the type\n  of the variable to be split is
  D pars ixs, where D is a data (or\n  record) type, pars stands for the parameters,
  and ixs the indices,\n  then the following requirements must be satisfied:\n\n  *
  The indices ixs must be applications of constructors to distinct\n    variables.\n\n
  \ * These variables must not be free in pars.\n\n  The intended purpose of --without-K
  is to enable experiments with a\n  propositional equality without the K rule. Let
  us define\n  propositional equality as follows:\n\n    data _≡_ {A : Set} : A →
  A → Set where\n      refl : ∀ x → x ≡ x\n\n  Then the obvious implementation of
  the J rule is accepted:\n\n    J : {A : Set} (P : {x y : A} → x ≡ y → Set) →\n        (∀
  x → P (refl x)) →\n        ∀ {x y} (x≡y : x ≡ y) → P x≡y\n    J P p (refl x) = p
  x\n\n  The same applies to Christine Paulin-Mohring's version of the J rule:\n\n
  \   J′ : {A : Set} {x : A} (P : {y : A} → x ≡ y → Set) →\n         P (refl x) →\n
  \        ∀ {y} (x≡y : x ≡ y) → P x≡y\n    J′ P p (refl x) = p\n\n  On the other
  hand, the obvious implementation of the K rule is not\n  accepted:\n\n    K : {A
  : Set} (P : {x : A} → x ≡ x → Set) →\n        (∀ x → P (refl x)) →\n        ∀ {x}
  (x≡x : x ≡ x) → P x≡x\n    K P p (refl x) = p x\n\n  However, we have /not/ proved
  that activation of --without-K ensures\n  that the K rule cannot be proved in some
  other way.\n\n* Irrelevant declarations.\n\n  Postulates and functions can be marked
  as irrelevant by prefixing\n  the name with a dot when the name is declared. Example:\n\n
  \   postulate\n      .irrelevant : {A : Set} → .A → A\n\n  Irrelevant names may
  only be used in irrelevant positions or in\n  definitions of things which have been
  declared irrelevant.\n\n  The axiom irrelevant above can be used to define a projection
  from\n  an irrelevant record field:\n\n    data Subset (A : Set) (P : A → Set) :
  Set where\n      _#_ : (a : A) → .(P a) → Subset A P\n\n    elem : ∀ {A P} → Subset
  A P → A\n    elem (a # p) = a\n\n    .certificate : ∀ {A P} (x : Subset A P) → P
  (elem x)\n    certificate (a # p) = irrelevant p\n\n  The right-hand side of certificate
  is relevant, so we cannot define\n\n    certificate (a # p) = p\n\n  (because p
  is irrelevant). However, certificate is declared to be\n  irrelevant, so it can
  use the axiom irrelevant. Furthermore the\n  first argument of the axiom is irrelevant,
  which means that\n  irrelevant p is well-formed.\n\n  As shown above the axiom irrelevant
  justifies irrelevant\n  projections. Previously no projections were generated for
  irrelevant\n  record fields, such as the field certificate in the following\n  record
  type:\n\n    record Subset (A : Set) (P : A → Set) : Set where\n      constructor
  _#_\n      field\n        elem         : A\n        .certificate : P elem\n\n  Now
  projections are generated automatically for irrelevant fields\n  (unless the flag
  --no-irrelevant-projections is used). Note that\n  irrelevant projections are highly
  experimental.\n\n* Termination checker recognises projections.\n\n  Projections
  now preserve sizes, both in patterns and expressions.\n  Example:\n\n    record
  Wrap (A : Set) : Set where\n      constructor wrap\n      field\n        unwrap
  : A\n\n    open Wrap public\n\n    data WNat : Set where\n      zero : WNat\n      suc
  \ : Wrap WNat → WNat\n\n    id : WNat → WNat\n    id zero    = zero\n    id (suc
  w) = suc (wrap (id (unwrap w)))\n\n  In the structural ordering unwrap w ≤ w. This
  means that\n\n    unwrap w ≤ w < suc w,\n\n  and hence the recursive call to id
  is accepted.\n\n  Projections also preserve guardedness.\n\nTools\n-----\n\n* Hyperlinks
  for top-level module names now point to the start of the\n  module rather than to
  the declaration of the module name. This\n  applies both to the Emacs mode and to
  the output of agda --html.\n\n* Most occurrences of record field names are now highlighted
  as\n  \"fields\". Previously many occurrences were highlighted as\n  \"functions\".\n\n*
  Emacs mode: It is no longer possible to change the behaviour of the\n  TAB key by
  customising agda2-indentation.\n\n* Epic compiler backend.\n\n  A new compiler backend
  is being implemented. This backend makes use\n  of Edwin Brady's language Epic\n
  \ (http://www.cs.st-andrews.ac.uk/~eb/epic.php) and its compiler. The\n  backend
  should handle most Agda code, but is still at an\n  experimental stage: more testing
  is needed, and some things written\n  below may not be entirely true.\n\n  The Epic
  compiler can be invoked from the command line using the\n  flag --epic:\n\n    agda
  --epic --epic-flag=<EPIC-FLAG> --compile-dir=<DIR> <FILE>.agda\n\n  The --epic-flag
  flag can be given multiple times; each flag is given\n  verbatim to the Epic compiler
  (in the given order). The resulting\n  executable is named after the main module
  and placed in the\n  directory specified by the --compile-dir flag (default: the
  project\n  root). Intermediate files are placed in a subdirectory called Epic.\n\n
  \ The backend requires that there is a definition named main. This\n  definition
  should be a value of type IO Unit, but at the moment this\n  is not checked (so
  it is easy to produce a program which segfaults).\n  Currently the backend represents
  actions of type IO A as functions\n  from Unit to A, and main is applied to the
  unit value.\n\n  The Epic compiler compiles via C, not Haskell, so the pragmas\n
  \ related to the Haskell FFI (IMPORT, COMPILED_DATA and COMPILED) are\n  not used
  by the Epic backend. Instead there is a new pragma\n  COMPILED_EPIC. This pragma
  is used to give Epic code for postulated\n  definitions (Epic code can in turn call
  C code). The form of the\n  pragma is {-# COMPILED_EPIC def code #-}, where def
  is the name of\n  an Agda postulate and code is some Epic code which should include\n
  \ the function arguments, return type and function body. As an example\n  the IO
  monad can be defined as follows:\n\n    postulate\n      IO     : Set → Set\n      return
  : ∀ {A} → A → IO A\n      _>>=_  : ∀ {A B} → IO A → (A → IO B) → IO B\n\n    {-#
  COMPILED_EPIC return (u : Unit, a : Any) -> Any =\n                        ioreturn(a)
  #-}\n    {-# COMPILED_EPIC\n          _>>=_ (u1 : Unit, u2 : Unit, x : Any, f :
  Any) -> Any =\n            iobind(x,f) #-}\n\n  Here ioreturn and iobind are Epic
  functions which are defined in the\n  file AgdaPrelude.e which is always included.\n\n
  \ By default the backend will remove so-called forced constructor\n  arguments (and
  case-splitting on forced variables will be\n  rewritten). This optimisation can
  be disabled by using the flag\n  --no-forcing.\n\n  All data types which look like
  unary natural numbers after forced\n  constructor arguments have been removed (i.e.
  types with two\n  constructors, one nullary and one with a single recursive argument)\n
  \ will be represented as \"BigInts\". This applies to the standard Fin\n  type,
  for instance.\n\n  The backend supports Agda's primitive functions and the BUILTIN\n
  \ pragmas. If the BUILTIN pragmas for unary natural numbers are used,\n  then some
  operations, like addition and multiplication, will use\n  more efficient \"BigInt\"
  operations.\n\n  If you want to make use of the Epic backend you need to install
  some\n  dependencies, see the README.\n\n* The Emacs mode can compile using either
  the MAlonzo or the Epic\n  backend. The variable agda2-backend controls which backend
  is used.\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.2.8\n------------------------------------------------------------------------\n\nImportant
  changes since 2.2.6:\n\nLanguage\n--------\n\n* Record pattern matching.\n\n  It
  is now possible to pattern match on named record constructors.\n  Example:\n\n    record
  Σ (A : Set) (B : A → Set) : Set where\n      constructor _,_\n      field\n        proj₁
  : A\n        proj₂ : B proj₁\n\n    map : {A B : Set} {P : A → Set} {Q : B → Set}\n
  \         (f : A → B) → (∀ {x} → P x → Q (f x)) →\n          Σ A P → Σ B Q\n    map
  f g (x , y) = (f x , g y)\n\n  The clause above is internally translated into the
  following one:\n\n    map f g p = (f (Σ.proj₁ p) , g (Σ.proj₂ p))\n\n  Record patterns
  containing data type patterns are not translated.\n  Example:\n\n    add : ℕ × ℕ
  → ℕ\n    add (zero  , n) = n\n    add (suc m , n) = suc (add (m , n))\n\n  Record
  patterns which do not contain data type patterns, but which\n  do contain dot patterns,
  are currently rejected. Example:\n\n    Foo : {A : Set} (p₁ p₂ : A × A) → proj₁
  p₁ ≡ proj₁ p₂ → Set₁\n    Foo (x , y) (.x , y′) refl = Set\n\n* Proof irrelevant
  function types.\n\n  Agda now supports irrelevant non-dependent function types:\n\n
  \   f : .A → B\n\n  This type implies that f does not depend computationally on
  its\n  argument. One intended use case is data structures with embedded\n  proofs,
  like sorted lists:\n\n    postulate\n      _≤_ : ℕ → ℕ → Set\n      p₁  : 0 ≤ 1\n
  \     p₂  : 0 ≤ 1\n\n    data SList (bound : ℕ) : Set where\n      []    : SList
  bound\n      scons : (head : ℕ) →\n              .(head ≤ bound) →\n              (tail
  : SList head) →\n              SList bound\n\n  The effect of the irrelevant type
  in the signature of scons is that\n  scons's second argument is never inspected
  after Agda has ensured\n  that it has the right type. It is even thrown away, leading
  to\n  smaller term sizes and hopefully some gain in efficiency. The\n  type-checker
  ignores irrelevant arguments when checking equality, so\n  two lists can be equal
  even if they contain different proofs:\n\n    l₁ : SList 1\n    l₁ = scons 0 p₁
  []\n\n    l₂ : SList 1\n    l₂ = scons 0 p₂ []\n\n    l₁≡l₂ : l₁ ≡ l₂\n    l₁≡l₂
  = refl\n\n  Irrelevant arguments can only be used in irrelevant contexts.\n  Consider
  the following subset type:\n\n    data Subset (A : Set) (P : A → Set) : Set where\n
  \     _#_ : (elem : A) → .(P elem) → Subset A P\n\n  The following two uses are
  fine:\n\n    elimSubset : ∀ {A C : Set} {P} →\n                 Subset A P → ((a
  : A) → .(P a) → C) → C\n    elimSubset (a # p) k = k a p\n\n    elem : {A : Set}
  {P : A → Set} → Subset A P → A\n    elem (x # p) = x\n\n  However, if we try to
  project out the proof component, then Agda\n  complains that \"variable p is declared
  irrelevant, so it cannot be\n  used here\":\n\n    prjProof : ∀ {A P} (x : Subset
  A P) → P (elem x)\n    prjProof (a # p) = p\n\n  Matching against irrelevant arguments
  is also forbidden, except in\n  the case of irrefutable matches (record constructor
  patterns which\n  have been translated away). For instance, the match against the\n
  \ pattern (p , q) here is accepted:\n\n    elim₂ : ∀ {A C : Set} {P Q : A → Set}
  →\n            Subset A (λ x → Σ (P x) (λ _ → Q x)) →\n            ((a : A) → .(P
  a) → .(Q a) → C) → C\n    elim₂ (a # (p , q)) k = k a p q\n\n  Absurd matches ()
  are also allowed.\n\n  Note that record fields can also be irrelevant. Example:\n\n
  \   record Subset (A : Set) (P : A → Set) : Set where\n      constructor _#_\n      field\n
  \       elem   : A\n        .proof : P elem\n\n  Irrelevant fields are never in
  scope, neither inside nor outside the\n  record. This means that no record field
  can depend on an irrelevant\n  field, and furthermore projections are not defined
  for such fields.\n  Irrelevant fields can only be accessed using pattern matching,
  as in\n  elimSubset above.\n\n  Irrelevant function types were added very recently,
  and have not\n  been subjected to much experimentation yet, so do not be surprised\n
  \ if something is changed before the next release. For instance,\n  dependent irrelevant
  function spaces (.(x : A) → B) might be added\n  in the future.\n\n* Mixfix binders.\n\n
  \ It is now possible to declare user-defined syntax that binds\n  identifiers. Example:\n\n
  \   postulate\n      State  : Set → Set → Set\n      put    : ∀ {S} → S → State
  S ⊤\n      get    : ∀ {S} → State S S\n      return : ∀ {A S} → A → State S A\n
  \     bind   : ∀ {A B S} → State S B → (B → State S A) → State S A\n\n    syntax
  bind e₁ (λ x → e₂) = x ← e₁ , e₂\n\n    increment : State ℕ ⊤\n    increment = x
  ← get ,\n                put (1 + x)\n\n  The syntax declaration for bind implies
  that x is in scope in e₂,\n  but not in e₁.\n\n  You can give fixity declarations
  along with syntax declarations:\n\n    infixr 40 bind\n    syntax bind e₁ (λ x →
  e₂) = x ← e₁ , e₂\n\n  The fixity applies to the syntax, not the name; syntax declarations\n
  \ are also restricted to ordinary, non-operator names. The following\n  declaration
  is disallowed:\n\n    syntax _==_ x y = x === y\n\n  Syntax declarations must also
  be linear; the following declaration\n  is disallowed:\n\n    syntax wrong x = x
  + x\n\n  Syntax declarations were added very recently, and have not been\n  subjected
  to much experimentation yet, so do not be surprised if\n  something is changed before
  the next release.\n\n* Prop has been removed from the language.\n\n  The experimental
  sort Prop has been disabled. Any program using Prop\n  should typecheck if Prop
  is replaced by Set₀. Note that Prop is still\n  a keyword.\n\n* Injective type constructors
  off by default.\n\n  Automatic injectivity of type constructors has been disabled
  (by\n  default). To enable it, use the flag --injective-type-constructors,\n  either
  on the command line or in an OPTIONS pragma. Note that this\n  flag makes Agda anti-classical
  and possibly inconsistent:\n\n    Agda with excluded middle is inconsistent\n    http://thread.gmane.org/gmane.comp.lang.agda/1367\n\n
  \ See test/succeed/InjectiveTypeConstructors.agda for an example.\n\n* Termination
  checker can count.\n\n  There is a new flag --termination-depth=N accepting values
  N >= 1\n  (with N = 1 being the default) which influences the behavior of the\n
  \ termination checker. So far, the termination checker has only\n  distinguished
  three cases when comparing the argument of a recursive\n  call with the formal parameter
  of the callee.\n\n    < : the argument is structurally smaller than the parameter\n
  \   = : they are equal\n    ? : the argument is bigger or unrelated to the parameter\n\n
  \ This behavior, which is still the default (N = 1), will not\n  recognise the following
  functions as terminating.\n\n    mutual\n\n      f : ℕ → ℕ\n      f zero          =
  zero\n      f (suc zero)    = zero\n      f (suc (suc n)) = aux n\n\n      aux :
  ℕ → ℕ\n      aux m = f (suc m)\n\n  The call graph\n\n    f --(<)--> aux --(?)-->
  f\n\n  yields a recursive call from f to f via aux where the relation of\n  call
  argument to callee parameter is computed as \"unrelated\"\n  (composition of < and
  ?).\n\n  Setting N >= 2 allows a finer analysis: n has two constructors less\n  than
  suc (suc n), and suc m has one more than m, so we get the call\n  graph:\n\n    f
  --(-2)--> aux --(+1)--> f\n\n  The indirect call f --> f is now labeled with (-1),
  and the\n  termination checker can recognise that the call argument is\n  decreasing
  on this path.\n\n  Setting the termination depth to N means that the termination\n
  \ checker counts decrease up to N and increase up to N-1. The default,\n  N=1, means
  that no increase is counted, every increase turns to\n  \"unrelated\".\n\n  In practice,
  examples like the one above sometimes arise when \"with\"\n  is used. As an example,
  the program\n\n    f : ℕ → ℕ\n    f zero          = zero\n    f (suc zero)    =
  zero\n    f (suc (suc n)) with zero\n    ... | _ = f (suc n)\n\n  is internally
  represented as\n\n    mutual\n\n      f : ℕ → ℕ\n      f zero          = zero\n
  \     f (suc zero)    = zero\n      f (suc (suc n)) = aux n zero\n\n      aux :
  ℕ → ℕ → ℕ\n      aux m k = f (suc m)\n\n  Thus, by default, the definition of f
  using \"with\" is not accepted\n  by the termination checker, even though it looks
  structural (suc n\n  is a subterm of suc suc n). Now, the termination checker is\n
  \ satisfied if the option \"--termination-depth=2\" is used.\n\n  Caveats:\n\n  -
  This is an experimental feature, hopefully being replaced by\n    something smarter
  in the near future.\n\n  - Increasing the termination depth will quickly lead to
  very long\n    termination checking times. So, use with care. Setting termination\n
  \   depth to 100 by habit, just to be on the safe side, is not a good\n    idea!\n\n
  \ - Increasing termination depth only makes sense for linear data\n    types such
  as ℕ and Size. For other types, increase cannot be\n    recognised. For instance,
  consider a similar example with lists.\n\n      data List : Set where\n\tnil  :
  List\n\tcons : ℕ → List → List\n\n      mutual\n\tf : List → List\n\tf nil                  =
  nil\n\tf (cons x nil)         = nil\n\tf (cons x (cons y ys)) = aux y ys\n\n\taux
  : ℕ → List → List\n\taux z zs = f (cons z zs)\n\n    Here the termination checker
  compares cons z zs to z and also to\n    zs. In both cases, the result will be \"unrelated\",
  no matter how\n    high we set the termination depth. This is because when comparing\n
  \   cons z zs to zs, for instance, z is unrelated to zs, thus,\n    cons z zs is
  also unrelated to zs. We cannot say it is just \"one\n    larger\" since z could
  be a very large term. Note that this points\n    to a weakness of untyped termination
  checking.\n\n    To regain the benefit of increased termination depth, we need to\n
  \   index our lists by a linear type such as ℕ or Size. With\n    termination depth
  2, the above example is accepted for vectors\n    instead of lists.\n\n* The codata
  keyword has been removed. To use coinduction, use the\n  following new builtins:
  INFINITY, SHARP and FLAT. Example:\n\n    {-# OPTIONS --universe-polymorphism #-}\n\n
  \   module Coinduction where\n\n    open import Level\n\n    infix 1000 ♯_\n\n    postulate\n
  \     ∞  : ∀ {a} (A : Set a) → Set a\n      ♯_ : ∀ {a} {A : Set a} → A → ∞ A\n      ♭
  \ : ∀ {a} {A : Set a} → ∞ A → A\n\n    {-# BUILTIN INFINITY ∞  #-}\n    {-# BUILTIN
  SHARP    ♯_ #-}\n    {-# BUILTIN FLAT     ♭  #-}\n\n  Note that (non-dependent)
  pattern matching on SHARP is no longer\n  allowed.\n\n  Note also that strange things
  might happen if you try to combine the\n  pragmas above with COMPILED_TYPE, COMPILED_DATA
  or COMPILED pragmas,\n  or if the pragmas do not occur right after the postulates.\n\n
  \ The compiler compiles the INFINITY builtin to nothing (more or\n  less), so that
  the use of coinduction does not get in the way of FFI\n  declarations:\n\n    data
  Colist (A : Set) : Set where\n      []  : Colist A\n      _∷_ : (x : A) (xs : ∞
  (Colist A)) → Colist A\n\n    {-# COMPILED_DATA Colist [] [] (:) #-}\n\n* Infinite
  types.\n\n  If the new flag --guardedness-preserving-type-constructors is used,\n
  \ then type constructors are treated as inductive constructors when we\n  check
  productivity (but only in parameters, and only if they are\n  used strictly positively
  or not at all). This makes examples such as\n  the following possible:\n\n    data
  Rec (A : ∞ Set) : Set where\n      fold : ♭ A → Rec A\n\n    -- Σ cannot be a record
  type below.\n\n    data Σ (A : Set) (B : A → Set) : Set where\n      _,_ : (x :
  A) → B x → Σ A B\n\n    syntax Σ A (λ x → B) = Σ[ x ∶ A ] B\n\n    -- Corecursive
  definition of the W-type.\n\n    W : (A : Set) → (A → Set) → Set\n    W A B = Rec
  (♯ (Σ[ x ∶ A ] (B x → W A B)))\n\n    syntax W A (λ x → B) = W[ x ∶ A ] B\n\n    sup
  : {A : Set} {B : A → Set} (x : A) (f : B x → W A B) → W A B\n    sup x f = fold
  (x , f)\n\n    W-rec : {A : Set} {B : A → Set}\n            (P : W A B → Set) →\n
  \           (∀ {x} {f : B x → W A B} → (∀ y → P (f y)) → P (sup x f)) →\n            ∀
  x → P x\n    W-rec P h (fold (x , f)) = h (λ y → W-rec P h (f y))\n\n    -- Induction-recursion
  encoded as corecursion-recursion.\n\n    data Label : Set where\n      ′0 ′1 ′2
  ′σ ′π ′w : Label\n\n    mutual\n\n      U : Set\n      U = Σ Label U′\n\n      U′
  : Label → Set\n      U′ ′0 = ⊤\n      U′ ′1 = ⊤\n      U′ ′2 = ⊤\n      U′ ′σ =
  Rec (♯ (Σ[ a ∶ U ] (El a → U)))\n      U′ ′π = Rec (♯ (Σ[ a ∶ U ] (El a → U)))\n
  \     U′ ′w = Rec (♯ (Σ[ a ∶ U ] (El a → U)))\n\n      El : U → Set\n      El (′0
  , _)            = ⊥\n      El (′1 , _)            = ⊤\n      El (′2 , _)            =
  Bool\n      El (′σ , fold (a , b)) = Σ[ x ∶ El a ]  El (b x)\n      El (′π , fold
  (a , b)) =   (x : El a) → El (b x)\n      El (′w , fold (a , b)) = W[ x ∶ El a ]
  \ El (b x)\n\n    U-rec : (P : ∀ u → El u → Set) →\n            P (′1 , _) tt →\n
  \           P (′2 , _) true →\n            P (′2 , _) false →\n            (∀ {a
  b x y} →\n             P a x → P (b x) y → P (′σ , fold (a , b)) (x , y)) →\n            (∀
  {a b f} →\n             (∀ x → P (b x) (f x)) → P (′π , fold (a , b)) f) →\n            (∀
  {a b x f} →\n             (∀ y → P (′w , fold (a , b)) (f y)) →\n             P
  (′w , fold (a , b)) (sup x f)) →\n            ∀ u (x : El u) → P u x\n    U-rec
  P P1 P2t P2f Pσ Pπ Pw = rec\n      where\n      rec : ∀ u (x : El u) → P u x\n      rec
  (′0 , _)            ()\n      rec (′1 , _)            _              = P1\n      rec
  (′2 , _)            true           = P2t\n      rec (′2 , _)            false          =
  P2f\n      rec (′σ , fold (a , b)) (x , y)        = Pσ (rec _ x) (rec _ y)\n      rec
  (′π , fold (a , b)) f              = Pπ (λ x → rec _ (f x))\n      rec (′w , fold
  (a , b)) (fold (x , f)) = Pw (λ y → rec _ (f y))\n\n  The --guardedness-preserving-type-constructors
  extension is based on\n  a rather operational understanding of ∞/♯_; it's not yet
  clear if\n  this extension is consistent.\n\n* Qualified constructors.\n\n  Constructors
  can now be referred to qualified by their data type.\n  For instance, given\n\n
  \   data Nat : Set where\n      zero : Nat\n      suc  : Nat → Nat\n\n    data Fin
  : Nat → Set where\n      zero : ∀ {n} → Fin (suc n)\n      suc  : ∀ {n} → Fin n
  → Fin (suc n)\n\n  you can refer to the constructors unambiguously as Nat.zero,\n
  \ Nat.suc, Fin.zero, and Fin.suc (Nat and Fin are modules containing\n  the respective
  constructors). Example:\n\n    inj : (n m : Nat) → Nat.suc n ≡ suc m → n ≡ m\n    inj
  .m m refl = refl\n\n  Previously you had to write something like\n\n    inj : (n
  m : Nat) → _≡_ {Nat} (suc n) (suc m) → n ≡ m\n\n  to make the type checker able
  to figure out that you wanted the\n  natural number suc in this case.\n\n* Reflection.\n\n
  \ There are two new constructs for reflection:\n\n    - quoteGoal x in e\n\n      In
  e the value of x will be a representation of the goal type\n      (the type expected
  of the whole expression) as an element in a\n      datatype of Agda terms (see below).
  For instance,\n\n      example : ℕ\n      example = quoteGoal x in {! at this point
  x = def (quote ℕ) [] !}\n\n    - quote x : Name\n\n      If x is the name of a definition
  (function, datatype, record, or\n      a constructor), quote x gives you the representation
  of x as a\n      value in the primitive type Name (see below).\n\n  Quoted terms
  use the following BUILTINs and primitives (available\n  from the standard library
  module Reflection):\n\n    -- The type of Agda names.\n\n    postulate Name : Set\n\n
  \   {-# BUILTIN QNAME Name #-}\n\n    primitive primQNameEquality : Name → Name
  → Bool\n\n    -- Arguments.\n\n    Explicit? = Bool\n\n    data Arg A : Set where\n
  \     arg : Explicit? → A → Arg A\n\n    {-# BUILTIN ARG    Arg #-}\n    {-# BUILTIN
  ARGARG arg #-}\n\n    -- The type of Agda terms.\n\n    data Term : Set where\n
  \     var     : ℕ → List (Arg Term) → Term\n      con     : Name → List (Arg Term)
  → Term\n      def     : Name → List (Arg Term) → Term\n      lam     : Explicit?
  → Term → Term\n      pi      : Arg Term → Term → Term\n      sort    : Term\n      unknown
  : Term\n\n    {-# BUILTIN AGDATERM            Term    #-}\n    {-# BUILTIN AGDATERMVAR
  \        var     #-}\n    {-# BUILTIN AGDATERMCON         con     #-}\n    {-# BUILTIN
  AGDATERMDEF         def     #-}\n    {-# BUILTIN AGDATERMLAM         lam     #-}\n
  \   {-# BUILTIN AGDATERMPI          pi      #-}\n    {-# BUILTIN AGDATERMSORT        sort
  \   #-}\n    {-# BUILTIN AGDATERMUNSUPPORTED unknown #-}\n\n  Reflection may be
  useful when working with internal decision\n  procedures, such as the standard library's
  ring solver.\n\n* Minor record definition improvement.\n\n  The definition of a
  record type is now available when type checking\n  record module definitions. This
  means that you can define things\n  like the following:\n\n    record Cat : Set₁
  where\n      field\n        Obj  : Set\n        _=>_ : Obj → Obj → Set\n        --
  ...\n\n      -- not possible before:\n      op : Cat\n      op = record { Obj =
  Obj; _=>_ = λ A B → B => A }\n\nTools\n-----\n\n* The \"Goal type and context\"
  command now shows the goal type before\n  the context, and the context is shown
  in reverse order. The \"Goal\n  type, context and inferred type\" command has been
  modified in a\n  similar way.\n\n* Show module contents command.\n\n  Given a module
  name M the Emacs mode can now display all the\n  top-level modules and names inside
  M, along with types for the\n  names. The command is activated using C-c C-o or
  the menus.\n\n* Auto command.\n\n  A command which searches for type inhabitants
  has been added. The\n  command is invoked by pressing C-C C-a (or using the goal
  menu).\n  There are several flags and parameters, e.g. '-c' which enables\n  case-splitting
  in the search. For further information, see the Agda\n  wiki:\n\n    http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.Auto\n\n*
  HTML generation is now possible for a module with unsolved\n  meta-variables, provided
  that the --allow-unsolved-metas flag is\n  used.\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.2.6\n------------------------------------------------------------------------\n\nImportant
  changes since 2.2.4:\n\nLanguage\n--------\n\n* Universe polymorphism (experimental
  extension).\n\n  To enable universe polymorphism give the flag\n  --universe-polymorphism
  on the command line or (recommended) as an\n  OPTIONS pragma.\n\n  When universe
  polymorphism is enabled Set takes an argument which is\n  the universe level. For
  instance, the type of universe polymorphic\n  identity is\n\n    id : {a : Level}
  {A : Set a} → A → A.\n\n  The type Level is isomorphic to the unary natural numbers
  and should be\n  specified using the BUILTINs LEVEL, LEVELZERO, and LEVELSUC:\n\n
  \   data Level : Set where\n      zero : Level\n      suc  : Level → Level\n\n    {-#
  BUILTIN LEVEL     Level #-}\n    {-# BUILTIN LEVELZERO zero  #-}\n    {-# BUILTIN
  LEVELSUC  suc   #-}\n\n  There is an additional BUILTIN LEVELMAX for taking the
  maximum of two\n  levels:\n\n    max : Level → Level → Level\n    max  zero    m
  \     = m\n    max (suc n)  zero   = suc n\n    max (suc n) (suc m) = suc (max n
  m)\n\n    {-# BUILTIN LEVELMAX max #-}\n\n  The non-polymorphic universe levels
  Set, Set₁ and so on are sugar\n  for Set zero, Set (suc zero), etc.\n\n  At present
  there is no automatic lifting of types from one level to\n  another. It can still
  be done (rather clumsily) by defining types\n  like the following one:\n\n    data
  Lifted {a} (A : Set a) : Set (suc a) where\n      lift : A → Lifted A\n\n  However,
  it is likely that automatic lifting is introduced at some\n  point in the future.\n\n*
  Multiple constructors, record fields, postulates or primitives can\n  be declared
  using a single type signature:\n\n    data Bool : Set where\n      false true :
  Bool\n\n    postulate\n      A B : Set\n\n* Record fields can be implicit:\n\n    record
  R : Set₁ where\n      field\n        {A}         : Set\n        f           : A
  → A\n        {B C} D {E} : Set\n        g           : B → C → E\n\n  By default
  implicit fields are not printed.\n\n* Record constructors can be defined:\n\n    record
  Σ (A : Set) (B : A → Set) : Set where\n      constructor _,_\n      field\n        proj₁
  : A\n        proj₂ : B proj₁\n\n  In this example _,_ gets the type\n\n     (proj₁ : A)
  → B proj₁ → Σ A B.\n\n  For implicit fields the corresponding constructor arguments
  become\n  implicit.\n\n  Note that the constructor is defined in the /outer/ scope,
  so any\n  fixity declaration has to be given outside the record definition.\n  The
  constructor is not in scope inside the record module.\n\n  Note also that pattern
  matching for records has not been implemented\n  yet.\n\n* BUILTIN hooks for equality.\n\n
  \ The data type\n\n    data _≡_ {A : Set} (x : A) : A → Set where\n      refl :
  x ≡ x\n\n  can be specified as the builtin equality type using the following\n  pragmas:\n\n
  \   {-# BUILTIN EQUALITY _≡_  #-}\n    {-# BUILTIN REFL     refl #-}\n\n  The builtin
  equality is used for the new rewrite construct and\n  the primTrustMe primitive
  described below.\n\n* New rewrite construct.\n\n  If eqn : a ≡ b, where _≡_ is the
  builtin equality (see above) you\n  can now write\n\n    f ps rewrite eqn = rhs\n\n
  \ instead of\n\n    f ps with a | eqn\n    ... | ._ | refl = rhs\n\n  The rewrite
  construct has the effect of rewriting the goal and the\n  context by the given equation
  (left to right).\n\n  You can rewrite using several equations (in sequence) by separating\n
  \ them with vertical bars (|):\n\n    f ps rewrite eqn₁ | eqn₂ | … = rhs\n\n  It
  is also possible to add with clauses after rewriting:\n\n    f ps rewrite eqns with
  e\n    ... | p = rhs\n\n  Note that pattern matching happens before rewriting—if
  you want to\n  rewrite and then do pattern matching you can use a with after the\n
  \ rewrite.\n\n  See test/succeed/Rewrite.agda for some examples.\n\n* A new primitive,
  primTrustMe, has been added:\n\n    primTrustMe : {A : Set} {x y : A} → x ≡ y\n\n
  \ Here _≡_ is the builtin equality (see BUILTIN hooks for equality,\n  above).\n\n
  \ If x and y are definitionally equal, then\n  primTrustMe {x = x} {y = y} reduces
  to refl.\n\n  Note that the compiler replaces all uses of primTrustMe with the\n
  \ REFL builtin, without any check for definitional equality. Incorrect\n  uses of
  primTrustMe can potentially lead to segfaults or similar\n  problems.\n\n  For an
  example of the use of primTrustMe, see Data.String in version\n  0.3 of the standard
  library, where it is used to implement decidable\n  equality on strings using the
  primitive boolean equality.\n\n* Changes to the syntax and semantics of IMPORT pragmas,
  which are\n  used by the Haskell FFI. Such pragmas must now have the following\n
  \ form:\n\n    {-# IMPORT <module name> #-}\n\n  These pragmas are interpreted as
  /qualified/ imports, so Haskell\n  names need to be given qualified (unless they
  come from the Haskell\n  prelude).\n\n* The horizontal tab character (U+0009) is
  no longer treated as white\n  space.\n\n* Line pragmas are no longer supported.\n\n*
  The --include-path flag can no longer be used as a pragma.\n\n* The experimental
  and incomplete support for proof irrelevance has\n  been disabled.\n\nTools\n-----\n\n*
  New \"intro\" command in the Emacs mode. When there is a canonical way\n  of building
  something of the goal type (for instance, if the goal\n  type is a pair), the goal
  can be refined in this way. The command\n  works for the following goal types:\n\n
  \   - A data type where only one of its constructors can be used to\n      construct
  an element of the goal type. (For instance, if the\n      goal is a non-empty vector,
  a \"cons\" will be introduced.)\n\n    - A record type. A record value will be introduced.
  Implicit\n      fields will not be included unless showing of implicit arguments\n
  \     is switched on.\n\n    - A function type. A lambda binding as many variables
  as possible\n      will be introduced. The variable names will be chosen from the\n
  \     goal type if its normal form is a dependent function type,\n      otherwise
  they will be variations on \"x\". Implicit lambdas will\n      only be inserted
  if showing of implicit arguments is switched\n      on.\n\n  This command can be
  invoked by using the refine command (C-c C-r)\n  when the goal is empty. (The old
  behaviour of the refine command in\n  this situation was to ask for an expression
  using the minibuffer.)\n\n* The Emacs mode displays \"Checked\" in the mode line
  if the current\n  file type checked successfully without any warnings.\n\n* If a
  file F is loaded, and this file defines the module M, it is an\n  error if F is
  not the file which defines M according to the include\n  path.\n\n  Note that the
  command-line tool and the Emacs mode define the\n  meaning of relative include paths
  differently: the command-line tool\n  interprets them relative to the current working
  directory, whereas\n  the Emacs mode interprets them relative to the root directory
  of the\n  current project. (As an example, if the module A.B.C is loaded from\n
  \ the file <some-path>/A/B/C.agda, then the root directory is\n  <some-path>.)\n\n*
  It is an error if there are several files on the include path which\n  match a given
  module name.\n\n* Interface files are relocatable. You can move around source trees
  as\n  long as the include path is updated in a corresponding way. Note\n  that a
  module M may be re-typechecked if its time stamp is strictly\n  newer than that
  of the corresponding interface file (M.agdai).\n\n* Type-checking is no longer done
  when an up-to-date interface exists.\n  (Previously the initial module was always
  type-checked.)\n\n* Syntax highlighting files for Emacs (.agda.el) are no longer
  used.\n  The --emacs flag has been removed. (Syntax highlighting information\n  is
  cached in the interface files.)\n\n* The Agate and Alonzo compilers have been retired.
  The options\n  --agate, --alonzo and --malonzo have been removed.\n\n* The default
  directory for MAlonzo output is the project's root\n  directory. The --malonzo-dir
  flag has been renamed to --compile-dir.\n\n* Emacs mode: C-c C-x C-d no longer resets
  the type checking state.\n  C-c C-x C-r can be used for a more complete reset. C-c C-x C-s\n
  \ (which used to reload the syntax highlighting information) has been\n  removed.
  C-c C-l can be used instead.\n\n* The Emacs mode used to define some \"abbrevs\",
  unless the user\n  explicitly turned this feature off. The new default is /not/
  to add\n  any abbrevs. The old default can be obtained by customising\n  agda2-mode-abbrevs-use-defaults
  (a customisation buffer can be\n  obtained by typing M-x customize-group agda2 RET
  after an Agda file\n  has been loaded).\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.2.4\n------------------------------------------------------------------------\n\nImportant
  changes since 2.2.2:\n\n* Change to the semantics of \"open import\" and \"open
  module\". The\n  declaration\n\n    open import M <using/hiding/renaming>\n\n  now
  translates to\n\n    import A\n    open A <using/hiding/renaming>\n\n  instead of\n\n
  \   import A <using/hiding/renaming>\n    open A.\n\n  The same translation is used
  for \"open module M = E …\". Declarations\n  involving the keywords as or public
  are changed in a corresponding\n  way (\"as\" always goes with import, and \"public\"
  always with open).\n\n  This change means that import directives do not affect the
  qualified\n  names when open import/module is used. To get the old behaviour you\n
  \ can use the expanded version above.\n\n* Names opened publicly in parameterised
  modules no longer inherit the\n  module parameters. Example:\n\n    module A where\n
  \     postulate X : Set\n\n    module B (Y : Set) where\n      open A public\n\n
  \ In Agda 2.2.2 B.X has type (Y : Set) → Set, whereas in Agda 2.2.4\n  B.X has type
  Set.\n\n* Previously it was not possible to export a given constructor name\n  through
  two different \"open public\" statements in the same module.\n  This is now possible.\n\n*
  Unicode subscript digits are now allowed for the hierarchy of\n  universes (Set₀,
  Set₁, …): Set₁ is equivalent to Set1.\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.2.2\n------------------------------------------------------------------------\n\nImportant
  changes since 2.2.0:\n\nTools\n-----\n\n* The --malonzodir option has been renamed
  to --malonzo-dir.\n\n* The output of agda --html is by default placed in a directory
  called\n  \"html\".\n\nInfrastructure\n--------------\n\n* The Emacs mode is included
  in the Agda Cabal package, and installed\n  by cabal install. The recommended way
  to enable the Emacs mode is to\n  include the following code in .emacs:\n\n    (load-file
  (let ((coding-system-for-read 'utf-8))\n                    (shell-command-to-string
  \"agda-mode locate\")))\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.2.0\n------------------------------------------------------------------------\n\nImportant
  changes since 2.1.2 (which was released 2007-08-16):\n\nLanguage\n--------\n\n*
  Exhaustive pattern checking. Agda complains if there are missing\n  clauses in a
  function definition.\n\n* Coinductive types are supported. This feature is under\n
  \ development/evaluation, and may change.\n\n  http://wiki.portal.chalmers.se/agda/agda.php?n=ReferenceManual.Codatatypes\n\n*
  Another experimental feature: Sized types, which can make it easier\n  to explain
  why your code is terminating.\n\n* Improved constraint solving for functions with
  constructor headed\n  right hand sides.\n\n  http://wiki.portal.chalmers.se/agda/agda.php?n=ReferenceManual.FindingTheValuesOfImplicitArguments\n\n*
  A simple, well-typed foreign function interface, which allows use of\n  Haskell
  functions in Agda code.\n\n  http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Docs.FFI\n\n*
  The tokens forall, -> and \\ can be written as ∀, → and λ.\n\n* Absurd lambdas:
  λ () and λ {}.\n\n  http://thread.gmane.org/gmane.comp.lang.agda/440\n\n* Record
  fields whose values can be inferred can be omitted.\n\n* Agda complains if it spots
  an unreachable clause, or if a pattern\n  variable \"shadows\" a hidden constructor
  of matching type.\n\n  http://thread.gmane.org/gmane.comp.lang.agda/720\n\nTools\n-----\n\n*
  Case-split: The user interface can replace a pattern variable with\n  the corresponding
  constructor patterns. You get one new left-hand\n  side for every possible constructor.\n\n
  \ http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.QuickGuideToEditingTypeCheckingAndCompilingAgdaCode\n\n*
  The MAlonzo compiler.\n\n  http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Docs.MAlonzo\n\n*
  A new Emacs input method, which contains bindings for many Unicode\n  symbols, is
  by default activated in the Emacs mode.\n\n  http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Docs.UnicodeInput\n\n*
  Highlighted, hyperlinked HTML can be generated from Agda source\n  code.\n\n  http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.HowToGenerateWebPagesFromSourceCode\n\n*
  The command-line interactive mode (agda -I) is no longer supported,\n  but should
  still work.\n\n  http://thread.gmane.org/gmane.comp.lang.agda/245\n\n* Reload times
  when working on large projects are now considerably\n  better.\n\n  http://thread.gmane.org/gmane.comp.lang.agda/551\n\nLibraries\n---------\n\n*
  A standard library is under development.\n\n  http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Libraries.StandardLibrary\n\nDocumentation\n-------------\n\n*
  The Agda wiki is better organised. It should be easier for a\n  newcomer to find
  relevant information now.\n\n  http://wiki.portal.chalmers.se/agda/\n\nInfrastructure\n--------------\n\n*
  Easy-to-install packages for Windows and Debian/Ubuntu have been\n  prepared.\n\n
  \ http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.Download\n\n* Agda 2.2.0
  is available from Hackage.\n\n  http://hackage.haskell.org/\n"
basic-deps:
  data-hash: ==0.2.0.0
  bytestring: ! '>=0.9.0.1 && <0.11'
  haskeline: ! '>=0.7 && <0.8'
  base: ! '>=4.2 && <4.8'
  xhtml: ==3000.2.*
  unordered-containers: ==0.2.*
  text: ! '>=0.11 && <1.3'
  strict: ! '>=0.3.2 && <0.4'
  Agda: ==2.4.2.2
  filepath: ! '>=1.1 && <1.4'
  process: ! '>=1.0.1.0 && <1.3'
  array: ! '>=0.1 && <0.6'
  Win32: ! '>=2.2 && <2.4'
  containers: ! '>=0.1 && <0.6'
  haskell-src-exts: ! '>=1.9.6 && <1.17'
  STMonadTrans: ! '>=0.3.2 && <0.4'
  binary: ! '>=0.6 && <0.8'
  epic: ! '>=0.1.13 && <0.10'
  hashtables: ! '>=1.0 && <1.2 || >=1.2.0.2 && <1.3'
  old-time: ! '>=1.0 && <1.2'
  zlib: ! '>=0.4.0.1 && <0.6'
  mtl: ! '>=2.1.1 && <=2.1.3.1 || >=2.2.1 && <2.3'
  hashable: ! '>=1.1.2.3 && <1.2 || >=1.2.1.0 && <1.3'
  transformers: ! '>=0.3 && <0.4 || >=0.4.1.0 && <0.5'
  parallel: <3.3
  deepseq: ==1.3.*
  boxes: ! '>=0.1.3 && <0.2'
  QuickCheck: ! '>=2.7.5 && <2.8'
  equivalence: ! '>=0.2.5 && <0.3'
  pretty: ! '>=1.0 && <1.2'
  template-haskell: ! '>=2.5 && <2.10'
  geniplate: ! '>=0.6.0.3 && <0.7'
  directory: ! '>=1.0 && <1.2'
all-versions:
- '2.2.0'
- '2.2.2'
- '2.2.4'
- '2.2.6'
- '2.2.8'
- '2.2.10'
- '2.3.0'
- '2.3.0.1'
- '2.3.2'
- '2.3.2.1'
- '2.3.2.2'
- '2.4.0'
- '2.4.0.1'
- '2.4.0.2'
- '2.4.2'
- '2.4.2.1'
- '2.4.2.2'
latest: '2.4.2.2'
description-type: markdown
description: ! "Agda 2\n======\n\nTable of contents:\n\n* [Prerequisites](#prerequisites)\n*
  [Installing Agda](#installing-agda)\n* [Configuring the Emacs mode](#configuring-the-emacs-mode)\n*
  [Installing the Epic backend's dependencies](#installing-the-epic-backends-dependencies)\n*
  [Installing Emacs under Windows](#installing-emacs-under-windows)\n\nNote that this
  README only discusses installation of Agda, not its standard\nlibrary. See the [Agda
  Wiki][agdawiki] for information about the library.\n\n\nPrerequisites\n-------------\n\nYou
  need recent versions of the following programs/libraries:\n\n* GHC:           http://www.haskell.org/ghc/\n*
  cabal-install: http://www.haskell.org/cabal/\n* Alex:          http://www.haskell.org/alex/\n*
  Happy:         http://www.haskell.org/happy/\n* cpphs:         http://projects.haskell.org/cpphs/\n*
  GNU Emacs:     http://www.gnu.org/software/emacs/\n\nYou should also make sure that
  programs installed by cabal-install are\non your shell's search path.\n\nFor instructions
  on installing a suitable version of Emacs under\nWindows, see [below]((#installing-emacs-under-windows).\n\nNon-Windows
  users need to ensure that the development files for the C\nlibraries zlib and ncurses
  are installed (see http://zlib.net and\nhttp://www.gnu.org/software/ncurses/). Your
  package manager may be\nable to install these files for you. For instance, on Debian
  or Ubuntu\nit should suffice to run\n\n    apt-get install zlib1g-dev libncurses5-dev\n\nas
  root to get the correct files installed.\n\n### Note on ghc's CPP language extension\n\nRecent
  versions of Clang's preprocessor don't work well with Haskell.\nIn order to get
  some dependencies to build, you may need to set up Cabal\nto have ghc use cpphs
  by default. You can do this by adding\n\n    program-default-options\n      ghc-options:
  -pgmPcpphs -optP--cpp\n\nto your .cabal/config file. (You must be using cabal >=
  1.18. Note\nthat some packages may not compile with this option set.)\n\nYou don't
  need to set this option to install *Agda* from the current\ndevelopment source;
  Agda.cabal now uses cpphs.\n\n\nInstalling Agda\n---------------\n\nThere are several
  ways to install Agda:\n\n\n### Using a binary package prepared for your platform\n\nRecommended
  if such a package exists. See the [Agda Wiki][agdawiki].\n\n\n### Using a released
  source package from Hackage\n\nInstall the prerequisites mentioned below, then run
  the following commands:\n\n    cabal update\n    cabal install Agda\n    agda-mode
  setup\n\nThe last command tries to set up Emacs for use with Agda. As an alternative
  you\ncan copy the following text to your .emacs file:\n\n    (load-file (let ((coding-system-for-read
  'utf-8))\n                    (shell-command-to-string \"agda-mode locate\")))\n\nIt
  is also possible (but not necessary) to compile the Emacs mode's files:\n\n    agda-mode
  compile\n\nThis can, in some cases, give a noticeable speedup.\n\n**WARNING**: If
  you reinstall the Agda mode without recompiling the Emacs\nLisp files, then Emacs
  may continue using the old, compiled files.\n\n\n### Using the development version
  of the code\n\nYou can obtain tarballs of the development version from the [Agda\nWiki][agdawiki],
  or clone the repository.\n\nInstall the prerequisites discussed in [Prerequisites](#prerequisites).\n\nThen,
  either:\n\n*(1a)* Run the following commands in the top-level directory of the Agda
  source\ntree to install Agda:\n\n    cabal update\n    cabal install\n\n*(1b)* Run
  `agda-mode setup` to set up Emacs for use with Agda. Alternatively,\nadd the following
  text to your .emacs file:\n\n    (load-file (let ((coding-system-for-read 'utf-8))\n
  \                   (shell-command-to-string \"agda-mode locate\")))\n\nIt is also
  possible (but not necessary) to compile the Emacs mode's files:\n\n    agda-mode
  compile\n\nThis can, in some cases, give a noticeable speedup.\n\n**WARNING**: If
  you reinstall the Agda mode without recompiling the Emacs\nLisp files, then Emacs
  may continue using the old compiled files.\n\n*(2)* Or, you can try to install Agda
  (including a compiled Emacs mode) by\nrunning the following command:\n\n    make
  install\n\n\nConfiguring the Emacs mode\n--------------------------\n\nIf you want
  to you can customise the Emacs mode. Just start Emacs and\ntype the following:\n\n
  \   M-x load-library RET agda2-mode RET\n    M-x customize-group RET agda2 RET\n\nThis
  is useful if you want to change the Agda search path, in which\ncase you should
  change the agda2-include-dirs variable.\n\nIf you want some specific settings for
  the Emacs mode you can add them\nto agda2-mode-hook. For instance, if you do not
  want to use the Agda\ninput method (for writing various symbols like ∀≥ℕ→π⟦⟧) you
  can add\nthe following to your .emacs:\n\n    (add-hook 'agda2-mode-hook\n              '(lambda
  ()\n                ; If you do not want to use any input method:\n                (deactivate-input-method)\n
  \               ; (In some versions of Emacs you should use\n                ; inactivate-input-method
  instead of\n                ; deactivate-input-method.)\n\n                ; If
  you want to use the X input method:\n                (set-input-method \"X\")))\n\nNote
  that, on some systems, the Emacs mode changes the default font of\nthe current frame
  in order to enable many Unicode symbols to be\ndisplayed. This only works if the
  right fonts are available, though.\nIf you want to turn off this feature, then you
  should customise the\nagda2-fontset-name variable.\n\n\n------------------------------------------------------------------------\nInstalling
  the Epic backend's dependencies\n------------------------------------------------------------------------\n\nThe
  Epic backend is experimental and requires that the Epic program is\ninstalled. You
  can install this program by giving the epic flag to\ncabal (but note that, at the
  time of writing, the Epic program does\nnot build with certain recent versions of
  GHC):\n\n### Installing from Hackage:\n\n    cabal update\n    cabal install Agda
  -fepic\n    agda-mode setup\n\n### Installing from development sources using cabal\n\n
  \   cabal update\n    cabal install -fepic\n    agda-mode setup\n\n### Installing
  from development sources using make\n\n    make CABAL_OPTIONS=-fepic install\n\nYou
  can also install Epic directly:\n\n    cabal install epic\n\nNote that Epic depends
  on other software:\n\n* The Boehm garbage collector: http://www.hpl.hp.com/personal/Hans_Boehm/gc/\n*
  The GNU Multiple Precision Arithmetic Library: http://gmplib.org/\n* GCC, the GNU
  Compiler Collection: http://gcc.gnu.org/\n\nFor more information about Epic: http://www.cs.st-andrews.ac.uk/~eb/epic.php\n\n------------------------------------------------------------------------\nInstalling
  Emacs under Windows\n------------------------------------------------------------------------\n\nA
  precompiled version of Emacs 24.3, with the necessary mathematical\nfonts, is available
  at http://homepage.cs.uiowa.edu/~astump/agda/\n\n[agdawiki]: http://wiki.portal.chalmers.se/agda/pmwiki.php\n"
