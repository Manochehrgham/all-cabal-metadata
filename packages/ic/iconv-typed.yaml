homepage: https://github.com/adinapoli/iconv-typed#readme
changelog-type: ''
hash: 853d7a060c2633258809e73cc689ae9a50c662412bb84c55e67ad8188e8d65cd
test-bench-deps:
  iconv-typed: -any
  base: -any
maintainer: alfredo.dinapoli@gmail.com
synopsis: Type safe iconv wrapper
changelog: ''
basic-deps:
  shelly: <1.8.0.0
  bytestring: -any
  base: ! '>=4.7 && <5'
  text: <1.4.0.0
  iconv: <0.5
  template-haskell: <3.0.0.0
all-versions:
- '0.1.0.0'
- '0.1.0.1'
author: Alfredo Di Napoli
latest: '0.1.0.1'
description-type: haddock
description: ! '[Type safe iconv wrapper]


  An experiment in bringing type safety to the <http://hackage.haskell.org/package/iconv
  iconv> package.


  [Usage Example]


  This is almost a drop-in replacement. Compare the original code from `iconv`:


  > module Main where

  >

  > import Codec.Text.IConv

  >

  > main :: IO ()

  > main = print $ convert "UTF-8" "LATIN1" "hello"


  With the equivalent in `iconv-typed`:


  > module Main where

  >

  > import Codec.Text.IConv.Typed

  >

  > main :: IO ()

  > main = print $ convert (E :: E "UTF-8") (E :: E "LATIN1") "hello"


  As a result, this code will compile and run only if the passed encoding resolves
  to a supported

  encoding (as retrieved at compile time by calling "iconv -l"). For example, the
  following won''t compile:


  > main = print $ convert (E :: E "UFT-8") (E :: E "LATIN1") "hello"


  As `UFT` is mispelled.'
license-name: BSD3
