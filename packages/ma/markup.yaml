changelog-type: ''
hash: 5a6a99d1296ac0b24ee84acf340704ccbc2f097eec68aa98d81460e90e36037e
test-bench-deps:
  base: -any
  hspec: -any
synopsis: Abstraction for markup languages
changelog: ''
basic-deps:
  lucid: ! '>=2.5'
  base: ! '>=4 && <5'
  blaze-markup: -any
  text: -any
  mtl: -any
  blaze-html: -any
  transformers: -any
  urlpath: ! '>=1.0'
all-versions:
- '0.0.1'
- '0.0.2'
- '0.0.3'
- '0.0.4'
- '0.0.5'
- '0.0.6'
- '0.0.6.1'
- '0.0.7'
- '0.0.8'
latest: '0.0.8'
description-type: haddock
description: ! 'This library tries to make things more uniformly controlled when working
  with

  markup languages in haskell - namely /deployment/ of markup assets.


  Deployment, from this library''s perspective, means /how/ something can be

  rendered to markup, yet still achieve the same "result" to the end user (namely

  the DOM).


  We use monad transformers to infer the deployment mechanism for a context of

  markup. The three deployment mechanisms provided include /inline/ (content is

  slapped between markup tags), /hosted/ (entirely external - uses raw text as a

  url), and /local/ (which uses the <hackage.haskell.org/package/urlpath urlpath>

  library to realize what kind of link to create).


  As an example, here is remotely hosted image:


  > image = deploy Image "foo.png" :: HostedMarkupM (Html ())

  >

  > λ> renderMarkup image

  >

  > <img src="foo.png">


  Here is the same example, going relative instead:


  > image :: LocalMarkupM (HtmlT AbsoluteUrl ())

  > image = deploy Image $ "foo.png" <?> ("some","getparam")

  >

  > λ> (runUrlReader $ renderTextT $ renderMarkup image $

  >    ) "example.com"

  >

  > "<img src=\"example.com/foo.png?some=getparam\">"'
