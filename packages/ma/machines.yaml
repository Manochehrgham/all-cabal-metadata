changelog-type: markdown
hash: 6c00ca655eed187aefe091a7dbfb49c08fc0bf89f7c75f11c0a0dfcae9296df8
test-bench-deps:
  base: ==4.*
  filepath: ! '>=1.3 && <1.5'
  criterion: ==0.6.2.*
  doctest: ! '>=0.8 && <=0.10'
  conduit: ==1.0.17.1
  hastache: <0.6
  pipes: ==4.1.0
  mtl: ==2.1.2
  statistics: <0.11
  machines: -any
  directory: ! '>=1.0 && <1.3'
synopsis: Networked stream transducers
changelog: ! '0.4.1

  -----

  * Support `void` 0.7, fixed upper bounds on dependencies going forward.


  0.4.0.1

  -----

  * Bumped the bounds for `mtl` and `transformers`


  0.4

  -----


  0.2.5

  -----

  * Added `deconstruct`, `tagDone` and `finishWith`


  0.2.4

  -----

  * Added `asPats`, `sinkPart_`, `autoM`, and `fitM`


  0.2.1

  -----

  * Fixed the `Mealy` Monad


  0.2

  ---

  * Removed the input type parameter from (almost) all of the types.


  0.1

  ---

  * Initial release

'
basic-deps:
  free: ! '>=3.1.1 && <5'
  void: ! '>=0.6.1 && <1'
  base: ==4.*
  comonad: ! '>=3 && <5'
  pointed: ! '>=3 && <5'
  semigroups: ! '>=0.8.3 && <1'
  containers: ! '>=0.3 && <0.6'
  mtl: ! '>=2 && <2.3'
  transformers: ! '>=0.3 && <0.5'
  profunctors: ! '>=3 && <5'
all-versions:
- '0.1'
- '0.1.1'
- '0.1.2'
- '0.2.1'
- '0.2.1.1'
- '0.2.1.2'
- '0.2.1.3'
- '0.2.2'
- '0.2.3'
- '0.2.3.1'
- '0.2.4'
- '0.2.5'
- '0.4'
- '0.4.0.1'
- '0.4.1'
latest: '0.4.1'
description-type: markdown
description: ! 'machines

  ========


  [![Build Status](https://secure.travis-ci.org/ekmett/machines.png?branch=master)](http://travis-ci.org/ekmett/machines)


  *Ceci n''est pas une pipe*


  Machines are demand driven input sources like pipes or conduits, but can support
  multiple inputs.


  You design a `Machine` by writing a `Plan`. You then `construct` the machine.


  Simple machines that take one input are called a `Process` and processes form a
  `Category`. More generally you can attach a

  `Process` to the output of any type of `Machine`, yielding a new `Machine`.


  More complicated machines provide other ways of connecting to them.


  Typically the use of machines proceeds by using simple plans into machine `Tee`s
  and `Wye`s, capping many of the inputs to

  those with possibly monadic sources, feeding the rest input (possibly repeatedly)
  and calling `run` or `runT` to get the

  answers out.


  There is a lot of flexibility when building a machine in choosing between empowering
  the machine to run its own monadic effects

  or delegating that responsibility to a custom driver.


  A port of this design to scala is available from runarorama/scala-machines


  Runar''s slides are also available from https://dl.dropbox.com/u/4588997/Machines.pdf


  Some worked examples are here https://github.com/alanz/machines-play


  Contact Information

  -------------------


  Contributions and bug reports are welcome!


  Please feel free to contact me through github or on the #haskell IRC channel on
  irc.freenode.net.


  -Edward Kmett

'
