homepage: ''
changelog-type: ''
hash: 1a49ef4347d1d94336377bb566e89776accc292391cadba07a61f53c16ed180b
test-bench-deps: {}
maintainer: david.darais@gmail.com
synopsis: An application of the Galois Transformers framework to two example semantics.
changelog: ''
basic-deps:
  ghc: ==7.8.*
  Cabal: -any
  base: ==4.7.*
  text: -any
  maam: -any
  containers: -any
  template-haskell: -any
  directory: -any
all-versions:
- '0.1.0.0'
- '0.2.0.0'
- '0.2.0.1'
author: David Darais
latest: '0.2.0.1'
description-type: markdown
description: ! "## Building and Running\n\nI recommend building with a cabal sandbox.
  To initialize a cabal sandbox (that\nwill live in the current directory) and install
  needed dependencies, run:\n\n    make sandbox\n\nI have not included dependency
  bounds in my cabal file. Should you have trouble\nfinding appropriate bounds, here
  are the versions of ghc and cabal packages\nthat I am using.\n\n    base=4.7.0.2\n
  \   Cabal=1.18.1.5\n    containers=0.5.5.1\n    directory=1.2.1.0\n    ghc=7.8.4\n
  \   template-haskell=2.9.0.0\n    text=1.2.0.4\n\n## Running\n\nTo run the project,
  displaying an analysis of various lambda-if examples, run:\n\n    make run\n\nExample
  output is included at the end of this readme.\n\n## Interactive (GHCI)\n\nTo support
  my custom (well-formatted and colored) pretty printing in ghci, you\nneed to first
  initialize some ghc flag files:\n\n    make init-flags\n\nThen just run:\n\n    ./ghci.sh\n\nto
  run Main, or:\n\n    ./ghci.sh Lang.LamIf.Examples\n\nto run another module, like
  `Lang.LamIf.Examples`.\n\n## Source Code\n\nAll code is in `/src`.\n\n### FP\n\n`FP`
  is a core functional programming library which replaces the standard\nPrelude. `FP`
  includes more batteries for things like functors, monads, monad\ntransformers, lenses,
  pretty printing, parsing, deriving, and more. On the\ndownside, it is non-idiomatic
  at parts and isn't as mature (i.e. debugged and\nstable).\n\n### MAAM\n\n`MAAM`
  is a semantics-independent package for implement path, flow, context and object\nsensitivity
  in program analysis. `MAAM` only contains types and definitions\nwhich are _analysis
  specific_. Because the monad transformers that capture path\nand flow sensitivity
  are fully general purpose, they are defined in\n`FP.Monads`, not here. The same
  goes for lattice structures, which are mostly\nall defined in `FP.Core`. If I were
  to port `MAAM` to use GHC's Prelude, I\nwould need to rip out maybe 50% of `FP`
  to be packaged alongside it.\n\nThe only code that ends up being specific to analysis
  is:\n\n- Mapping monadic actions to state space transition systems, which is defined\n
  \ in `MAAM.MonadStep`.\n- Implementations for abstract time to infinite-k (concrete),
  finite-k and\n  zero-k, which are defined in `MAAM.Time`.\n\n### LamIf\n\n`Lang.LamIf`
  implements the following for a small applied lambda calculus with\nbooleans and
  if-statements:\n\n- Direct-style syntax (`Lang.LamIf.Syntax`)\n- Continuation passing
  style (CPS) syntax (`Lang.LamIf.CPS`)\n- Parsing (`Lang.LamIf.Parser`) and pretty
  printing (`Lang.LamIf.Pretty`)\n- CPS conversion (`Lang.LamIf.Passes`)\n- Semantics
  state-space (`Lang.LamIf.StateSpace`)\n- Monadic semantics (`Lang.LamIf.Semantics`)\n-
  Concrete and abstract value domains (`Lang.LamIf.Val`)\n- Instantiations of language-independent
  monads from `MAAM` (`Lang.LamIf.Monads`)\n- Orthogonal analysis parameters (`Lang.LamIf.Analyses`)\n-
  Example analyses (`Lang.LamIf.Examples`)\n\n### Hask\n\nA semantics for GHC core
  is implemented in `Lang.Hask`:\n\n- CPS syntax and conversion (`Lang.Hask.CPS`)\n-
  Pretty printing (`Lang.Hask.Pretty`)\n- Monadic semantics (`Lang.Hask.Semantics`)\n-
  Execution semantics (`Lang.Hask.Execution`)\n- Instantiations of language-independent
  monads from `MAAM` (`Lang.Hask.Monads`)\n- Concrete value domain (`Lang.Hask.ValConcrete`)\n-
  Lifting of an arbitrary value domain to a sum-of-products lattice (`Lang.Hask.SumOfProdVal`)\n\nWhile
  the core semantics for core GHC is implemented, we haven't implemented\nany GHC
  primitives yet, but you should be able to get a feel for the semantics\nwithout
  the primitives. (More on this coming soon.)\n\n## Example Output\n\nIf you execute
  the project it will compute an abstract interpretation of some\nvery small `LamIf`
  programs.\n\nThe output includes results for the heap when it reaches any `HALT`
  state:\n\nBelow is a copy of the (normally ANSI-terminal-color-coded) output of
  `make\nrun`. For 0CFA results the state space will contain `∙` values and abstract\nenvironments
  mapping variables to themselves, which are degenerate encodings of\n(unused) call-site
  sensitivity. The abstract heap will come last, mapping\nvariables to the values
  they take on. This is also the example from the Galois\nTransformers paper. More
  examples programs can be found in `/data/lamif-src`,\nwith example configurations
  found in `/src/Lang/LamIf/Examples.hs`.\n    \n    Source\n    let b := 1 - 1 >=
  0 in\n    let v := if b\n        then if b then 1 else 2\n        else if b then
  3 else 4\n    in\n    let w := if b then 5 else 6 in <v,w>\n    Stamped\n    0:let
  0:b := 1:(2:(3:1) - (4:1)) >= (5:0) in\n    6:let 1:v := 7:if 8:0:b\n        then
  9:if 10:0:b then 11:1 else 12:2\n        else 13:if 14:0:b then 15:3 else 16:4\n
  \   in\n    17:let 2:w := 18:if 19:0:b then 20:5 else 21:6 in\n    22:<23:1:v,24:2:w>\n
  \   CPS\n    25:3:a#0 := 2:1 - 1\n    0:0:b := 1:(3:a#0) >= 0\n    33:8:k#5 := 32:λ
  4:x#1 ->\n      6:1:v := 7:4:x#1\n      29:7:k#4 := 28:λ 5:x#2 ->\n        17:2:w
  := 18:5:x#2\n        26:6:a#3 := 22:<1:v,2:w>\n        27:HALT (6:a#3)\n      18:if
  0:b then 30:(7:k#4) 5 else 31:(7:k#4) 6\n    7:if 0:b\n      then\n        9:if
  0:b then 34:(8:k#5) 1 else 35:(8:k#5) 2\n      else\n        13:if 0:b then 36:(8:k#5)
  3 else 37:(8:k#5) 4\n    LT=0 DT=0 V=abstract M=fi G=yes C=link LF=app DF=app\n
  \   ( { ( 27:HALT (6:a#3)\n        , ( ∙\n          , ∙\n          , { 0:b => <x=0:b,lτ=∙,dτ=∙>\n
  \           , 1:v => <x=1:v,lτ=∙,dτ=∙>\n            , 2:w => <x=2:w,lτ=∙,dτ=∙>\n
  \           , 3:a#0 => <x=3:a#0,lτ=∙,dτ=∙>\n            , 4:x#1 => <x=4:x#1,lτ=∙,dτ=∙>\n
  \           , 5:x#2 => <x=5:x#2,lτ=∙,dτ=∙>\n            , 6:a#3 => <x=6:a#3,lτ=∙,dτ=∙>\n
  \           }\n          )\n        )\n      }\n    , { <x=1:v,lτ=∙,dτ=∙> => {1,2,3,4}\n
  \     , <x=2:w,lτ=∙,dτ=∙> => {5,6}\n      , <x=6:a#3,lτ=∙,dτ=∙> =>\n          {<<x=1:v,lτ=∙,dτ=∙>,<x=2:w,lτ=∙,dτ=∙>>}\n
  \     }\n    )\n    LT=0 DT=0 V=abstract M=fs G=yes C=link LF=app DF=app\n    {
  27:HALT (6:a#3) =>\n        ( { ( ∙\n            , ∙\n            , { 0:b => <x=0:b,lτ=∙,dτ=∙>\n
  \             , 1:v => <x=1:v,lτ=∙,dτ=∙>\n              , 2:w => <x=2:w,lτ=∙,dτ=∙>\n
  \             , 3:a#0 => <x=3:a#0,lτ=∙,dτ=∙>\n              , 4:x#1 => <x=4:x#1,lτ=∙,dτ=∙>\n
  \             , 5:x#2 => <x=5:x#2,lτ=∙,dτ=∙>\n              , 6:a#3 => <x=6:a#3,lτ=∙,dτ=∙>\n
  \             }\n            )\n          }\n        , { <x=1:v,lτ=∙,dτ=∙> => {1,4}\n
  \         , <x=2:w,lτ=∙,dτ=∙> => {5,6}\n          , <x=6:a#3,lτ=∙,dτ=∙> =>\n              {<<x=1:v,lτ=∙,dτ=∙>,<x=2:w,lτ=∙,dτ=∙>>}\n
  \         }\n        )\n    }\n    LT=0 DT=0 V=abstract M=ps G=yes C=link LF=app
  DF=app\n    { ( 27:HALT (6:a#3)\n      , ( ( ∙\n          , ∙\n          , { 0:b
  => <x=0:b,lτ=∙,dτ=∙>\n            , 1:v => <x=1:v,lτ=∙,dτ=∙>\n            , 2:w
  => <x=2:w,lτ=∙,dτ=∙>\n            , 3:a#0 => <x=3:a#0,lτ=∙,dτ=∙>\n            ,
  4:x#1 => <x=4:x#1,lτ=∙,dτ=∙>\n            , 5:x#2 => <x=5:x#2,lτ=∙,dτ=∙>\n            ,
  6:a#3 => <x=6:a#3,lτ=∙,dτ=∙>\n            }\n          )\n        , { <x=1:v,lτ=∙,dτ=∙>
  => {1}\n          , <x=2:w,lτ=∙,dτ=∙> => {5}\n          , <x=6:a#3,lτ=∙,dτ=∙> =>\n
  \             {<<x=1:v,lτ=∙,dτ=∙>,<x=2:w,lτ=∙,dτ=∙>>}\n          }\n        )\n
  \     )\n    , ( 27:HALT (6:a#3)\n      , ( ( ∙\n          , ∙\n          , { 0:b
  => <x=0:b,lτ=∙,dτ=∙>\n            , 1:v => <x=1:v,lτ=∙,dτ=∙>\n            , 2:w
  => <x=2:w,lτ=∙,dτ=∙>\n            , 3:a#0 => <x=3:a#0,lτ=∙,dτ=∙>\n            ,
  4:x#1 => <x=4:x#1,lτ=∙,dτ=∙>\n            , 5:x#2 => <x=5:x#2,lτ=∙,dτ=∙>\n            ,
  6:a#3 => <x=6:a#3,lτ=∙,dτ=∙>\n            }\n          )\n        , { <x=1:v,lτ=∙,dτ=∙>
  => {4}\n          , <x=2:w,lτ=∙,dτ=∙> => {6}\n          , <x=6:a#3,lτ=∙,dτ=∙> =>\n
  \             {<<x=1:v,lτ=∙,dτ=∙>,<x=2:w,lτ=∙,dτ=∙>>}\n          }\n        )\n
  \     )\n    }\n"
license-name: BSD3
