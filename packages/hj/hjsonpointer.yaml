homepage: https://github.com/seagreen/hjsonpointer
changelog-type: markdown
hash: c2ef2e5b95559e8a6ffd8cb193cbf7c9a721c6dad6acf8f43f7af847322d7999
test-bench-deps:
  test-framework-hunit: ! '>=0.3 && <0.4'
  test-framework: ! '>=0.8 && <0.9'
  base: -any
  unordered-containers: -any
  text: -any
  test-framework-quickcheck2: ! '>=0.3 && <0.4'
  HUnit: ! '>=1.2 && <1.4'
  hjsonpointer: -any
  http-types: ! '>=0.8 && <0.10'
  aeson: -any
  vector: -any
maintainer: ian@housejeffries.com
synopsis: JSON Pointer library
changelog: ! '# 0.3


  + Rewrite.


  # 0.2


  + Fix mistake in `resolveRefTok`.

  + Split errors over two types.

  + Switch the order of pointer and value arguments for functions that take both.
  The pointer now comes first.


  # 0.1


  + Initial implementation.

'
basic-deps:
  base: ! '>=4.6 && <4.9'
  unordered-containers: ! '>=0.2 && <0.3'
  text: ! '>=1.2 && <1.3'
  hjsonpointer: -any
  QuickCheck: ! '>=2.8 && <2.9'
  aeson: ! '>=0.7 && <0.12'
  vector: ! '>=0.10 && <0.12'
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.2.0.0'
- '0.2.0.1'
- '0.2.0.2'
- '0.2.0.3'
- '0.2.0.4'
- '0.3.0.0'
author: Ian Grant Jeffries
latest: '0.3.0.0'
description-type: markdown
description: ! "# Summary\n\n[JSON Pointer](http://tools.ietf.org/html/rfc6901) library
  for Haskell.\n\n[Hackage](https://hackage.haskell.org/package/hjsonpointer) / [GitHub](https://github.com/seagreen/hjsonpointer)
  / [Travis CI](https://travis-ci.org/seagreen/hjsonpointer)\n\n# Example\n\n```haskell\n{-#
  LANGUAGE OverloadedStrings #-}\n\nmodule Main where\n\nimport           Control.Monad
  \     (unless)\nimport           Data.Aeson\nimport qualified Data.Aeson.Pointer
  as P\n\nmain :: IO ()\nmain = do\n  -- JSON Pointers must either be empty or start
  with a /.\n  pntr1 <- case P.unescape \"/foo/0\" of\n             Left _     ->
  error \"Failed to construct JSON Pointer.\"\n             Right pntr -> pure pntr\n\n
  \ -- We can also write JSON Pointers in Haskell.\n  let pntr2 = P.Pointer [P.Token
  \"/\"]\n  -- When we do this we don't have to escape / or ~ characters\n  -- (as
  ~1 and ~0 respectively) like we do in an escaped JSON\n  -- Pointer string.\n  unless
  (P.unescape \"/~1\" == Right pntr2) (error \"ohno!\")\n\n  print (P.resolve pntr1
  document)\n  print (P.resolve pntr2 document)\n\n  where\n    document :: Value\n
  \   document = object [ \"foo\" .= [String \"bar\", String \"baz\"]\n                      ,
  \"/\"   .= String \"quux\"\n                      ]\n```\n\nOutput:\n```\nRight
  (String \"bar\")\nRight (String \"quux\")\n```\n"
license-name: MIT
