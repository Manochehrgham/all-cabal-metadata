homepage: https://github.com/AccelerateHS/accelerate/
changelog-type: markdown
hash: 83124bcd74ba34b29dc3235eccf74b796aec9444afa86ab66165cbf7eb6ba154
test-bench-deps: {}
maintainer: Trevor L. McDonell <tmcdonell@cse.unsw.edu.au>
synopsis: An embedded language for accelerated array processing
changelog: ! "1.0.0.0\n\n  * Many API and internal changes\n\n  * Bug fixes and other
  enhancements\n\n0.15.0.0\n\n  * Bug fixes and performance improvements.\n\n0.14.0.0\n\n
  \ * New iteration constructs.\n\n  * Additional Prelude-like functions.\n\n  * Improved
  code generation and fusion optimisation.\n\n  * Concurrent kernel execution in the
  CUDA backend.\n\n  * Bug fixes.\n\n0.13.0.0\n\n  * New array fusion optimisation.\n\n
  \ * New foreign function interface for array and scalar expressions.\n\n  * Additional
  Prelude-like functions.\n\n  * New example programs.\n\n  * Bug fixes and performance
  improvements.\n\n0.12.0.0\n\n  * Full sharing recovery in scalar expressions and
  array computations.\n\n  * Two new example applications in package `accelerate-examples`:
  Real-time\n    Canny edge detection and an interactive fluid flow simulator (both
  including\n    a graphical frontend).\n\n  * Bug fixes.\n\n0.11.0.0\n\n  * New Prelude-like
  functions `zip*`, `unzip*`, `fill`, `enumFrom*`, `tail`,\n    `init`, `drop`, `take`,
  `slit`, `gather*`, `scatter*`, and `shapeSize`.\n\n  * New simplified AST (in package
  `accelerate-backend-kit`) for backend writers\n    who want to avoid the complexities
  of the type-safe AST.\n\n0.10.0.0\n\n  * Complete sharing recovery for scalar expressions
  (but currently disabled by\n    default).\n\n  * Also bug fixes in array sharing
  recovery and a few new convenience\n    functions.\n\n0.9.0.0\n\n  * Streaming computations\n\n
  \ * Precompilation\n\n  * Repa-style array indices\n\n  * Additional collective
  operations supported by the CUDA backend: `stencil`s,\n    more `scan`s, rank-polymorphic
  `fold`, `generate`.\n\n  * Conversions to other array formats\n\n  * Bug fixes\n\n0.8.1.0\n\n
  \ * Bug fixes and some performance tweaks.\n\n0.8.0.0\n\n  * More collective operations
  supported by the CUDA backend: `replicate`,\n    `slice` and `foldSeg`. Frontend
  and interpreter support for `stencil`.\n\n  * Bug fixes.\n\n0.7.1.0\n\n  * Initial
  release of the CUDA backend\n\n"
basic-deps:
  exceptions: ! '>=0.6'
  unix: -any
  base: ! '>=4.7 && <4.10'
  time: ! '>=1.4'
  unordered-containers: ! '>=0.2'
  fclabels: ! '>=2.0'
  unique: -any
  filepath: ! '>=1.0'
  base-orphans: ! '>=0.3'
  containers: ! '>=0.3'
  hashtables: ! '>=1.0'
  ghc-prim: -any
  mtl: ! '>=2.0'
  hashable: ! '>=1.1'
  transformers: ! '>=0.3'
  deepseq: ! '>=1.3'
  pretty: ! '>=1.0'
  template-haskell: -any
  directory: ! '>=1.0'
all-versions:
- '0.4.0'
- '0.5.0.0'
- '0.6.0.0'
- '0.7.1.0'
- '0.8.0.0'
- '0.8.1.0'
- '0.9.0.0'
- '0.9.0.1'
- '0.10.0.0'
- '0.12.0.0'
- '0.12.1.0'
- '0.12.2.0'
- '0.13.0.0'
- '0.13.0.1'
- '0.13.0.2'
- '0.13.0.3'
- '0.13.0.4'
- '0.13.0.5'
- '0.14.0.0'
- '0.15.0.0'
- '0.15.1.0'
- '1.0.0.0'
author: ! 'Manuel M T Chakravarty,

  Robert Clifton-Everest,

  Gabriele Keller,

  Ben Lever,

  Trevor L. McDonell,

  Ryan Newtown,

  Sean Seefried'
latest: '1.0.0.0'
description-type: haddock
description: ! '@Data.Array.Accelerate@ defines an embedded array language for computations

  for high-performance computing in Haskell. Computations on multi-dimensional,

  regular arrays are expressed in the form of parameterised collective

  operations, such as maps, reductions, and permutations. These computations may

  then be online compiled and executed on a range of architectures.


  [/A simple example/]


  As a simple example, consider the computation of a dot product of two vectors

  of floating point numbers:


  > dotp :: Acc (Vector Float) -> Acc (Vector Float) -> Acc (Scalar Float)

  > dotp xs ys = fold (+) 0 (zipWith (*) xs ys)


  Except for the type, this code is almost the same as the corresponding Haskell

  code on lists of floats. The types indicate that the computation may be

  online-compiled for performance - for example, using

  @Data.Array.Accelerate.LLVM.PTX@ it may be on-the-fly off-loaded to the GPU.


  [/Additional components/]


  The following supported add-ons are available as separate packages. Install

  them from Hackage with @cabal install \<package\>@


  * @accelerate-llvm-native@: Backend supporting parallel execution on

  multicore CPUs.


  * @accelerate-llvm-ptx@: Backend supporting parallel execution on

  CUDA-capable NVIDIA GPUs. Requires a GPU with compute capability 2.0 or

  greater. See the following table for supported GPUs:

  <http://en.wikipedia.org/wiki/CUDA#Supported_GPUs>


  * @accelerate-cuda@: Backend targeting CUDA-enabled NVIDIA GPUs. Requires

  a GPU with compute compatibility 1.2 or greater. /NOTE: This backend is

  being deprecated in favour of @accelerate-llvm-ptx@./


  * @accelerate-examples@: Computational kernels and applications showcasing

  the use of Accelerate as well as a regression test suite, supporting

  function and performance testing.


  * @accelerate-io@: Fast conversions between Accelerate arrays and other

  array formats (including vector and repa).


  * @accelerate-fft@: Discrete Fourier transforms, with FFI bindings to

  optimised implementations.


  * @accelerate-bignum@: Fixed-width large integer arithmetic.


  * @colour-accelerate@: Colour representations in Accelerate (RGB, sRGB, HSV,

  and HSL).


  * @gloss-accelerate@: Generate gloss pictures from Accelerate.


  * @gloss-raster-accelerate@: Parallel rendering of raster images and

  animations.


  * @lens-accelerate@: Lens operators for Accelerate types.


  * @linear-accelerate@: Linear vector spaces in Accelerate.


  * @mwc-random-accelerate@: Generate Accelerate arrays filled with high

  quality pseudorandom numbers.


  [/Examples and documentation/]


  Haddock documentation is included in the package


  The @accelerate-examples@ package demonstrates a range of computational

  kernels and several complete applications, including:


  * An implementation of the Canny edge detection algorithm


  * An interactive Mandelbrot set generator


  * A particle-based simulation of stable fluid flows


  * An /n/-body simulation of gravitational attraction between solid particles


  * An implementation of the PageRank algorithm


  * A simple interactive ray tracer


  * A particle based simulation of stable fluid flows


  * A cellular automata simulation


  * A \"password recovery\" tool, for dictionary lookup of MD5 hashes


  @lulesh-accelerate@ is an implementation of the Livermore Unstructured

  Lagrangian Explicit Shock Hydrodynamics (LULESH) mini-app. LULESH represents a

  typical hydrodynamics code such as ALE3D, but is highly simplified and

  hard-coded to solve the Sedov blast problem on an unstructured hexahedron

  mesh.


  [/Mailing list and contacts/]


  * Mailing list: <accelerate-haskell@googlegroups.com> (discussion of both

  use and development welcome).


  * Sign up for the mailing list here:

  <http://groups.google.com/group/accelerate-haskell>


  * Bug reports and issue tracking:

  <https://github.com/AccelerateHS/accelerate/issues>

'
license-name: BSD3
