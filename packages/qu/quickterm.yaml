homepage: https://github.com/SamuelSchlesinger/Quickterm
changelog-type: ''
hash: b2c8f227dafb1de46f02e5651913ab13b818c790ca47305d44e10e45c4e565ef
test-bench-deps: {}
maintainer: sgschlesinger@gmail.com
synopsis: An interface for describing and executing terminal applications
changelog: ''
basic-deps:
  edit-distance: -any
  base: ! '>=4.8 && <4.9'
  hashmap: -any
all-versions:
- '0.1.0.0'
author: Samuel Schlesinger
latest: '0.1.0.0'
description-type: markdown
description: ! "#Quickterm [Quick Haskell Terminal Interfaces]\n\n##First Look (Thoughts)\n\nI
  often want to port certain functions I write to a command line interface. Assuming
  the existence of various functions which map from a set of command line arguments
  to an action of type IO (), this involes parsing arguments, options, and generating
  some usage information which should give you an idea of how to use the application
  if you go wrong.\n\nI originally solved this with the idea of a Feature, which could
  be a Program with a list of features, or a Command, which contains a function [String]
  -> IO (). I did not include the concept of an option within this and I would like
  to handle this properly here. Both of the constructions of a Feature contained as
  well a name and a usage string, something which can recursively be generated and
  printed to the user upon failure to find a Command to run.\n\nI want to step back
  from this and take a more principled view, seeing which useful Haskell typeclasses
  within which I can instantiate the various types I found useful in the last attempt.
  (Looking back, basically none were needed or would have added much as far as I can
  see. Living in the IO Monad is basically enough.) \n\n##Second Look (First Interface)\n\nimporting
  the Quickterm module will give you the following definitions:\n\n> type Name = String
  -- I like this better than saying String everywhere, more meaning.\n\n> type Usage
  = String -- I like to describe things with characters, ideally with words.\n\n>
  type Args = [String] -- Nothing special here\n\n> type Options = Map Name [String]
  -- The options are a mapping from Name -> [String]\n> -- It's rather important to
  note that an option of the form -X takes no argument,\n> -- an option of the form
  --X can take one, ---X two, and so on.\n\n> type TerminalAction = Args -> Options
  -> IO () -- The sort of action we can perform\n\n> data Quickterm = Choice Name
  [Quickterm] Usage\n               | Command Name TerminalAction Usage \n\n> usage
  :: Quickterm -> String -- Generates the usage string\n\n> quickrun :: [String] ->
  Quickterm -> IO () -- Runs the program on the raw arguments\n\n"
license-name: GPL-3
