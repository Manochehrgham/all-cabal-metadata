changelog-type: ''
hash: 1c739251e96a25c226a1dcb48d4d1958c337d9ab68295398bd49badece668365
synopsis: Efficient Arrays
changelog: ''
all-versions:
- '0.1'
- '0.2'
- '0.3'
- '0.3.1'
- '0.4'
- '0.4.1'
- '0.4.2'
- '0.5'
- '0.6'
- '0.6.0.1'
- '0.6.0.2'
- '0.7'
- '0.7.0.1'
- '0.7.1'
- '0.8'
- '0.9'
- '0.9.1'
- '0.10'
- '0.10.0.1'
- '0.10.9.0'
- '0.10.9.1'
- '0.10.9.2'
- '0.10.9.3'
- '0.10.10.0'
- '0.10.11.0'
- '0.10.12.0'
- '0.10.12.1'
- '0.10.12.2'
- '0.10.12.3'
latest: '0.10.12.3'
description-type: haddock
description: ! '

  An efficient implementation of Int-indexed arrays (both mutable

  and immutable), with a powerful loop optimisation framework .


  It is structured as follows:


  ["Data.Vector"] Boxed vectors of arbitrary types.


  ["Data.Vector.Unboxed"] Unboxed vectors with an adaptive

  representation based on data type families.


  ["Data.Vector.Storable"] Unboxed vectors of ''Storable'' types.


  ["Data.Vector.Primitive"] Unboxed vectors of primitive types as

  defined by the @primitive@ package. "Data.Vector.Unboxed" is more

  flexible at no performance cost.


  ["Data.Vector.Generic"] Generic interface to the vector types.


  There is also a (draft) tutorial on common uses of vector.


  * <http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial>'
