homepage: https://github.com/jwaldmann/haskell-obdd
changelog-type: ''
hash: 5150e7d7adccf56a4f3c525e36cfe04a5a8ac03333f7e31d418d845ef889750e
test-bench-deps:
  base: -any
  array: -any
  containers: -any
  obdd: -any
maintainer: Johannes Waldmann
synopsis: Ordered Reduced Binary Decision Diagrams
changelog: ''
basic-deps:
  base: ==4.*
  process: -any
  array: -any
  containers: ! '>=0.5'
  mtl: -any
  random: -any
all-versions:
- '0.2'
- '0.2.3'
- '0.2.5'
- '0.2.7'
- '0.3.1'
- '0.3.2'
- '0.3.3'
- '0.4.0'
- '0.5.0'
- '0.6.0'
author: Johannes Waldmann
latest: '0.6.0'
description-type: haddock
description: ! 'Construct, combine and query OBDDs;

  an efficient representation for formulas in propositional logic.


  This is mostly educational.

  The BDDs do not share nodes and this might introduce inefficiencies.


  An important (for me, in teaching) feature is

  that I can immediately draw the BDD to an X11 window (via graphviz).

  For example, to show the effect of different variable orderings,

  try this in ghci:


  > import qualified Prelude as P

  > import OBDD

  > let f [] = false; f (x:y:zs) = x && y || f zs

  > display P.$ f P.$ P.map variable [1,2,3,4,5,6]

  > display P.$ f P.$ P.map variable [1,4,2,5,3,6]

  If you want better performance,

  use <http://vlsi.colorado.edu/%7Efabio/CUDD/ CUDD>

  <https://hackage.haskell.org/package/cudd Haskell bindings>,

  see <https://gitlab.imn.htwk-leipzig.de/waldmann/min-comp-sort this example>.'
license-name: GPL
